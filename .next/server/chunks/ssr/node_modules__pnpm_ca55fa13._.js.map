{"version":3,"sources":["../../../../node_modules/.pnpm/%40tma.js%2Bsignals%401.0.1/node_modules/%40tma.js/signals/src/batch.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsignals%401.0.1/node_modules/%40tma.js/signals/src/signal.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsignals%401.0.1/node_modules/%40tma.js/signals/src/computed.ts","../../../../node_modules/.pnpm/valibot%401.2.0_typescript%405.9.3/node_modules/valibot/dist/index.mjs","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/casing/camelToKebab.ts","../../../../node_modules/.pnpm/%40tma.js%2Btransformers%401.1.1_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/function.js","../../../../node_modules/.pnpm/better-promises%401.0.0/node_modules/better-promises/node_modules/.pnpm/error-kid%401.0.1/node_modules/error-kid/dist/index.js","../../../../node_modules/.pnpm/error-kid%401.0.2/node_modules/error-kid/src/createIsInstanceOf.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/casing/camelToSnake.ts","../../../../node_modules/.pnpm/error-kid%401.0.2/node_modules/error-kid/src/errorClass.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/casing/camelToSnakeObjKeys.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/casing/snakeToCamel.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/casing/snakeToCamelObjKeys.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/casing/deepSnakeToCamelObjKeys.ts","../../../../node_modules/.pnpm/error-kid%401.0.2/node_modules/error-kid/src/errorClassWithData.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/casing/snakeToKebab.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/storage/storage.ts","../../../../node_modules/.pnpm/better-promises%401.0.0/node_modules/better-promises/src/errors.ts","../../../../node_modules/.pnpm/%40tma.js%2Btransformers%401.1.1_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/internal.js","../../../../node_modules/.pnpm/%40tma.js%2Btransformers%401.1.1_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Either.js","../../../../node_modules/.pnpm/better-promises%401.0.0/node_modules/better-promises/src/resolved-utils.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/createCbCollector.ts","../../../../node_modules/.pnpm/better-promises%401.0.0/node_modules/better-promises/src/BetterPromise.ts","../../../../node_modules/.pnpm/%40tma.js%2Btransformers%401.1.1_typescript%405.9.3/node_modules/%40tma.js/transformers/src/transformers.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/createLogger.ts","../../../../node_modules/.pnpm/%40tma.js%2Btransformers%401.1.1_typescript%405.9.3/node_modules/%40tma.js/transformers/src/pipes.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/function.js","../../../../node_modules/.pnpm/%40tma.js%2Btransformers%401.1.1_typescript%405.9.3/node_modules/%40tma.js/transformers/src/rgb.ts","../../../../node_modules/.pnpm/%40tma.js%2Btransformers%401.1.1_typescript%405.9.3/node_modules/%40tma.js/transformers/src/structures.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/internal.js","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Either.js","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/EitherT.js","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Task.js","../../../../node_modules/.pnpm/%40tma.js%2Btransformers%401.1.1_typescript%405.9.3/node_modules/%40tma.js/transformers/src/parsers.ts","../../../../node_modules/.pnpm/%40tma.js%2Btransformers%401.1.1_typescript%405.9.3/node_modules/%40tma.js/transformers/src/serializers.ts","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/TaskEither.js","../../../../node_modules/.pnpm/%40tma.js%2Btoolkit%401.0.2/node_modules/%40tma.js/toolkit/src/monads.ts","../../../../node_modules/.pnpm/mitt%403.0.1/node_modules/mitt/src/index.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/env/hasWebviewProxy.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/function.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/env/isIframe.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/function.js","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/internal.js","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Apply.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/internal.js","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Functor.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Either.js","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Chain.js","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Either.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Option.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/EitherT.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Task.js","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/helpers/access.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/composables/Mountable.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/TaskEither.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/errors.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/helpers/removeUndefined.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/helpers/shallowEqual.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/composables/Stateful.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/launch-params.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/helpers/createIsSupportedSignal.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Option.js","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/with-checks/throwifyWithChecksFp.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/events/createEmitter.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/EitherT.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/events/emitEvent.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Task.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/globals.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/obj-prop-helpers.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/TaskEither.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/events/emitter.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/errors.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/methods/postMessage.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/methods/postEvent.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/utils/request2.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/with-checks/withChecksFp.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/env/isTMA.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/env/mockTelegramEnv.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/composables/Button.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/methods/captureSameReq.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/methods/getReleaseVersion.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/utils/compareVersions.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/methods/supports.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/methods/createPostEvent.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/utils/invokeCustomMethod.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/BackButton/BackButton.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/utils/request.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/applyPolyfills.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/base64-url.ts","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/node_modules/.pnpm/fp-ts%402.16.11/node_modules/fp-ts/es6/Json.js","../../../../node_modules/.pnpm/%40tma.js%2Bbridge%402.2.0_typescript%405.9.3/node_modules/%40tma.js/bridge/src/start-param.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/sharedFeatureOptions.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/createFnOption.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/globals/signals-registry.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/globals/postEvent.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/withPostEvent.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/helpers/component-storage.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/helpers/navigation.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/withStateRestore.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/globals/version.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/withVersion.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/buttonOptions.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/BackButton/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/composables/AsyncMountable.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/Biometry/Biometry.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/globals/request.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/withRequest.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/Biometry/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/ClosingBehavior/ClosingBehavior.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/ClosingBehavior/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/CloudStorage/CloudStorage.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/globals/createRequestId.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/globals/invokeCustomMethod.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/withInvokeCustomMethod.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/CloudStorage/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/DeviceStorage/DeviceStorage.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/withCreateRequestId.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/DeviceStorage/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/emoji-status/requestEmojiStatusAccess.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/emoji-status/setEmojiStatus.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/HapticFeedback/HapticFeedback.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/HapticFeedback/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/home-screen/addToHomeScreen.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/home-screen/checkHomeScreenStatus.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/InitData/InitData.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/InitData/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/Invoice/Invoice.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/Invoice/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/links/openLink.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/links/openTelegramLink.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/links/shareURL.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/LocationManager/LocationManager.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/LocationManager/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/MainButton/MainButton.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/helpers/css-vars.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/helpers/isColorDark.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/ThemeParams/ThemeParams.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/globals/themeParams.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/ThemeParams/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/fn-options/bottomButtonOptions.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/MainButton/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/MiniApp/MiniApp.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/MiniApp/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/Popup/prepareParams.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/Popup/Popup.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/Popup/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/privacy/requestPhoneAccess.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/privacy/requestContact.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/privacy/requestWriteAccess.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/QrScanner/QrScanner.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/QrScanner/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/SecondaryButton/SecondaryButton.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/SecondaryButton/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/SecureStorage/SecureStorage.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/SecureStorage/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/SettingsButton/SettingsButton.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/SettingsButton/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/SwipeBehavior/SwipeBehavior.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/SwipeBehavior/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/copyTextToClipboard.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/downloadFile.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/getCurrentTime.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/hideKeyboard.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/readTextFromClipboard.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/retrieveAndroidDeviceDataFrom.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/retrieveAndroidDeviceData.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/sendData.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/shareMessage.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/shareStory.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/globals/isInlineMode.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/uncategorized/switchInlineQuery.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/Viewport/Viewport.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/features/Viewport/instance.ts","../../../../node_modules/.pnpm/%40tma.js%2Bsdk%403.1.2_typescript%405.9.3/node_modules/%40tma.js/sdk/src/init.ts","../../../../node_modules/.pnpm/%40swc%2Bhelpers%400.5.15/node_modules/%40swc/helpers/esm/_define_property.js","../../../../node_modules/.pnpm/%40swc%2Bhelpers%400.5.15/node_modules/%40swc/helpers/esm/_object_spread.js","../../../../node_modules/.pnpm/%40swc%2Bhelpers%400.5.15/node_modules/%40swc/helpers/esm/_object_spread_props.js","../../../../node_modules/.pnpm/%40swc%2Bhelpers%400.5.15/node_modules/%40swc/helpers/esm/_object_without_properties_loose.js","../../../../node_modules/.pnpm/%40telegram-apps%2Btelegram-ui%402.1.13_%40types%2Breact-dom%4019.2.3_%40types%2Breact%4019.2.7__%40types%2Br_cd2a85882c477b95a917a92df729637e/node_modules/%40telegram-apps/telegram-ui/dist/helpers/classNames.js","../../../../node_modules/.pnpm/%40swc%2Bhelpers%400.5.15/node_modules/%40swc/helpers/esm/_object_without_properties.js","../../../../node_modules/.pnpm/%40telegram-apps%2Btelegram-ui%402.1.13_%40types%2Breact-dom%4019.2.3_%40types%2Breact%4019.2.7__%40types%2Br_cd2a85882c477b95a917a92df729637e/node_modules/%40telegram-apps/telegram-ui/src/components/Service/AppRoot/AppRootContext.ts","../../../../node_modules/.pnpm/%40floating-ui%2Butils%400.2.10/node_modules/%40floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../../../node_modules/.pnpm/%40telegram-apps%2Btelegram-ui%402.1.13_%40types%2Breact-dom%4019.2.3_%40types%2Breact%4019.2.7__%40types%2Br_cd2a85882c477b95a917a92df729637e/node_modules/%40telegram-apps/telegram-ui/dist/helpers/dom.js","../../../../node_modules/.pnpm/next%4016.0.7_%40babel%2Bcore%407.28.5_%40playwright%2Btest%401.57.0_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts","../../../../node_modules/.pnpm/%40swc%2Bhelpers%400.5.15/node_modules/%40swc/helpers/cjs/_interop_require_wildcard.cjs","../../../../node_modules/.pnpm/next%4016.0.7_%40babel%2Bcore%407.28.5_%40playwright%2Btest%401.57.0_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/shared/lib/is-thenable.ts","../../../../node_modules/.pnpm/next%4016.0.7_%40babel%2Bcore%407.28.5_%40playwright%2Btest%401.57.0_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/components/use-action-queue.ts","../../../../node_modules/.pnpm/next%4016.0.7_%40babel%2Bcore%407.28.5_%40playwright%2Btest%401.57.0_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/app-call-server.ts","../../../../node_modules/.pnpm/next%4016.0.7_%40babel%2Bcore%407.28.5_%40playwright%2Btest%401.57.0_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/app-find-source-map-url.ts"],"sourcesContent":["import { Signal } from './signal.js';\n\nlet callbacks: Map<Signal<any>, () => void> | undefined;\n\nexport function runInBatchMode(signal: Signal<any>, fn: () => void): void {\n  if (callbacks) {\n    callbacks.set(signal, fn);\n  } else {\n    fn();\n  }\n}\n\n/**\n * Runs the specified function in the batch mode.\n *\n * It makes all signals' subscribers to be called only after signals changes inside the specified\n * function were applied.\n * @param fn - function to run in the batch mode.\n * @example\n * const a = signal(1);\n * const b = signal(1);\n * const c = computed(() => a() + b());\n *\n * function subscriber(value) {\n *   console.log(value);\n * }\n *\n * c.sub(subscriber);\n *\n * batch(() => {\n *   a.set(2);\n *   a.set(3);\n *   b.set(2);\n *   b.set(3);\n * });\n *\n * // Despite the fact that we called signals setters four times, the `subscriber` function will\n * // be called only once. Removing the `batch` function usage will lead to calling the `subscriber`\n * // function four times.\n */\nexport function batch(fn: () => void): void {\n  // There could be a case when a batch is called inside other batches.\n  // In this case, we should just ignore the current call.\n  if (callbacks) {\n    return fn();\n  }\n  callbacks = new Map();\n\n  try {\n    fn();\n  } finally {\n    callbacks.forEach(cb => cb());\n    callbacks = undefined;\n    // TODO: What if something went wrong in fn or its callbacks?\n  }\n}\n","import { collectSignal } from './computed.js';\nimport { runInBatchMode } from './batch.js';\n\nexport type SubscribeListenerFn<T> = (current: T, previous: T) => void;\nexport type RemoveListenerFn = () => void;\n\nexport interface SignalOptions<T> {\n  /**\n   * Previous and next values comparator.\n   *\n   * This function is used during the actual and incoming values comparison in the `set` method.\n   * If values are considered the same, no subscribers will be called.\n   *\n   * @default Object.is\n   * @param current - the actual value.\n   * @param next - an incoming value.\n   * @returns True if values are considered the same.\n   */\n  equals?: (current: T, next: T) => boolean;\n}\n\nexport interface SubOptions {\n  /**\n   * Should the listener be called only once.\n   */\n  once?: boolean;\n  /**\n   * True if the subscriber was added by another signal.\n   */\n  signal?: boolean;\n}\n\nexport interface Signal<T> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n  /**\n   * Destroys the signal removing all bound listeners.\n   *\n   * We usually use this method when the signal is not needed anymore.\n   *\n   * Take note that as long as call of this method removes all bound listeners, computed signals\n   * based on the current one will stop listening to its changes, possibly making it work\n   * improperly.\n   */\n  destroy: () => void;\n  /**\n   * Resets the signal to its initial value.\n   */\n  reset: () => void;\n  /**\n   * Updates the signal notifying all subscribers about changes.\n   * @param value - value to set.\n   */\n  set: (value: T) => void;\n  /**\n   * Adds a new listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options.\n   * @returns A function to remove the bound listener.\n   */\n  sub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => RemoveListenerFn;\n  /**\n   * Removes a listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options. Default: false\n   */\n  unsub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => void;\n  /**\n   * Remove all non-signal listeners.\n   */\n  unsubAll: () => void;\n}\n\n/**\n * Creates a new signal with initial value.\n * @param initialValue - initial value.\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without initial value.\n * @param initialValue\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  type CurrentSignal = Signal<T | undefined>;\n\n  options ||= {};\n  const equals = options.equals || Object.is;\n\n  let listeners: [\n    listener: SubscribeListenerFn<T | undefined>,\n    options: Required<SubOptions>,\n  ][] = [];\n  let value: ReturnType<CurrentSignal> = initialValue;\n\n  const set: CurrentSignal['set'] = v => {\n    if (!equals(value, v)) {\n      const prev = value;\n      value = v;\n\n      // We are making a copy of listeners as long as they may mutate the listeners' array,\n      // leading to an unexpected behavior.\n      //\n      // We want the setter to make sure that all listeners will be called in predefined\n      // order within a single update frame.\n      runInBatchMode(s, () => {\n        [...listeners].forEach(([fn, once]) => {\n          fn(v, prev);\n\n          // Remove \"once\" listeners.\n          if (once) {\n            unsub(fn, true);\n          }\n        });\n      });\n    }\n  };\n\n  function formatSubOptions(onceOrOptions: boolean | SubOptions | undefined): Required<SubOptions> {\n    const options = typeof onceOrOptions !== 'object'\n      ? { once: onceOrOptions }\n      : onceOrOptions;\n    return {\n      once: options.once || false,\n      signal: options.signal || false,\n    };\n  }\n\n  const unsub: CurrentSignal['unsub'] = (fn, onceOrOptions) => {\n    const options = formatSubOptions(onceOrOptions);\n    const idx = listeners.findIndex(([listener, lOptions]) => {\n      return listener === fn\n        && lOptions.once === options.once\n        && lOptions.signal === options.signal;\n    });\n    if (idx >= 0) {\n      listeners.splice(idx, 1);\n    }\n  };\n\n  const s = Object.assign(\n    function get() {\n      collectSignal(s);\n      return value;\n    },\n    {\n      destroy() {\n        listeners = [];\n      },\n      set,\n      reset() {\n        set(initialValue);\n      },\n      sub(fn, onceOrOptions) {\n        listeners.push([fn, formatSubOptions(onceOrOptions)]);\n        return () => unsub(fn, onceOrOptions);\n      },\n      unsub,\n      unsubAll() {\n        listeners = listeners.filter(l => l[1].signal);\n      },\n    } satisfies Pick<CurrentSignal, 'destroy' | 'set' | 'reset' | 'sub' | 'unsub' | 'unsubAll'>,\n  );\n\n  return s;\n}\n","import { signal, type Signal, type SignalOptions } from './signal.js';\n\nexport interface Computed<T> extends Omit<Signal<T>, 'set' | 'reset'> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n}\n\nconst collectContexts: Set<Signal<unknown>>[] = [];\n\nexport function collectSignal(signal: Signal<any>): void {\n  collectContexts.length && collectContexts[collectContexts.length - 1].add(signal);\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function computed<T>(\n  fn: (prev?: T) => T,\n  options?: SignalOptions<T>,\n): Computed<T> {\n  let deps = new Set<Signal<unknown>>();\n\n  // An underlying signal.\n  let $signal: Signal<T> | undefined;\n\n  function s(): Signal<T> {\n    return $signal || ($signal = signal<T>(compute(), options));\n  }\n\n  function update() {\n    s().set(compute());\n  }\n\n  function compute(): T {\n    // As long as in this iteration, we may receive new signals as dependencies, we stop\n    // listening to the previous signals.\n    deps.forEach(s => {\n      s.unsub(update, { signal: true });\n    });\n\n    // Signals we collected during current computation.\n    const collectedSignals = new Set<Signal<unknown>>();\n    let result: T;\n\n    // Add this set to the global variable, so dependant signals will be catched.\n    collectContexts.push(collectedSignals);\n\n    try {\n      // Run the function and collect all called signals.\n      result = fn();\n    } finally {\n      // Remember to untrack the reactive context.\n      collectContexts.pop();\n    }\n\n    // Start tracking for all dependencies' changes and re-compute the computed value.\n    collectedSignals.forEach(s => {\n      s.sub(update, { signal: true });\n    });\n    deps = collectedSignals;\n\n    return result;\n  }\n\n  return Object.assign(function computed(): T {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...args) {\n      return s().sub(...args);\n    },\n    unsub(...args) {\n      s().unsub(...args);\n    },\n    unsubAll(...args) {\n      s().unsubAll(...args);\n    },\n  } satisfies Pick<Computed<T>, 'destroy' | 'sub' | 'unsub' | 'unsubAll'>);\n}\n","//#region src/storages/globalConfig/globalConfig.ts\nlet store$4;\n/**\n* Sets the global configuration.\n*\n* @param config The configuration.\n*/\nfunction setGlobalConfig(config$1) {\n\tstore$4 = {\n\t\t...store$4,\n\t\t...config$1\n\t};\n}\n/**\n* Returns the global configuration.\n*\n* @param config The config to merge.\n*\n* @returns The configuration.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalConfig(config$1) {\n\treturn {\n\t\tlang: config$1?.lang ?? store$4?.lang,\n\t\tmessage: config$1?.message,\n\t\tabortEarly: config$1?.abortEarly ?? store$4?.abortEarly,\n\t\tabortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly\n\t};\n}\n/**\n* Deletes the global configuration.\n*/\nfunction deleteGlobalConfig() {\n\tstore$4 = void 0;\n}\n\n//#endregion\n//#region src/storages/globalMessage/globalMessage.ts\nlet store$3;\n/**\n* Sets a global error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setGlobalMessage(message$1, lang) {\n\tif (!store$3) store$3 = /* @__PURE__ */ new Map();\n\tstore$3.set(lang, message$1);\n}\n/**\n* Returns a global error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalMessage(lang) {\n\treturn store$3?.get(lang);\n}\n/**\n* Deletes a global error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteGlobalMessage(lang) {\n\tstore$3?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/schemaMessage/schemaMessage.ts\nlet store$2;\n/**\n* Sets a schema error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSchemaMessage(message$1, lang) {\n\tif (!store$2) store$2 = /* @__PURE__ */ new Map();\n\tstore$2.set(lang, message$1);\n}\n/**\n* Returns a schema error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSchemaMessage(lang) {\n\treturn store$2?.get(lang);\n}\n/**\n* Deletes a schema error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteSchemaMessage(lang) {\n\tstore$2?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/specificMessage/specificMessage.ts\nlet store$1;\n/**\n* Sets a specific error message.\n*\n* @param reference The identifier reference.\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSpecificMessage(reference, message$1, lang) {\n\tif (!store$1) store$1 = /* @__PURE__ */ new Map();\n\tif (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());\n\tstore$1.get(reference).set(lang, message$1);\n}\n/**\n* Returns a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSpecificMessage(reference, lang) {\n\treturn store$1?.get(reference)?.get(lang);\n}\n/**\n* Deletes a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*/\nfunction deleteSpecificMessage(reference, lang) {\n\tstore$1?.get(reference)?.delete(lang);\n}\n\n//#endregion\n//#region src/utils/_stringify/_stringify.ts\n/**\n* Stringifies an unknown input to a literal or type string.\n*\n* @param input The unknown input.\n*\n* @returns A literal or type string.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _stringify(input) {\n\tconst type = typeof input;\n\tif (type === \"string\") return `\"${input}\"`;\n\tif (type === \"number\" || type === \"bigint\" || type === \"boolean\") return `${input}`;\n\tif (type === \"object\" || type === \"function\") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n\treturn type;\n}\n\n//#endregion\n//#region src/utils/_addIssue/_addIssue.ts\n/**\n* Adds an issue to the dataset.\n*\n* @param context The issue context.\n* @param label The issue label.\n* @param dataset The input dataset.\n* @param config The configuration.\n* @param other The optional props.\n*\n* @internal\n*/\nfunction _addIssue(context, label, dataset, config$1, other) {\n\tconst input = other && \"input\" in other ? other.input : dataset.value;\n\tconst expected = other?.expected ?? context.expects ?? null;\n\tconst received = other?.received ?? /* @__PURE__ */ _stringify(input);\n\tconst issue = {\n\t\tkind: context.kind,\n\t\ttype: context.type,\n\t\tinput,\n\t\texpected,\n\t\treceived,\n\t\tmessage: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n\t\trequirement: context.requirement,\n\t\tpath: other?.path,\n\t\tissues: other?.issues,\n\t\tlang: config$1.lang,\n\t\tabortEarly: config$1.abortEarly,\n\t\tabortPipeEarly: config$1.abortPipeEarly\n\t};\n\tconst isSchema = context.kind === \"schema\";\n\tconst message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);\n\tif (message$1 !== void 0) issue.message = typeof message$1 === \"function\" ? message$1(issue) : message$1;\n\tif (isSchema) dataset.typed = false;\n\tif (dataset.issues) dataset.issues.push(issue);\n\telse dataset.issues = [issue];\n}\n\n//#endregion\n//#region src/utils/_getByteCount/_getByteCount.ts\nlet textEncoder;\n/**\n* Returns the byte count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The byte count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getByteCount(input) {\n\tif (!textEncoder) textEncoder = new TextEncoder();\n\treturn textEncoder.encode(input).length;\n}\n\n//#endregion\n//#region src/utils/_getGraphemeCount/_getGraphemeCount.ts\nlet segmenter;\n/**\n* Returns the grapheme count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The grapheme count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getGraphemeCount(input) {\n\tif (!segmenter) segmenter = new Intl.Segmenter();\n\tconst segments = segmenter.segment(input);\n\tlet count = 0;\n\tfor (const _ of segments) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_getLastMetadata/_getLastMetadata.ts\n/**\n* Returns the last top-level value of a given metadata type from a schema\n* using a breadth-first search that starts with the last item in the pipeline.\n*\n* @param schema The schema to search.\n* @param type The metadata type.\n*\n* @returns The value, if any.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getLastMetadata(schema, type) {\n\tif (\"pipe\" in schema) {\n\t\tconst nestedSchemas = [];\n\t\tfor (let index = schema.pipe.length - 1; index >= 0; index--) {\n\t\t\tconst item = schema.pipe[index];\n\t\t\tif (item.kind === \"schema\" && \"pipe\" in item) nestedSchemas.push(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === type) return item[type];\n\t\t}\n\t\tfor (const nestedSchema of nestedSchemas) {\n\t\t\tconst result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);\n\t\t\tif (result !== void 0) return result;\n\t\t}\n\t}\n}\n\n//#endregion\n//#region src/utils/_getStandardProps/_getStandardProps.ts\n/**\n* Returns the Standard Schema properties.\n*\n* @param context The schema context.\n*\n* @returns The Standard Schema properties.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getStandardProps(context) {\n\treturn {\n\t\tversion: 1,\n\t\tvendor: \"valibot\",\n\t\tvalidate(value$1) {\n\t\t\treturn context[\"~run\"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/utils/_getWordCount/_getWordCount.ts\nlet store;\n/**\n* Returns the word count of the input.\n*\n* @param locales The locales to be used.\n* @param input The input to be measured.\n*\n* @returns The word count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getWordCount(locales, input) {\n\tif (!store) store = /* @__PURE__ */ new Map();\n\tif (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n\tconst segments = store.get(locales).segment(input);\n\tlet count = 0;\n\tfor (const segment of segments) if (segment.isWordLike) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\n/**\n* Non-digit regex.\n*/\nconst NON_DIGIT_REGEX = /\\D/gu;\n/**\n* Checks whether a string with numbers corresponds to the luhn algorithm.\n*\n* @param input The input to be checked.\n*\n* @returns Whether input is valid.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isLuhnAlgo(input) {\n\tconst number$1 = input.replace(NON_DIGIT_REGEX, \"\");\n\tlet length$1 = number$1.length;\n\tlet bit = 1;\n\tlet sum = 0;\n\twhile (length$1) {\n\t\tconst value$1 = +number$1[--length$1];\n\t\tbit ^= 1;\n\t\tsum += bit ? [\n\t\t\t0,\n\t\t\t2,\n\t\t\t4,\n\t\t\t6,\n\t\t\t8,\n\t\t\t1,\n\t\t\t3,\n\t\t\t5,\n\t\t\t7,\n\t\t\t9\n\t\t][value$1] : value$1;\n\t}\n\treturn sum % 10 === 0;\n}\n\n//#endregion\n//#region src/utils/_isValidObjectKey/_isValidObjectKey.ts\n/**\n* Disallows inherited object properties and prevents object prototype\n* pollution by disallowing certain keys.\n*\n* @param object The object to check.\n* @param key The key to check.\n*\n* @returns Whether the key is allowed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isValidObjectKey(object$1, key) {\n\treturn Object.hasOwn(object$1, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n//#endregion\n//#region src/utils/_joinExpects/_joinExpects.ts\n/**\n* Joins multiple `expects` values with the given separator.\n*\n* @param values The `expects` values.\n* @param separator The separator.\n*\n* @returns The joined `expects` property.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _joinExpects(values$1, separator) {\n\tconst list = [...new Set(values$1)];\n\tif (list.length > 1) return `(${list.join(` ${separator} `)})`;\n\treturn list[0] ?? \"never\";\n}\n\n//#endregion\n//#region src/utils/entriesFromList/entriesFromList.ts\n/**\n* Creates an object entries definition from a list of keys and a schema.\n*\n* @param list A list of keys.\n* @param schema The schema of the keys.\n*\n* @returns The object entries.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromList(list, schema) {\n\tconst entries$1 = {};\n\tfor (const key of list) entries$1[key] = schema;\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/entriesFromObjects/entriesFromObjects.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromObjects(schemas) {\n\tconst entries$1 = {};\n\tfor (const schema of schemas) Object.assign(entries$1, schema.entries);\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/getDotPath/getDotPath.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDotPath(issue) {\n\tif (issue.path) {\n\t\tlet key = \"\";\n\t\tfor (const item of issue.path) if (typeof item.key === \"string\" || typeof item.key === \"number\") if (key) key += `.${item.key}`;\n\t\telse key += item.key;\n\t\telse return null;\n\t\treturn key;\n\t}\n\treturn null;\n}\n\n//#endregion\n//#region src/utils/isOfKind/isOfKind.ts\n/**\n* A generic type guard to check the kind of an object.\n*\n* @param kind The kind to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfKind(kind, object$1) {\n\treturn object$1.kind === kind;\n}\n\n//#endregion\n//#region src/utils/isOfType/isOfType.ts\n/**\n* A generic type guard to check the type of an object.\n*\n* @param type The type to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfType(type, object$1) {\n\treturn object$1.type === type;\n}\n\n//#endregion\n//#region src/utils/isValiError/isValiError.ts\n/**\n* A type guard to check if an error is a ValiError.\n*\n* @param error The error to check.\n*\n* @returns Whether its a ValiError.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isValiError(error) {\n\treturn error instanceof ValiError;\n}\n\n//#endregion\n//#region src/utils/ValiError/ValiError.ts\n/**\n* A Valibot error with useful information.\n*/\nvar ValiError = class extends Error {\n\t/**\n\t* Creates a Valibot error with useful information.\n\t*\n\t* @param issues The error issues.\n\t*/\n\tconstructor(issues) {\n\t\tsuper(issues[0].message);\n\t\tthis.name = \"ValiError\";\n\t\tthis.issues = issues;\n\t}\n};\n\n//#endregion\n//#region src/actions/args/args.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction args(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: args,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst argsDataset = this.schema[\"~run\"]({ value: args_ }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/args/argsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction argsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: argsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args$1) => {\n\t\t\t\tconst argsDataset = await schema[\"~run\"]({ value: args$1 }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/await/awaitAsync.ts\n/**\n* Creates an await transformation action.\n*\n* @returns An await action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction awaitAsync() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"await\",\n\t\treference: awaitAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/regex.ts\n/**\n* [Base64](https://en.wikipedia.org/wiki/Base64) regex.\n*/\nconst BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\n/**\n* [BIC](https://en.wikipedia.org/wiki/ISO_9362) regex.\n*/\nconst BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\n/**\n* [Cuid2](https://github.com/paralleldrive/cuid2) regex.\n*/\nconst CUID2_REGEX = /^[a-z][\\da-z]*$/u;\n/**\n* [Decimal](https://en.wikipedia.org/wiki/Decimal) regex.\n*/\nconst DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\n/**\n* [Digits](https://en.wikipedia.org/wiki/Numerical_digit) regex.\n*/\nconst DIGITS_REGEX = /^\\d+$/u;\n/**\n* [Email address](https://en.wikipedia.org/wiki/Email_address) regex.\n*/\nconst EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\n/**\n* Emoji regex from [emoji-regex-xs](https://github.com/slevithan/emoji-regex-xs) v1.0.0 (MIT license).\n*\n* Hint: We decided against the newer `/^\\p{RGI_Emoji}+$/v` regex because it is\n* not supported in older runtimes and does not match all emoji.\n*/\nconst EMOJI_REGEX = /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation}))*)+$/u;\n/**\n* [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\n/**\n* [Hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\n/**\n* [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) regex.\n*/\nconst IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\n/**\n* [IPv4](https://en.wikipedia.org/wiki/IPv4) regex.\n*/\nconst IPV4_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\n/**\n* [IPv6](https://en.wikipedia.org/wiki/IPv6) regex.\n*/\nconst IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [IP](https://en.wikipedia.org/wiki/IP_address) regex.\n*/\nconst IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date regex.\n*/\nconst ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time regex.\n*/\nconst ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time regex.\n*/\nconst ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time with seconds regex.\n*/\nconst ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp regex.\n*/\nconst ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) week regex.\n*/\nconst ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 48 bit regex.\n*/\nconst MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 64 bit regex.\n*/\nconst MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) regex.\n*/\nconst MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [Nano ID](https://github.com/ai/nanoid) regex.\n*/\nconst NANO_ID_REGEX = /^[\\w-]+$/u;\n/**\n* [Octal](https://en.wikipedia.org/wiki/Octal) regex.\n*/\nconst OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\n/**\n* [RFC 5322 email address](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) regex.\n*\n* Hint: This regex was taken from the [HTML Living Standard Specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) and does not perfectly represent RFC 5322.\n*/\nconst RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/**\n* [Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug) regex.\n*/\nconst SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\n/**\n* [ULID](https://github.com/ulid/spec) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\n/**\n* [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.\n*/\nconst UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n//#endregion\n//#region src/actions/base64/base64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction base64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"base64\",\n\t\treference: base64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BASE64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Base64\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bic/bic.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bic(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bic\",\n\t\treference: bic,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BIC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"BIC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/brand/brand.ts\n/**\n* Creates a brand transformation action.\n*\n* @param name The brand name.\n*\n* @returns A brand action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction brand(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"brand\",\n\t\treference: brand,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bytes/bytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bytes\",\n\t\treference: bytes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 !== this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/check.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction check(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: check,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/checkAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: checkAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItems(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItems,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) for (let index = 0; index < dataset.value.length; index++) {\n\t\t\t\tconst item = dataset.value[index];\n\t\t\t\tif (!this.requirement(item, index, dataset.value)) _addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\tinput: item,\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\tvalue: item\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItemsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItemsAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItemsAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst requirementResults = await Promise.all(dataset.value.map(this.requirement));\n\t\t\t\tfor (let index = 0; index < dataset.value.length; index++) if (!requirementResults[index]) {\n\t\t\t\t\tconst item = dataset.value[index];\n\t\t\t\t\t_addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\t\tinput: item,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\t\tvalue: item\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/creditCard/creditCard.ts\n/**\n* Credit card regex.\n*/\nconst CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\n/**\n* Sanitize regex.\n*/\nconst SANITIZE_REGEX = /[- ]/gu;\n/**\n* Provider regex list.\n*/\nconst PROVIDER_REGEX_LIST = [\n\t/^3[47]\\d{13}$/u,\n\t/^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n\t/^6(?:011|5\\d{2})\\d{12,15}$/u,\n\t/^(?:2131|1800|35\\d{3})\\d{11}$/u,\n\t/^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n\t/^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n\t/^4\\d{12}(?:\\d{3,6})?$/u\n];\n/* @__NO_SIDE_EFFECTS__ */\nfunction creditCard(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"credit_card\",\n\t\treference: creditCard,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\tlet sanitized;\n\t\t\treturn CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, \"\")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"credit card\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/cuid2/cuid2.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction cuid2(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"cuid2\",\n\t\treference: cuid2,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: CUID2_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Cuid2\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/decimal/decimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction decimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"decimal\",\n\t\treference: decimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"decimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/description/description.ts\n/**\n* Creates a description metadata action.\n*\n* @param description_ The description text.\n*\n* @returns A description action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction description(description_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"description\",\n\t\treference: description,\n\t\tdescription: description_\n\t};\n}\n\n//#endregion\n//#region src/actions/digits/digits.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction digits(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"digits\",\n\t\treference: digits,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DIGITS_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"digits\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/email/email.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction email(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"email\",\n\t\treference: email,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/emoji/emoji.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction emoji(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"emoji\",\n\t\treference: emoji,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: EMOJI_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"emoji\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/empty/empty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction empty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"empty\",\n\t\treference: empty,\n\t\tasync: false,\n\t\texpects: \"0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > 0) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/endsWith/endsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction endsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ends_with\",\n\t\treference: endsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, \"end\", dataset, config$1, { received: `\"${dataset.value.slice(-this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/entries/entries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"entries\",\n\t\treference: entries,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count !== this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/everyItem/everyItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction everyItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"every_item\",\n\t\treference: everyItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/examples/examples.ts\n/**\n* Creates an examples metadata action.\n*\n* @param examples_ The examples.\n*\n* @returns An examples action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction examples(examples_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"examples\",\n\t\treference: examples,\n\t\texamples: examples_\n\t};\n}\n\n//#endregion\n//#region src/actions/excludes/excludes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction excludes(requirement, message$1) {\n\tconst received = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"excludes\",\n\t\treference: excludes,\n\t\tasync: false,\n\t\texpects: `!${received}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/filterItems/filterItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction filterItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"filter_items\",\n\t\treference: filterItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.filter(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/findItem/findItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction findItem(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"find_item\",\n\t\treference: findItem,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.find(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/finite/finite.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction finite(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"finite\",\n\t\treference: finite,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isFinite,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"finite\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/flavor/flavor.ts\n/**\n* Creates a flavor transformation action.\n*\n* @param name The flavor name.\n*\n* @returns A flavor action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction flavor(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"flavor\",\n\t\treference: flavor,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/graphemes/graphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction graphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"graphemes\",\n\t\treference: graphemes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/gtValue/gtValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction gtValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"gt_value\",\n\t\treference: gtValue,\n\t\tasync: false,\n\t\texpects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hash/hash.ts\n/**\n* Hash lengths object.\n*/\nconst HASH_LENGTHS = {\n\tmd4: 32,\n\tmd5: 32,\n\tsha1: 40,\n\tsha256: 64,\n\tsha384: 96,\n\tsha512: 128,\n\tripemd128: 32,\n\tripemd160: 40,\n\ttiger128: 32,\n\ttiger160: 40,\n\ttiger192: 48,\n\tcrc32: 8,\n\tcrc32b: 8,\n\tadler32: 8\n};\n/* @__NO_SIDE_EFFECTS__ */\nfunction hash(types, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hash\",\n\t\treference: hash,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hash\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexadecimal/hexadecimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexadecimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hexadecimal\",\n\t\treference: hexadecimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEXADECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hexadecimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexColor/hexColor.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexColor(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hex_color\",\n\t\treference: hexColor,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEX_COLOR_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hex color\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/imei/imei.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction imei(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"imei\",\n\t\treference: imei,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\treturn IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"IMEI\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/includes/includes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction includes(requirement, message$1) {\n\tconst expects = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"includes\",\n\t\treference: includes,\n\t\tasync: false,\n\t\texpects,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received: `!${expects}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/integer/integer.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction integer(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"integer\",\n\t\treference: integer,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ip/ip.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ip(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ip\",\n\t\treference: ip,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IP\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv4/ipv4.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv4(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv4\",\n\t\treference: ipv4,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV4_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv4\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv6/ipv6.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv6(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv6\",\n\t\treference: ipv6,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV6_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv6\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDate/isoDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDate(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date\",\n\t\treference: isoDate,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDateTime/isoDateTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDateTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date_time\",\n\t\treference: isoDateTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date-time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTime/isoTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time\",\n\t\treference: isoTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimeSecond/isoTimeSecond.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimeSecond(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time_second\",\n\t\treference: isoTimeSecond,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_SECOND_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time-second\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimestamp/isoTimestamp.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimestamp(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_timestamp\",\n\t\treference: isoTimestamp,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIMESTAMP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"timestamp\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoWeek/isoWeek.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoWeek(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_week\",\n\t\treference: isoWeek,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_WEEK_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"week\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/length/length.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction length(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"length\",\n\t\treference: length,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ltValue/ltValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ltValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"lt_value\",\n\t\treference: ltValue,\n\t\tasync: false,\n\t\texpects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac/mac.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac\",\n\t\treference: mac,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac48/mac48.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac48(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac48\",\n\t\treference: mac48,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC48_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"48-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac64/mac64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac64\",\n\t\treference: mac64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"64-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mapItems/mapItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"map_items\",\n\t\treference: mapItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.map(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxBytes/maxBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_bytes\",\n\t\treference: maxBytes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 > this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxEntries/maxEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_entries\",\n\t\treference: maxEntries,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count > this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxGraphemes/maxGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_graphemes\",\n\t\treference: maxGraphemes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxLength/maxLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_length\",\n\t\treference: maxLength,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxSize/maxSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_size\",\n\t\treference: maxSize,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxValue/maxValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_value\",\n\t\treference: maxValue,\n\t\tasync: false,\n\t\texpects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxWords/maxWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_words\",\n\t\treference: maxWords,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/metadata/metadata.ts\n/**\n* Creates a custom metadata action.\n*\n* @param metadata_ The metadata object.\n*\n* @returns A metadata action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction metadata(metadata_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"metadata\",\n\t\treference: metadata,\n\t\tmetadata: metadata_\n\t};\n}\n\n//#endregion\n//#region src/actions/mimeType/mimeType.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mimeType(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mime_type\",\n\t\treference: mimeType,\n\t\tasync: false,\n\t\texpects: /* @__PURE__ */ _joinExpects(requirement.map((option) => `\"${option}\"`), \"|\"),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, \"MIME type\", dataset, config$1, { received: `\"${dataset.value.type}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minBytes/minBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_bytes\",\n\t\treference: minBytes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 < this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minEntries/minEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_entries\",\n\t\treference: minEntries,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count < this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minGraphemes/minGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_graphemes\",\n\t\treference: minGraphemes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minLength/minLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_length\",\n\t\treference: minLength,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minSize/minSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_size\",\n\t\treference: minSize,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minValue/minValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_value\",\n\t\treference: minValue,\n\t\tasync: false,\n\t\texpects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minWords/minWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_words\",\n\t\treference: minWords,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/multipleOf/multipleOf.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction multipleOf(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"multiple_of\",\n\t\treference: multipleOf,\n\t\tasync: false,\n\t\texpects: `%${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, \"multiple\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nanoid/nanoid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nanoid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"nanoid\",\n\t\treference: nanoid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: NANO_ID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Nano ID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nonEmpty/nonEmpty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonEmpty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"non_empty\",\n\t\treference: nonEmpty,\n\t\tasync: false,\n\t\texpects: \"!0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === 0) _addIssue(this, \"length\", dataset, config$1, { received: \"0\" });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/normalize/normalize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction normalize(form) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"normalize\",\n\t\treference: normalize,\n\t\tasync: false,\n\t\tform,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.normalize(this.form);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notBytes/notBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_bytes\",\n\t\treference: notBytes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 === this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notEntries/notEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_entries\",\n\t\treference: notEntries,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count === this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notGraphemes/notGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_graphemes\",\n\t\treference: notGraphemes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notLength/notLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_length\",\n\t\treference: notLength,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notSize/notSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_size\",\n\t\treference: notSize,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValue/notValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_value\",\n\t\treference: notValue,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValues/notValues.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValues(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_values\",\n\t\treference: notValues,\n\t\tasync: false,\n\t\texpects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notWords/notWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_words\",\n\t\treference: notWords,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/octal/octal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction octal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"octal\",\n\t\treference: octal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: OCTAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"octal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/parseJson/parseJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parseJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"parse_json\",\n\t\treference: parseJson,\n\t\tconfig: config$1,\n\t\tmessage: message$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tdataset.value = JSON.parse(dataset.value, this.config?.reviver);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n/**\n* Checks if a dataset is partially typed.\n*\n* @param dataset The dataset to check.\n* @param paths The paths to check.\n*\n* @returns Whether it is partially typed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isPartiallyTyped(dataset, paths) {\n\tif (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {\n\t\tlet typed = false;\n\t\tconst bound = Math.min(path.length, issue.path?.length ?? 0);\n\t\tfor (let index = 0; index < bound; index++) if (path[index] !== issue.path[index].key && (path[index] !== \"$\" || issue.path[index].type !== \"array\")) {\n\t\t\ttyped = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!typed) return false;\n\t}\n\treturn true;\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheck.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheck(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheckAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheckAsync(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheck.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheck(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\taction({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheckAsync.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheckAsync(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tawait action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransform.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransform(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransform,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst output = action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransformAsync.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransformAsync(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransformAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst output = await action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/readonly/readonly.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction readonly() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"readonly\",\n\t\treference: readonly,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/reduceItems/reduceItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction reduceItems(operation, initial) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"reduce_items\",\n\t\treference: reduceItems,\n\t\tasync: false,\n\t\toperation,\n\t\tinitial,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.reduce(this.operation, this.initial);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/regex/regex.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction regex(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"regex\",\n\t\treference: regex,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"format\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returns.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returns(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returns,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst returnsDataset = this.schema[\"~run\"]({ value: func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returnsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returnsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returnsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args_) => {\n\t\t\t\tconst returnsDataset = await this.schema[\"~run\"]({ value: await func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rfcEmail/rfcEmail.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction rfcEmail(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"rfc_email\",\n\t\treference: rfcEmail,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RFC_EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/safeInteger/safeInteger.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeInteger(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"safe_integer\",\n\t\treference: safeInteger,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isSafeInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"safe integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/size/size.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction size(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"size\",\n\t\treference: size,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/slug/slug.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction slug(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"slug\",\n\t\treference: slug,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: SLUG_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"slug\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/someItem/someItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction someItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"some_item\",\n\t\treference: someItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/sortItems/sortItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction sortItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"sort_items\",\n\t\treference: sortItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.sort(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/startsWith/startsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction startsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"starts_with\",\n\t\treference: startsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, \"start\", dataset, config$1, { received: `\"${dataset.value.slice(0, this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/stringifyJson/stringifyJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction stringifyJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"stringify_json\",\n\t\treference: stringifyJson,\n\t\tmessage: message$1,\n\t\tconfig: config$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tconst output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);\n\t\t\t\tif (output === void 0) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t\tdataset.value = output;\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/title/title.ts\n/**\n* Creates a title metadata action.\n*\n* @param title_ The title text.\n*\n* @returns A title action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction title(title_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"title\",\n\t\treference: title,\n\t\ttitle: title_\n\t};\n}\n\n//#endregion\n//#region src/actions/toBigint/toBigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBigint(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_bigint\",\n\t\treference: toBigint,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = BigInt(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"bigint\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toBoolean/toBoolean.ts\n/**\n* Creates a to boolean transformation action.\n*\n* @returns A to boolean action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBoolean() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_boolean\",\n\t\treference: toBoolean,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = Boolean(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toDate/toDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toDate(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_date\",\n\t\treference: toDate,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = new Date(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"date\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"date\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toLowerCase/toLowerCase.ts\n/**\n* Creates a to lower case transformation action.\n*\n* @returns A to lower case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toLowerCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_lower_case\",\n\t\treference: toLowerCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toLowerCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMaxValue/toMaxValue.ts\n/**\n* Creates a to max value transformation action.\n*\n* @param requirement The maximum value.\n*\n* @returns A to max value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMaxValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_max_value\",\n\t\treference: toMaxValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMinValue/toMinValue.ts\n/**\n* Creates a to min value transformation action.\n*\n* @param requirement The minimum value.\n*\n* @returns A to min value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMinValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_min_value\",\n\t\treference: toMinValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toNumber/toNumber.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toNumber(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_number\",\n\t\treference: toNumber,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = Number(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toString/toString.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toString(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_string\",\n\t\treference: toString,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = String(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"string\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toUpperCase/toUpperCase.ts\n/**\n* Creates a to upper case transformation action.\n*\n* @returns A to upper case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toUpperCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_upper_case\",\n\t\treference: toUpperCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toUpperCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transform.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transform(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transform,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transformAsync.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transformAsync(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transformAsync,\n\t\tasync: true,\n\t\toperation,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trim/trim.ts\n/**\n* Creates a trim transformation action.\n*\n* @returns A trim action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trim() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim\",\n\t\treference: trim,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trim();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimEnd/trimEnd.ts\n/**\n* Creates a trim end transformation action.\n*\n* @returns A trim end action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimEnd() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_end\",\n\t\treference: trimEnd,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimEnd();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimStart/trimStart.ts\n/**\n* Creates a trim start transformation action.\n*\n* @returns A trim start action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimStart() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_start\",\n\t\treference: trimStart,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimStart();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ulid/ulid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ulid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ulid\",\n\t\treference: ulid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ULID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"ULID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/url/url.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction url(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"url\",\n\t\treference: url,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\ttry {\n\t\t\t\tnew URL(input);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"URL\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/uuid/uuid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction uuid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"uuid\",\n\t\treference: uuid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: UUID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"UUID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/value/value.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction value(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"value\",\n\t\treference: value,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/values/values.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction values(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"values\",\n\t\treference: values,\n\t\tasync: false,\n\t\texpects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/words/words.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction words(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"words\",\n\t\treference: words,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/assert/assert.ts\n/**\n* Checks if the input matches the schema. As this is an assertion function, it\n* can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*/\nfunction assert(schema, input) {\n\tconst issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n\tif (issues) throw new ValiError(issues);\n}\n\n//#endregion\n//#region src/methods/config/config.ts\n/**\n* Changes the local configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param config The parse configuration.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction config(schema, config$1) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config_) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config_,\n\t\t\t\t...config$1\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getFallback/getFallback.ts\n/**\n* Returns the fallback value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The output dataset if available.\n* @param config The config if available.\n*\n* @returns The fallback value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallback(schema, dataset, config$1) {\n\treturn typeof schema.fallback === \"function\" ? schema.fallback(dataset, config$1) : schema.fallback;\n}\n\n//#endregion\n//#region src/methods/fallback/fallback.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallback(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/fallback/fallbackAsync.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallbackAsync(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = await schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/flatten/flatten.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction flatten(issues) {\n\tconst flatErrors = {};\n\tfor (const issue of issues) if (issue.path) {\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) {\n\t\t\tif (!flatErrors.nested) flatErrors.nested = {};\n\t\t\tif (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);\n\t\t\telse flatErrors.nested[dotPath] = [issue.message];\n\t\t} else if (flatErrors.other) flatErrors.other.push(issue.message);\n\t\telse flatErrors.other = [issue.message];\n\t} else if (flatErrors.root) flatErrors.root.push(issue.message);\n\telse flatErrors.root = [issue.message];\n\treturn flatErrors;\n}\n\n//#endregion\n//#region src/methods/forward/forward.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forward(action, path) {\n\treturn {\n\t\t...action,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/forward/forwardAsync.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forwardAsync(action, path) {\n\treturn {\n\t\t...action,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = await action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getDefault/getDefault.ts\n/**\n* Returns the default value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The input dataset if available.\n* @param config The config if available.\n*\n* @returns The default value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefault(schema, dataset, config$1) {\n\treturn typeof schema.default === \"function\" ? schema.default(dataset, config$1) : schema.default;\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaults.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefaults(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getDefaults);\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaultsAsync.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getDefaultsAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getDefaultsAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getDefaultsAsync));\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDescription/getDescription.ts\n/**\n* Returns the description of the schema.\n*\n* If multiple descriptions are defined, the last one of the highest level is\n* returned. If no description is defined, `undefined` is returned.\n*\n* @param schema The schema to get the description from.\n*\n* @returns The description, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDescription(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"description\");\n}\n\n//#endregion\n//#region src/methods/getExamples/getExamples.ts\n/**\n* Returns the examples of a schema.\n*\n* If multiple examples are defined, it concatenates them using depth-first\n* search. If no examples are defined, an empty array is returned.\n*\n* @param schema The schema to get the examples from.\n*\n* @returns The examples, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getExamples(schema) {\n\tconst examples$1 = [];\n\tfunction depthFirstCollect(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstCollect(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"examples\") examples$1.push(...item.examples);\n\t\t}\n\t}\n\tdepthFirstCollect(schema);\n\treturn examples$1;\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacks.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallbacks(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getFallbacks);\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacksAsync.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getFallbacksAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getFallbacksAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getFallbacksAsync));\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getMetadata/getMetadata.ts\n/**\n* Returns the metadata of a schema.\n*\n* If multiple metadata are defined, it shallowly merges them using depth-first\n* search. If no metadata is defined, an empty object is returned.\n*\n* @param schema Schema to get the metadata from.\n*\n* @returns The metadata, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getMetadata(schema) {\n\tconst result = {};\n\tfunction depthFirstMerge(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstMerge(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"metadata\") Object.assign(result, item.metadata);\n\t\t}\n\t}\n\tdepthFirstMerge(schema);\n\treturn result;\n}\n\n//#endregion\n//#region src/methods/getTitle/getTitle.ts\n/**\n* Returns the title of the schema.\n*\n* If multiple titles are defined, the last one of the highest level is\n* returned. If no title is defined, `undefined` is returned.\n*\n* @param schema The schema to get the title from.\n*\n* @returns The title, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getTitle(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"title\");\n}\n\n//#endregion\n//#region src/methods/is/is.ts\n/**\n* Checks if the input matches the schema. By using a type predicate, this\n* function can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*\n* @returns Whether the input matches the schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction is(schema, input) {\n\treturn !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n//#endregion\n//#region src/schemas/any/any.ts\n/**\n* Creates an any schema.\n*\n* Hint: This schema function exists only for completeness and is not\n* recommended in practice. Instead, `unknown` should be used to accept\n* unknown data.\n*\n* @returns An any schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction any() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"any\",\n\t\treference: any,\n\t\texpects: \"any\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/array.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction array(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: array,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.item[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/arrayAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction arrayAsync(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: arrayAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(input.map((value$1) => this.item[\"~run\"]({ value: value$1 }, config$1)));\n\t\t\t\tfor (let key = 0; key < itemDatasets.length; key++) {\n\t\t\t\t\tconst itemDataset = itemDatasets[key];\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/bigint/bigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bigint(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"bigint\",\n\t\treference: bigint,\n\t\texpects: \"bigint\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"bigint\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/blob/blob.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction blob(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"blob\",\n\t\treference: blob,\n\t\texpects: \"Blob\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Blob) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/boolean/boolean.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction boolean(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"boolean\",\n\t\treference: boolean,\n\t\texpects: \"boolean\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"boolean\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/custom.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction custom(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: custom,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/customAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction customAsync(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: customAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (await this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/date/date.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction date(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"date\",\n\t\treference: date,\n\t\texpects: \"Date\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/enum/enum.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction enum_(enum__, message$1) {\n\tconst options = [];\n\tfor (const key in enum__) if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"enum\",\n\t\treference: enum_,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\tenum: enum__,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptional,\n\t\texpects: wrapped.expects,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptionalAsync,\n\t\texpects: wrapped.expects,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/file/file.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction file(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"file\",\n\t\treference: file,\n\t\texpects: \"File\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof File) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/function/function.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction function_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"function\",\n\t\treference: function_,\n\t\texpects: \"Function\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"function\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/instance/instance.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction instance(class_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"instance\",\n\t\treference: instance,\n\t\texpects: class_.name,\n\t\tasync: false,\n\t\tclass: class_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof this.class) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/utils/_merge/_merge.ts\n/**\n* Merges two values into one single output.\n*\n* @param value1 First value.\n* @param value2 Second value.\n*\n* @returns The merge dataset.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _merge(value1, value2) {\n\tif (typeof value1 === typeof value2) {\n\t\tif (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };\n\t\tif (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n\t\t\tfor (const key in value2) if (key in value1) {\n\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\tvalue1[key] = dataset.value;\n\t\t\t} else value1[key] = value2[key];\n\t\t\treturn { value: value1 };\n\t\t}\n\t\tif (Array.isArray(value1) && Array.isArray(value2)) {\n\t\t\tif (value1.length === value2.length) {\n\t\t\t\tfor (let index = 0; index < value1.length; index++) {\n\t\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n\t\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\t\tvalue1[index] = dataset.value;\n\t\t\t\t}\n\t\t\t\treturn { value: value1 };\n\t\t\t}\n\t\t}\n\t}\n\treturn { issue: true };\n}\n\n//#endregion\n//#region src/schemas/intersect/intersect.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersect(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersect,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tfor (const schema of this.options) {\n\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/intersectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersectAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersectAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tconst optionDatasets = await Promise.all(this.options.map((schema) => schema[\"~run\"]({ value: input }, config$1)));\n\t\t\t\tfor (const optionDataset of optionDatasets) {\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazy.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazy(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazy,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.getter(dataset.value)[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazyAsync.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazyAsync(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazyAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn (await this.getter(dataset.value))[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/literal/literal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction literal(literal_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"literal\",\n\t\treference: literal,\n\t\texpects: /* @__PURE__ */ _stringify(literal_),\n\t\tasync: false,\n\t\tliteral: literal_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === this.literal) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/map.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction map(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: map,\n\t\texpects: \"Map\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tfor (const [inputKey, inputValue] of input) {\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: inputKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/mapAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: mapAsync,\n\t\texpects: \"Map\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tconst datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([\n\t\t\t\t\tinputKey,\n\t\t\t\t\tinputValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: inputKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: inputValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nan/nan.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nan(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nan\",\n\t\treference: nan,\n\t\texpects: \"NaN\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (Number.isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/never/never.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction never(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"never\",\n\t\treference: never,\n\t\texpects: \"never\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\t_addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullable(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullable,\n\t\texpects: \"!null\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullableAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullableAsync,\n\t\texpects: \"!null\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullish(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullish,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullishAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullishAsync,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptional(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptional,\n\t\texpects: \"!undefined\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptionalAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptionalAsync,\n\t\texpects: \"!undefined\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/null/null.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction null_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"null\",\n\t\treference: null_,\n\t\texpects: \"null\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullable,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullableAsync,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullish(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullish,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullishAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullishAsync,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/number/number.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction number(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"number\",\n\t\treference: number,\n\t\texpects: \"number\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"number\" && !isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/object.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction object(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: object,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/objectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: objectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRest(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRest,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) {\n\t\t\t\t\t\tconst valueDataset = this.rest[\"~run\"]({ value: input[key] }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRestAsync(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRestAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(Object.entries(input).filter(([key]) => /* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue$1,\n\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t]))]);\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optional,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optionalAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/picklist/picklist.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction picklist(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"picklist\",\n\t\treference: picklist,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/promise/promise.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction promise(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"promise\",\n\t\treference: promise,\n\t\texpects: \"Promise\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Promise) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/record.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction record(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: record,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {\n\t\t\t\t\tconst entryValue = input[entryKey];\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: entryKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: entryValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/recordAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction recordAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: recordAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([\n\t\t\t\t\tentryKey,\n\t\t\t\t\tentryValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: entryKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: entryValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/set.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction set(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: set,\n\t\texpects: \"Set\",\n\t\tasync: false,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tfor (const inputValue of input) {\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/setAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction setAsync(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: setAsync,\n\t\texpects: \"Set\",\n\t\tasync: true,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tconst valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value[\"~run\"]({ value: inputValue }, config$1)]));\n\t\t\t\tfor (const [inputValue, valueDataset] of valueDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/string/string.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction string(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"string\",\n\t\treference: string,\n\t\texpects: \"string\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"string\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/symbol/symbol.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction symbol(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"symbol\",\n\t\treference: symbol,\n\t\texpects: \"symbol\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"symbol\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRest(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRest,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.rest[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRestAsync(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRestAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(input.slice(this.items.length).map(async (value$1, key) => {\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey + this.items.length,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}))]);\n\t\t\t\tfor (const [key, value$1, itemDataset] of normalDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefined/undefined.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefined_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefined\",\n\t\treference: undefined_,\n\t\texpects: \"undefined\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedable,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedableAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/utils/_subIssues/_subIssues.ts\n/**\n* Returns the sub issues of the provided datasets for the union issue.\n*\n* @param datasets The datasets.\n*\n* @returns The sub issues.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _subIssues(datasets) {\n\tlet issues;\n\tif (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);\n\telse issues = dataset.issues;\n\treturn issues;\n}\n\n//#endregion\n//#region src/schemas/union/union.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction union(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: union,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/unionAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction unionAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: unionAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/unknown/unknown.ts\n/**\n* Creates a unknown schema.\n*\n* @returns A unknown schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unknown() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"unknown\",\n\t\treference: unknown,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variant.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variant(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variant,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true }).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tparseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variantAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variantAsync(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variantAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = async (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") await parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? (await discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true })).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tawait parseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/void/void.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction void_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"void\",\n\t\treference: void_,\n\t\texpects: \"void\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/keyof/keyof.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction keyof(schema, message$1) {\n\treturn /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);\n}\n\n//#endregion\n//#region src/methods/message/message.ts\n/**\n* Changes the local message configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param message_ The error message.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction message(schema, message_) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config$1,\n\t\t\t\tmessage: message_\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/omit/omit.ts\n/**\n* Creates a modified copy of an object schema that does not contain the\n* selected entries.\n*\n* @param schema The schema to omit from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction omit(schema, keys) {\n\tconst entries$1 = { ...schema.entries };\n\tfor (const key of keys) delete entries$1[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/parse/parse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nfunction parse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parse/parseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nasync function parseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parser/parser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parser(schema, config$1) {\n\tconst func = (input) => parse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/parser/parserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parserAsync(schema, config$1) {\n\tconst func = (input) => parseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/partial/partial.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partial(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optional(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/partial/partialAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialAsync(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optionalAsync(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pick/pick.ts\n/**\n* Creates a modified copy of an object schema that contains only the selected\n* entries.\n*\n* @param schema The schema to pick from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction pick(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key of keys) entries$1[key] = schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipe.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipe(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipeAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipeAsync(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/required.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction required(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptional(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/requiredAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction requiredAsync(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function safeParseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParser(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParserAsync(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/summarize/summarize.ts\n/**\n* Summarize the error messages of issues in a pretty-printable multi-line string.\n*\n* @param issues The list of issues.\n*\n* @returns A summary of the issues.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction summarize(issues) {\n\tlet summary = \"\";\n\tfor (const issue of issues) {\n\t\tif (summary) summary += \"\\n\";\n\t\tsummary += ` ${issue.message}`;\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) summary += `\\n   at ${dotPath}`;\n\t}\n\treturn summary;\n}\n\n//#endregion\n//#region src/methods/unwrap/unwrap.ts\n/**\n* Unwraps the wrapped schema.\n*\n* @param schema The schema to be unwrapped.\n*\n* @returns The unwrapped schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unwrap(schema) {\n\treturn schema.wrapped;\n}\n\n//#endregion\nexport { BASE64_REGEX, BIC_REGEX, CUID2_REGEX, DECIMAL_REGEX, DIGITS_REGEX, EMAIL_REGEX, EMOJI_REGEX, HEXADECIMAL_REGEX, HEX_COLOR_REGEX, IMEI_REGEX, IPV4_REGEX, IPV6_REGEX, IP_REGEX, ISO_DATE_REGEX, ISO_DATE_TIME_REGEX, ISO_TIMESTAMP_REGEX, ISO_TIME_REGEX, ISO_TIME_SECOND_REGEX, ISO_WEEK_REGEX, MAC48_REGEX, MAC64_REGEX, MAC_REGEX, NANO_ID_REGEX, OCTAL_REGEX, RFC_EMAIL_REGEX, SLUG_REGEX, ULID_REGEX, UUID_REGEX, ValiError, _addIssue, _getByteCount, _getGraphemeCount, _getLastMetadata, _getStandardProps, _getWordCount, _isLuhnAlgo, _isValidObjectKey, _joinExpects, _stringify, any, args, argsAsync, array, arrayAsync, assert, awaitAsync, base64, bic, bigint, blob, boolean, brand, bytes, check, checkAsync, checkItems, checkItemsAsync, config, creditCard, cuid2, custom, customAsync, date, decimal, deleteGlobalConfig, deleteGlobalMessage, deleteSchemaMessage, deleteSpecificMessage, description, digits, email, emoji, empty, endsWith, entries, entriesFromList, entriesFromObjects, enum_ as enum, enum_, everyItem, exactOptional, exactOptionalAsync, examples, excludes, fallback, fallbackAsync, file, filterItems, findItem, finite, flatten, flavor, forward, forwardAsync, function_ as function, function_, getDefault, getDefaults, getDefaultsAsync, getDescription, getDotPath, getExamples, getFallback, getFallbacks, getFallbacksAsync, getGlobalConfig, getGlobalMessage, getMetadata, getSchemaMessage, getSpecificMessage, getTitle, graphemes, gtValue, hash, hexColor, hexadecimal, imei, includes, instance, integer, intersect, intersectAsync, ip, ipv4, ipv6, is, isOfKind, isOfType, isValiError, isoDate, isoDateTime, isoTime, isoTimeSecond, isoTimestamp, isoWeek, keyof, lazy, lazyAsync, length, literal, looseObject, looseObjectAsync, looseTuple, looseTupleAsync, ltValue, mac, mac48, mac64, map, mapAsync, mapItems, maxBytes, maxEntries, maxGraphemes, maxLength, maxSize, maxValue, maxWords, message, metadata, mimeType, minBytes, minEntries, minGraphemes, minLength, minSize, minValue, minWords, multipleOf, nan, nanoid, never, nonEmpty, nonNullable, nonNullableAsync, nonNullish, nonNullishAsync, nonOptional, nonOptionalAsync, normalize, notBytes, notEntries, notGraphemes, notLength, notSize, notValue, notValues, notWords, null_ as null, null_, nullable, nullableAsync, nullish, nullishAsync, number, object, objectAsync, objectWithRest, objectWithRestAsync, octal, omit, optional, optionalAsync, parse, parseAsync, parseJson, parser, parserAsync, partial, partialAsync, partialCheck, partialCheckAsync, pick, picklist, pipe, pipeAsync, promise, rawCheck, rawCheckAsync, rawTransform, rawTransformAsync, readonly, record, recordAsync, reduceItems, regex, required, requiredAsync, returns, returnsAsync, rfcEmail, safeInteger, safeParse, safeParseAsync, safeParser, safeParserAsync, set, setAsync, setGlobalConfig, setGlobalMessage, setSchemaMessage, setSpecificMessage, size, slug, someItem, sortItems, startsWith, strictObject, strictObjectAsync, strictTuple, strictTupleAsync, string, stringifyJson, summarize, symbol, title, toBigint, toBoolean, toDate, toLowerCase, toMaxValue, toMinValue, toNumber, toString, toUpperCase, transform, transformAsync, trim, trimEnd, trimStart, tuple, tupleAsync, tupleWithRest, tupleWithRestAsync, ulid, undefined_ as undefined, undefined_, undefinedable, undefinedableAsync, union, unionAsync, unknown, unwrap, url, uuid, value, values, variant, variantAsync, void_ as void, void_, words };","/**\n * Converts string value from camel case to kebab case.\n * @param value - value to convert.\n */\nexport function camelToKebab(value: string): string {\n  return value.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\n}\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n","var l = Object.defineProperty;\nvar o = (e, t, n) => t in e ? l(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar c = (e, t, n) => o(e, typeof t != \"symbol\" ? t + \"\" : t, n);\nfunction f(e) {\n  return (t) => t instanceof e;\n}\nfunction u(e, t) {\n  const s = class s extends Error {\n    constructor(...d) {\n      const i = typeof t == \"function\" ? t(...d) : typeof t == \"string\" ? [t] : t || [];\n      super(...i), this.name = e;\n    }\n  };\n  c(s, \"is\", f(s));\n  let n = s;\n  return Object.defineProperty(n, \"name\", { value: e }), n;\n}\nfunction y(e, t, n) {\n  const a = class a extends u(e, n) {\n    constructor(...r) {\n      super(...r);\n      c(this, \"data\");\n      this.data = t(...r);\n    }\n  };\n  c(a, \"is\", f(a));\n  let s = a;\n  return Object.defineProperty(s, \"name\", { value: e }), s;\n}\nexport {\n  u as errorClass,\n  y as errorClassWithData\n};\n//# sourceMappingURL=index.js.map\n","export function createIsInstanceOf<C extends { new(...args: any): any }>(\r\n  Class: C,\r\n): (value: unknown) => value is InstanceType<C> {\r\n  return (value): value is InstanceType<C> => value instanceof Class;\r\n}","export type CamelToSnakeCase<T extends string> = T extends `${infer First}${infer Rest}`\n  ? `${First extends Capitalize<First> ? '_' : ''}${Lowercase<First>}${CamelToSnakeCase<Rest>}`\n  : T;\n\n/**\n * Converts string value from camel case to snake case.\n * @param value - value to convert.\n */\nexport function camelToSnake<T extends string>(value: T): CamelToSnakeCase<T> {\n  return value.replace(/[A-Z]/g, match => `_${match.toLowerCase()}`) as CamelToSnakeCase<T>;\n}\n","import { createIsInstanceOf } from './createIsInstanceOf.js';\r\n\r\nexport type ToSuperFn<ConstructorArgs extends any[]> =\r\n  (...args: ConstructorArgs) => Parameters<ErrorConstructor>;\r\n\r\nexport type ToSuperType<ConstructorArgs extends any[]> =\r\n  | ToSuperFn<ConstructorArgs>\r\n  | string\r\n  | Parameters<ErrorConstructor>;\r\n\r\nexport interface ErrorClass<ConstructorArgs extends any[]> {\r\n  name: string;\r\n  new(...args: ConstructorArgs): Error;\r\n  /**\r\n   * @returns True if the passed value is an instance of this class.\r\n   * @param value - value to check.\r\n   */\r\n  is: (value: unknown) => value is Error;\r\n}\r\n\r\n/**\r\n * @returns A new error class with a predefined name.\r\n * @param name - error class name\r\n * @param toSuper - a function converting passed constructor arguments to a list of arguments\r\n * passed to the `Error` constructor. It can also be a message or a list of arguments passed\r\n * to the super constructor.\r\n */\r\nexport function errorClass<ConstructorArgs extends any[] = []>(\r\n  name: string,\r\n  toSuper?: ToSuperType<ConstructorArgs>,\r\n): ErrorClass<ConstructorArgs> {\r\n  class CustomError extends Error {\r\n    constructor(...args: ConstructorArgs) {\r\n      const params = typeof toSuper === 'function'\r\n        ? toSuper(...args)\r\n        : typeof toSuper === 'string'\r\n          ? [toSuper] as [string]\r\n          : toSuper || [];\r\n      super(...params);\r\n      this.name = name;\r\n    }\r\n\r\n    static is = createIsInstanceOf(CustomError);\r\n  }\r\n\r\n  Object.defineProperty(CustomError, 'name', { value: name });\r\n\r\n  return CustomError;\r\n}","import { camelToSnake, type CamelToSnakeCase } from '@/casing/camelToSnake.js';\n\nexport type ConvertCamelKeysToSnakeCase<T> = {\n  [K in keyof T as CamelToSnakeCase<string & K>]: T[K];\n};\n\n/**\n * Converts object keys from snake to camel case.\n * @param value - value to convert.\n */\nexport function camelToSnakeObjKeys<T extends object>(value: T): ConvertCamelKeysToSnakeCase<T> {\n  return Object.entries(value).reduce<ConvertCamelKeysToSnakeCase<T>>((acc, [k, v]) => {\n    acc[camelToSnake(k) as keyof ConvertCamelKeysToSnakeCase<T>] = v;\n    return acc;\n  }, {} as ConvertCamelKeysToSnakeCase<T>);\n}\n","export type SnakeToCamelCase<S extends string> =\n  S extends `${infer Head}_${infer Tail}`\n    ? `${Head}${Capitalize<SnakeToCamelCase<Tail>>}`\n    : S;\n\n/**\n * Converts string value from snake case to camel case.\n * @param value - value to convert.\n */\nexport function snakeToCamel<T extends string>(value: T): SnakeToCamelCase<T> {\n  return value.replace(/_[a-z]/g, m => m[1].toUpperCase()) as SnakeToCamelCase<T>;\n}\n","import { snakeToCamel, type SnakeToCamelCase } from '@/casing/snakeToCamel.js';\n\nexport type ConvertSnakeKeysToCamelCase<T> = {\n  [K in keyof T as SnakeToCamelCase<string & K>]: T[K];\n};\n\n/**\n * Converts object keys from snake to camel case.\n * @param value - value to convert.\n */\nexport function snakeToCamelObjKeys<T extends object>(value: T): ConvertSnakeKeysToCamelCase<T> {\n  return Object.entries(value).reduce<ConvertSnakeKeysToCamelCase<T>>((acc, [k, v]) => {\n    acc[snakeToCamel(k) as keyof ConvertSnakeKeysToCamelCase<T>] = v;\n    return acc;\n  }, {} as ConvertSnakeKeysToCamelCase<T>);\n}\n","import { snakeToCamelObjKeys } from '@/casing/snakeToCamelObjKeys.js';\nimport type { SnakeToCamelCase } from '@/casing/snakeToCamel.js';\n\nexport type DeepConvertSnakeKeysToCamelCase<T> = T extends infer U\n  ? U extends object\n    ? U extends Date\n      ? U\n      : U extends (infer Item)[]\n        ? DeepConvertSnakeKeysToCamelCase<Item>[]\n        : {\n          [K in keyof U as SnakeToCamelCase<string & K>]: DeepConvertSnakeKeysToCamelCase<U[K]>\n        } & {}\n    : U\n  : T;\n\n/**\n * Deeply converts object keys from snake to camel case.\n * @param value - value to convert.\n */\nexport function deepSnakeToCamelObjKeys<T extends object>(\n  value: T,\n): DeepConvertSnakeKeysToCamelCase<T> {\n  const camelCased = snakeToCamelObjKeys(value);\n  for (const key in camelCased) {\n    const value = camelCased[key];\n    if (value && typeof value === 'object' && !(value instanceof Date)) {\n      (camelCased as any)[key] = Array.isArray(value)\n        ? value.map(deepSnakeToCamelObjKeys)\n        : deepSnakeToCamelObjKeys(value);\n    }\n  }\n  return camelCased as DeepConvertSnakeKeysToCamelCase<T>;\n}\n","import { errorClass, type ToSuperType } from './errorClass.js';\r\nimport { createIsInstanceOf } from './createIsInstanceOf.js';\r\n\r\nexport type ToDataFn<ConstructorArgs extends any[], Data> = (...args: ConstructorArgs) => Data;\r\n\r\nexport interface ErrorWithData<Data> extends Error {\r\n  readonly data: Data;\r\n}\r\n\r\nexport interface ErrorClassWithData<ConstructorArgs extends any[], Data> {\r\n  name: string;\r\n  new(...args: ConstructorArgs): ErrorWithData<Data>;\r\n  /**\r\n   * @returns True if the passed value is an instance of this class.\r\n   * @param value - value to check.\r\n   */\r\n  is: (value: unknown) => value is ErrorWithData<Data>;\r\n}\r\n\r\n/**\r\n * @returns A new error class with a predefined name and data type.\r\n * @param name - error name\r\n * @param toData - function converting constructor arguments to data\r\n * @param toSuper - a function converting passed arguments to a list of arguments passed to\r\n * the `Error` constructor. It can also be a message or a list of arguments passed to the\r\n * super constructor.\r\n */\r\nexport function errorClassWithData<Data, ConstructorArgs extends any[] = []>(\r\n  name: string,\r\n  toData: ToDataFn<ConstructorArgs, Data>,\r\n  toSuper?: ToSuperType<ConstructorArgs>,\r\n): ErrorClassWithData<ConstructorArgs, Data> {\r\n  class CustomError extends errorClass(name, toSuper) {\r\n    readonly data: Data;\r\n\r\n    constructor(...args: ConstructorArgs) {\r\n      super(...args);\r\n      this.data = toData(...args);\r\n    }\r\n\r\n    static is = createIsInstanceOf(CustomError);\r\n  }\r\n\r\n  Object.defineProperty(CustomError, 'name', { value: name });\r\n\r\n  return CustomError;\r\n}\r\n","/**\n * Converts string value from snake case to kebab case.\n * @param value - value to convert.\n */\nexport function snakeToKebab(value: string): string {\n  return value.replace(/_([a-z])/g, (_, letter) => `-${letter.toLowerCase()}`);\n}\n","/**\n * Converts a passed storage key to the formatted state.\n * @param key - storage key.\n */\nfunction formatKey(key: string): string {\n  return `tapps/${key}`;\n}\n\n/**\n * Saves value in the storage.\n * @param key - storage key.\n * @param value - storage value.\n */\nexport function setStorageValue<T>(key: string, value: T): void {\n  sessionStorage.setItem(formatKey(key), JSON.stringify(value));\n}\n\n/**\n * Extracts value from the storage.\n * @param key - storage key.\n */\nexport function getStorageValue<R>(key: string): R | undefined {\n  const value = sessionStorage.getItem(formatKey(key));\n  try {\n    return value ? JSON.parse(value) as R : undefined;\n  } catch {\n  }\n}\n","import { errorClass, errorClassWithData } from 'error-kid';\r\n\r\nexport class CancelledError extends errorClass('CancelledError', 'Promise was canceled') {\r\n}\r\n\r\nexport class TimeoutError extends errorClassWithData<\r\n  { timeout: number },\r\n  [timeout: number, cause?: unknown]\r\n>(\r\n  'TimeoutError',\r\n  timeout => ({ timeout }),\r\n  (timeout, cause) => [`Timeout reached: ${timeout}ms`, { cause }],\r\n) {\r\n}","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    try {\n        return e instanceof Error ? e : new Error(String(e));\n    }\n    catch (error) {\n        return new Error();\n    }\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n","const tag = Symbol('resolved');\r\n\r\nexport interface Resolved<T> {\r\n  tag: symbol;\r\n  value: T;\r\n}\r\n\r\nexport function isResolved<T = unknown>(value: unknown): value is Resolved<T> {\r\n  return typeof value === 'object'\r\n    && !!value\r\n    && 'tag' in value\r\n    && value.tag === tag;\r\n}\r\n\r\nexport function withResolved<T>(value: T): Resolved<T> {\r\n  return { tag, value };\r\n}","export type CallbackFn = () => void;\n\n/**\n * Returns a tuple, containing function to add cleanup, call cleanup, and flag showing whether\n * cleanup was called. Cleanup will not be performed in case, it was done before.\n */\nexport function createCbCollector(...cbs: (CallbackFn | CallbackFn[])[]): [\n  add: (...fns: CallbackFn[]) => void,\n  call: () => void,\n] {\n  const callbacks = cbs.flat(1);\n\n  return [\n    callbacks.push.bind(callbacks),\n    () => {\n      callbacks.forEach(cb => {\n        cb();\n      });\n    },\n  ];\n}\n","import { CancelledError, TimeoutError } from './errors.js';\r\nimport { withResolved } from './resolved-utils.js';\r\n\r\ntype Maybe<T> = T | undefined | null;\r\n\r\nexport interface BetterPromiseOptions {\r\n  /**\r\n   * Should the `abortSignal` passed to the executor be aborted if the promise was rejected.\r\n   *\r\n   * By default, as long as there is no point to perform any operations at the moment of rejection,\r\n   * the signal will be aborted.\r\n   * @default true\r\n   */\r\n  abortOnReject?: boolean;\r\n  /**\r\n   * Should the `abortSignal` passed to the executor be aborted if the promise was fulfilled.\r\n   *\r\n   * By default, as long as there is no point to perform any operations at the moment of resolve,\r\n   * the signal will be aborted.\r\n   * @default true\r\n   */\r\n  abortOnResolve?: boolean;\r\n  /**\r\n   * Signal to abort the execution.\r\n   */\r\n  abortSignal?: AbortSignal;\r\n  /**\r\n   * Execution timeout. After the timeout was reached, the promise will be aborted\r\n   * with the `TimeoutError` error.\r\n   */\r\n  timeout?: number;\r\n}\r\n\r\nexport type BetterPromiseResolveFn<T> = undefined extends T\r\n  ? (value?: T) => void\r\n  : (value: T) => void;\r\n\r\nexport type BetterPromiseRejectFn = (reason?: any) => void;\r\n\r\nexport type BetterPromiseRejectReason = TimeoutError | CancelledError | unknown;\r\n\r\ninterface EventMap<Result> {\r\n  resolved: Result;\r\n  rejected: BetterPromiseRejectReason;\r\n  finalized:\r\n    | { kind: 'resolved', result: Result }\r\n    | { kind: 'rejected', reason: BetterPromiseRejectReason };\r\n}\r\n\r\nexport interface BetterPromiseExecutorContext<Result> {\r\n  /**\r\n   * Abort signal. Will be aborted if the promise was rejected.\r\n   */\r\n  readonly abortSignal: AbortSignal;\r\n  /**\r\n   * @returns True if the promise was rejected.\r\n   */\r\n  get isRejected(): boolean;\r\n  /**\r\n   * @returns True if the promise was resolved.\r\n   */\r\n  get isResolved(): boolean;\r\n  /**\r\n   * Adds a new event listener to the specified event.\r\n   * @param event - event to listen to.\r\n   * @param listener - a corresponding callback function to call.\r\n   */\r\n  on<E extends keyof EventMap<Result>>(\r\n    event: E,\r\n    listener: (ev: EventMap<Result>[E]) => void,\r\n  ): VoidFunction;\r\n  /**\r\n   * @returns Promise resolve result if it was resolved.\r\n   */\r\n  get result(): Result | undefined;\r\n  /**\r\n   * @returns Promise rejection reason if the promise was rejected.\r\n   */\r\n  get rejectReason(): BetterPromiseRejectReason | undefined;\r\n  /**\r\n   * Will throw a rejection reason if the promise was rejected.\r\n   */\r\n  throwIfRejected: () => void;\r\n}\r\n\r\nexport type BetterPromiseExecutorFn<T> = (\r\n  res: BetterPromiseResolveFn<T>,\r\n  rej: BetterPromiseRejectFn,\r\n  context: BetterPromiseExecutorContext<T>,\r\n) => any;\r\n\r\nexport type BetterPromiseOnFulfilledFn<TResult1, TResult2> =\r\n  (value: TResult1) => TResult2 | PromiseLike<TResult2>;\r\n\r\nexport type BetterPromiseOnRejectedFn<T> = (value: any) => T | PromiseLike<T>;\r\n\r\nfunction withInheritedResolvers<P extends BetterPromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: BetterPromise<any>,\r\n): P {\r\n  childPromise.reject = parentPromise.reject;\r\n  childPromise.resolve = parentPromise.resolve;\r\n  return childPromise;\r\n}\r\n\r\nexport class BetterPromise<Result> extends Promise<Result> {\r\n  static fn<Result>(\r\n    fn: (context: BetterPromiseExecutorContext<Result>) => (Result | PromiseLike<Result>),\r\n    options?: BetterPromiseOptions,\r\n  ): BetterPromise<Awaited<Result>> {\r\n    return new BetterPromise(async (res, rej, context) => {\r\n      try {\r\n        res(await fn(context));\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): BetterPromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): BetterPromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): BetterPromise<Awaited<T>> {\r\n    return this.fn(() => value) as BetterPromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject(reason?: unknown): BetterPromise<never> {\r\n    return new BetterPromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n\r\n  constructor(options?: BetterPromiseOptions);\r\n  constructor(executor?: BetterPromiseExecutorFn<Result>, options?: BetterPromiseOptions);\r\n  constructor(\r\n    arg1?: BetterPromiseExecutorFn<Result> | BetterPromiseOptions,\r\n    maybeOptions?: BetterPromiseOptions,\r\n  ) {\r\n    let reject!: BetterPromiseRejectFn;\r\n    let resolve!: BetterPromiseResolveFn<Result>;\r\n    let executor: BetterPromiseExecutorFn<Result> | undefined;\r\n    let options: BetterPromiseOptions;\r\n\r\n    if (typeof arg1 === 'function') {\r\n      executor = arg1;\r\n      options = maybeOptions || {};\r\n    } else {\r\n      options = arg1 || {};\r\n    }\r\n\r\n    let resolved: [Result] | undefined;\r\n    let rejected: [BetterPromiseRejectReason] | undefined;\r\n    const isRejected = () => !!rejected;\r\n    const isResolved = () => !!resolved;\r\n    let listeners: {\r\n      [E in keyof EventMap<Result>]?: ((data: EventMap<Result>[E]) => void)[];\r\n    } = {};\r\n\r\n    //#region Cleanup section.\r\n    const cleanupFns: VoidFunction[] = [];\r\n    const cleanup = () => {\r\n      cleanupFns.forEach(fn => fn());\r\n      cleanupFns.splice(0, cleanupFns.length);\r\n      listeners = {};\r\n    };\r\n    //#endregion\r\n\r\n    // We are going to use our controller signal in the executor because we can control it.\r\n    // We can't say the same about the abort signal passed from above - we can't abort it by\r\n    // ourselves.\r\n    const controller = new AbortController();\r\n    const isResolvedOrRejected = () => isResolved() || isRejected();\r\n\r\n    super((res, rej) => {\r\n      // Enhance resolve and reject functions with cleanup and controller abortion.\r\n      const { abortOnResolve = true, abortOnReject = true } = options;\r\n      resolve = ((result: Result) => {\r\n        if (!isResolvedOrRejected()) {\r\n          res(result);\r\n          resolved = [result];\r\n          listeners.resolved?.forEach(l => l(result));\r\n          listeners.finalized?.forEach(l => l({ kind: 'resolved', result }));\r\n          cleanup();\r\n\r\n          if (abortOnResolve) {\r\n            controller.abort(withResolved<Result>(result));\r\n          }\r\n        }\r\n      }) as BetterPromiseResolveFn<Result>;\r\n      reject = reason => {\r\n        if (!isResolvedOrRejected()) {\r\n          rej(reason);\r\n          rejected = [reason];\r\n          listeners.rejected?.forEach(l => l(reason));\r\n          listeners.finalized?.forEach(l => l({ kind: 'rejected', reason }));\r\n          cleanup();\r\n\r\n          if (abortOnReject) {\r\n            controller.abort(reason);\r\n          }\r\n        }\r\n      };\r\n\r\n      //#region Process abortSignal option.\r\n      const { abortSignal } = options;\r\n      if (abortSignal) {\r\n        if (abortSignal.aborted) {\r\n          return reject(abortSignal.reason);\r\n        }\r\n        // Whenever the passed abort signal aborts, we are also aborting our locally created\r\n        // signal.\r\n        const listener = () => {\r\n          reject(abortSignal.reason);\r\n        };\r\n        abortSignal.addEventListener('abort', listener, true);\r\n        cleanupFns.push(() => {\r\n          abortSignal.removeEventListener('abort', listener, true);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      //#region Process timeout option.\r\n      const { timeout } = options;\r\n      if (timeout) {\r\n        const timeoutId = setTimeout(() => {\r\n          reject(new TimeoutError(timeout));\r\n        }, timeout);\r\n        cleanupFns.push(() => {\r\n          clearTimeout(timeoutId);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      try {\r\n        const voidFn = () => undefined;\r\n        const result = executor && executor(resolve, reject, {\r\n          abortSignal: controller.signal,\r\n          get isRejected() {\r\n            return isRejected();\r\n          },\r\n          get isResolved() {\r\n            return isResolved();\r\n          },\r\n          on(event, listener) {\r\n            // The promise may already be finalized. In this case we just call the listener.\r\n            if (resolved || rejected) {\r\n              if (event === 'finalized') {\r\n                const payload = resolved\r\n                  ? { kind: 'resolved', result: resolved[0] } as const\r\n                  : { kind: 'rejected', reason: rejected![0] } as const;\r\n                (\r\n                  listener as (\r\n                    data:\r\n                      | { kind: 'resolved', result: Result }\r\n                      | { kind: 'rejected', reason: BetterPromiseRejectReason },\r\n                  ) => void\r\n                )(payload);\r\n              } else if (event === 'resolved' && resolved) {\r\n                (listener as (result: Result) => void)(resolved[0]);\r\n              } else if (event === 'rejected' && rejected) {\r\n                (listener as (reason: BetterPromiseRejectReason) => void)(rejected[0]);\r\n              }\r\n              return voidFn;\r\n            }\r\n            listeners[event] ||= [];\r\n            listeners[event].push(listener);\r\n\r\n            return () => {\r\n              const eventListeners: any[] = listeners[event] || [];\r\n              const index = eventListeners.indexOf(listener);\r\n              if (index >= 0) {\r\n                eventListeners.splice(index, 1);\r\n              }\r\n            };\r\n          },\r\n          get result() {\r\n            return resolved?.[0];\r\n          },\r\n          get rejectReason() {\r\n            return rejected?.[0];\r\n          },\r\n          throwIfRejected() {\r\n            if (rejected) {\r\n              throw rejected[0];\r\n            }\r\n          },\r\n        });\r\n\r\n        // If a promise was returned, we want to handle its rejection because the JS Promise\r\n        // will not do it for us. Not catching the promise rejection this way, an unhandled promise\r\n        // rejection error will be thrown. We also need to perform reject properly cleaning up\r\n        // all effects.\r\n        if (result instanceof Promise) {\r\n          result.catch(reject);\r\n        }\r\n      } catch (e) {\r\n        // The wrapped executor may throw an error. Here we are following the same logic described\r\n        // in result.catch() line above.\r\n        reject(e);\r\n      }\r\n    });\r\n\r\n    this.reject = reject;\r\n    this.resolve = resolve;\r\n  }\r\n\r\n  /**\r\n   * Rejects the promise with the `CancelledError` error.\r\n   */\r\n  cancel(): void {\r\n    this.reject(new CancelledError());\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<BetterPromiseOnRejectedFn<CatchResult>>,\r\n  ): BetterPromise<Result | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): BetterPromise<Result> {\r\n    // Here we follow the same logic described in the \"then\" method.\r\n    return withInheritedResolvers(super.finally(onFinally) as BetterPromise<Result>, this);\r\n  }\r\n\r\n  /**\r\n   * Rejects the initially created promise.\r\n   *\r\n   * This method not only aborts the signal passed to the executor, but also rejects the\r\n   * promise itself calling all chained listeners.\r\n   *\r\n   * The reason passed to the method is being passed as-is to the executor's context.\r\n   */\r\n  reject: BetterPromiseRejectFn;\r\n\r\n  /**\r\n   * Resolves the promise.\r\n   */\r\n  resolve: BetterPromiseResolveFn<Result>;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = Result, B = never>(\r\n    onFulfilled?: Maybe<BetterPromiseOnFulfilledFn<Result, A>>,\r\n    onRejected?: Maybe<BetterPromiseOnRejectedFn<B>>,\r\n  ): BetterPromise<A | B> {\r\n    // Use the original promise \"then\" method because in fact, it creates an AbortablePromise\r\n    // instance.\r\n    // Then, reassign the promise \"reject\" method, because not doing it and rejecting the promise\r\n    // it will lead to an unhandled promise rejection.\r\n    //\r\n    // Here is an example:\r\n    // const myPromise = new AbortablePromise(...)\r\n    //   .catch(() => console.log('Catched'));\r\n    //\r\n    // If we don't reassign myPromise's \"reject\" method here, it will reject the promise, returned\r\n    // from the \"catch\" method, which is unexpected. So, even using several catches in a row,\r\n    // a developer will not be able to catch the error, thrown using the \"reject\" method.\r\n    //\r\n    // The expected behavior here is the \"reject\" method rejecting the initially created promise.\r\n    // Then, this error will be handled via the \"catch\" method.\r\n    return withInheritedResolvers(\r\n      super.then(onFulfilled, onRejected) as BetterPromise<A | B>,\r\n      this,\r\n    );\r\n  }\r\n}","import {\n  type BaseIssue,\n  type BaseSchema,\n  check,\n  type CheckAction,\n  type InferOutput,\n  instance,\n  type InstanceSchema,\n  parse, pipe,\n  type SchemaWithPipe,\n  string,\n  type StringSchema,\n  transform,\n  type TransformAction,\n  union,\n  type UnionSchema,\n} from 'valibot';\n\ntype RequiredSchema = BaseSchema<any, any, BaseIssue<any>>;\n\nexport type TransformJsonToSchemaAction<Schema extends RequiredSchema> = SchemaWithPipe<readonly [\n  StringSchema<any>,\n  CheckAction<string, string>,\n  TransformAction<string, unknown>,\n  Schema,\n]>;\n\nexport type TransformQueryToSchemaAction<Schema extends RequiredSchema> = SchemaWithPipe<readonly [\n  UnionSchema<[\n    StringSchema<undefined>,\n    InstanceSchema<typeof URLSearchParams, undefined>,\n  ], undefined>,\n  CheckAction<string | URLSearchParams, string>,\n  TransformAction<string | URLSearchParams, InferOutput<Schema>>,\n]>;\n\nexport function transformQueryToSchema<Schema extends RequiredSchema>(\n  schema: Schema,\n): TransformQueryToSchemaAction<Schema> {\n  const transformer = (input: string | URLSearchParams) => {\n    const result: Record<string, string | string[]> = {};\n\n    new URLSearchParams(input).forEach((value, key) => {\n      const accValue = result[key];\n      if (Array.isArray(accValue)) {\n        accValue.push(value);\n      } else if (accValue === undefined) {\n        result[key] = value;\n      } else {\n        result[key] = [accValue, value];\n      }\n    });\n\n    return parse(schema, result);\n  };\n\n  return pipe(\n    union([string(), instance(URLSearchParams)]),\n    check(input => {\n      try {\n        transformer(input);\n        return true;\n      } catch {\n        return false;\n      }\n    }, 'The value doesn\\'t match required schema'),\n    transform(transformer),\n  );\n}\n\n/**\n * @returns A transformer applying `JSON.parse` to the input.\n */\nexport function transformJsonToSchema<Schema extends RequiredSchema>(\n  schema: Schema,\n): TransformJsonToSchemaAction<Schema> {\n  return pipe(\n    string(),\n    check(input => {\n      try {\n        JSON.parse(input);\n        return true;\n      } catch {\n        return false;\n      }\n    }, 'Input is not a valid JSON value'),\n    transform(JSON.parse),\n    schema,\n  );\n}\n","/**\n * Message log level.\n */\nexport type LogLevel = 'log' | 'error' | 'warn';\n\nexport interface LoggerOptions {\n  bgColor?: string;\n  textColor?: string;\n  /**\n   * True if logs are enabled.\n   * @default true\n   */\n  shouldLog?: boolean | (() => boolean);\n}\n\nexport type LoggerFn = (...args: any[]) => void;\nexport type LoggerForceFn = (...args: any[]) => void;\n\nexport interface Logger {\n  /**\n   * Prints an error message into the console.\n   * @param args - items to log.\n   */\n  error: LoggerFn;\n  /**\n   * Prints an error message into the console ignoring the `shouldLog`\n   * constructor option.\n   * @param args - items to log.\n   */\n  forceError: LoggerForceFn;\n  /**\n   * Prints a log message into the console ignoring the `shouldLog` constructor\n   * option.\n   * @param args - items to log.\n   */\n  forceLog: LoggerForceFn;\n  /**\n   * Prints a warning message into the console ignoring the `shouldLog`\n   * constructor option.\n   * @param args - items to log.\n   */\n  forceWarn: LoggerForceFn;\n  /**\n   * Prints a log message into the console.\n   * @param args - items to log.\n   */\n  log: LoggerFn;\n  /**\n   * Prints a warning message into the console.\n   * @param args - items to log.\n   */\n  warn: LoggerFn;\n}\n\n/* @__NO_SIDE_EFFECTS__*/\nexport function createLogger(scope: string, options?: LoggerOptions): Logger {\n  options ||= {};\n  const {\n    textColor,\n    bgColor,\n    shouldLog: optionsShouldLog,\n  } = options;\n  const shouldLogValue = optionsShouldLog === undefined ? true : optionsShouldLog;\n  const shouldLog = typeof shouldLogValue === 'boolean'\n    ? () => shouldLogValue\n    : shouldLogValue;\n\n  /**\n   * Prints a message into the console.\n   * @param level - log level.\n   * @param force - should `shouldLog` value be ignored.\n   * @param args - arguments.\n   */\n  const print = (level: LogLevel, force: boolean, ...args: any[]): void => {\n    if (force || shouldLog()) {\n      const commonCss = 'font-weight:bold;padding:0 5px;border-radius:100px';\n      const [timeBgColor, timeTextColor, prefix] = {\n        log: ['#0089c3', 'white', 'INFO'],\n        error: ['#ff0000F0', 'white', 'ERR'],\n        warn: ['#D38E15', 'white', 'WARN'],\n      }[level];\n      console[level](\n        `%c${prefix} ${\n          Intl\n            .DateTimeFormat('en-GB', {\n              hour: '2-digit',\n              minute: '2-digit',\n              second: '2-digit',\n              fractionalSecondDigits: 3,\n              timeZone: 'UTC',\n            })\n            .format(new Date())\n        }%c %c${scope}`,\n        `${commonCss};background-color:${timeBgColor};color:${timeTextColor}`,\n        '',\n        `${commonCss};${textColor ? `color:${textColor};` : ''}${bgColor ? `background-color:${bgColor}` : ''}`,\n        ...args,\n      );\n    }\n  };\n\n  return ([\n    ['log', 'forceLog'],\n    ['warn', 'forceWarn'],\n    ['error', 'forceError'],\n  ] as const).reduce<Logger>((acc, [level, forceMethod]) => {\n    acc[level] = print.bind(undefined, level, false);\n    acc[forceMethod] = print.bind(undefined, level, true);\n    return acc;\n  }, {} as Logger);\n}\n","import {\n  type BaseIssue,\n  type BaseSchema,\n  instance,\n  type InstanceSchema,\n  pipe,\n  type SchemaWithPipe,\n  string,\n  type StringSchema,\n  union,\n  type UnionSchema,\n} from 'valibot';\n\nimport {\n  transformJsonToSchema,\n  type TransformJsonToSchemaAction,\n  transformQueryToSchema,\n  type TransformQueryToSchemaAction,\n} from './transformers.js';\n\ntype RequiredSchema = BaseSchema<any, any, BaseIssue<any>>;\n\nexport type JsonToSchemaPipe<Schema extends RequiredSchema> = SchemaWithPipe<readonly [\n  StringSchema<undefined>,\n  TransformJsonToSchemaAction<Schema>,\n]>;\n\nexport type QueryToSchemaPipe<Schema extends RequiredSchema> = SchemaWithPipe<readonly [\n  UnionSchema<[\n    StringSchema<undefined>,\n    InstanceSchema<typeof URLSearchParams, undefined>,\n  ], undefined>,\n  TransformQueryToSchemaAction<Schema>,\n]>;\n\nexport function pipeJsonToSchema<Schema extends RequiredSchema>(\n  schema: Schema,\n): JsonToSchemaPipe<Schema> {\n  return pipe(string(), transformJsonToSchema(schema));\n}\n\nexport function pipeQueryToSchema<Schema extends RequiredSchema>(\n  schema: Schema,\n): QueryToSchemaPipe<Schema> {\n  return pipe(\n    union([string(), instance(URLSearchParams)]),\n    transformQueryToSchema(schema),\n  );\n}\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n","import { throwifyFpFn } from '@tma.js/toolkit';\nimport type { RGB } from '@tma.js/types';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nfunction guardBasedOn(re: RegExp) {\n  return (value: string): value is RGB => re.test(value);\n}\n\n/**\n * @returns True if the value has the #RGB format.\n */\nexport const isRGBShort = guardBasedOn(/^#[\\da-f]{3}$/i);\n\n/**\n * @returns True if the value has the #RGBA format.\n */\nexport const isRGBAShort = guardBasedOn(/^#[\\da-f]{4}$/i);\n\n/**\n * @returns True if the value has the #RRGGBB format.\n */\nexport const isRGB = guardBasedOn(/^#[\\da-f]{6}$/i);\n\n/**\n * @returns True if the value has the #RRGGBBAA format.\n */\nexport const isRGBA = guardBasedOn(/^#[\\da-f]{8}$/i);\n\n/**\n * @returns True if the value has any known RGB format.\n * @param value - value to check.\n */\nexport function isAnyRGB(value: string): value is RGB {\n  return [isRGB, isRGBA, isRGBShort, isRGBAShort].some(fn => fn(value));\n}\n\n/**\n * Converts a short version of RGB (#RGB) to a complete one (#RRGGBB).\n * @param value\n */\nfunction expandRgb(value: RGB): RGB {\n  let color: RGB = '#';\n  for (let i = 0; i < value.length - 1; i += 1) {\n    color += value[1 + i].repeat(2);\n  }\n  return color;\n}\n\n/**\n * Converts passed value to #RRGGBBAA format. Accepts the following color formats:\n * - `#RGB`\n * - `#RGBA`\n * - `#RRGGBB`\n * - `#RRGGBBAA`\n * - `rgb(1,2,3)`\n * - `rgba(1,2,3,4)`\n * @param value - a value to convert.\n * @returns A value in the #RRGGBBAA format.\n */\nexport function toRGBFullFp(value: string): E.Either<Error, RGB> {\n  const clean = value.replace(/\\s/g, '').toLowerCase();\n  if (/^#[\\da-f]{3}$/i.test(clean)) {\n    return E.right(expandRgb(clean.toLowerCase() + 'f' as RGB));\n  }\n\n  if (/^#[\\da-f]{4}$/i.test(clean)) {\n    return E.right(expandRgb(clean.toLowerCase() as RGB));\n  }\n\n  if (/^#[\\da-f]{6}$/i.test(clean)) {\n    return E.right(clean.toLowerCase() + 'ff' as RGB);\n  }\n\n  if (/^#[\\da-f]{8}$/i.test(clean)) {\n    return E.right(clean.toLowerCase() as RGB);\n  }\n\n  // Example valid values: rgb(0,3,10) rgba(32,114,8,0)\n  const match = clean.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/)\n    || clean.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/);\n\n  // If this didn't work as well, we can't extract RGB color from passed text.\n  if (!match) {\n    return E.left(new Error(`Value \"${value}\" does not satisfy any of known RGB formats.`));\n  }\n\n  // Otherwise, take R, G and B components, convert to hex and create #RRGGBB string.\n  return E.right(\n    match\n      .slice(1)\n      .reduce(\n        (acc, component) => {\n          return acc + parseInt(component, 10)\n            .toString(16)\n            .padStart(2, '0');\n        }, '#',\n      )\n      // We are adding f-s here to match the pattern: #RRGGBBAA\n      .padEnd(9, 'f') as RGB,\n  );\n}\n\n/**\n * Converts passed value to #RRGGBB format. Accepts the following color formats:\n * - `#RGB`\n * - `#RGBA`\n * - `#RRGGBB`\n * - `#RRGGBBAA`\n * - `rgb(1,2,3)`\n * - `rgba(1,2,3,4)`\n * @param value - a value to convert.\n * @returns A value in the #RRGGBB format.\n * @deprecated This function cuts the RGB's alpha channel. Use the `toRGBFullFp` function instead.\n */\nexport function toRGBFp(value: string): E.Either<Error, RGB> {\n  return pipe(\n    toRGBFullFp(value),\n    E.map(rgb => rgb.slice(0, 7) as RGB),\n  );\n}\n\n/**\n * @see toRGBFp\n * @deprecated This function cuts the RGB's alpha channel. Use the `toRGBFull` function instead.\n */\nexport const toRGB = throwifyFpFn(toRGBFp);\n\n/**\n * @see toRGBFullFp\n */\nexport const toRGBFull = throwifyFpFn(toRGBFullFp);\n","import type {\n  Chat,\n  InitData,\n  KnownThemeParamsKey,\n  LaunchParams,\n  RGB,\n  User,\n} from '@tma.js/types';\nimport {\n  type BaseSchema,\n  boolean,\n  check,\n  type CheckAction,\n  date,\n  type InferOutput,\n  integer,\n  is,\n  looseObject,\n  number,\n  type NumberSchema,\n  optional,\n  pipe,\n  record,\n  type RecordSchema,\n  type SchemaWithPipe,\n  string,\n  type StringSchema,\n  transform,\n  type TransformAction,\n  union,\n  type UnionSchema,\n  unknown,\n} from 'valibot';\n\nimport { pipeJsonToSchema, pipeQueryToSchema } from './pipes.js';\nimport { isAnyRGB } from './rgb.js';\n\nexport type InitDataGenSchema = ReturnType<typeof initData>;\nexport type InitDataGenType = InferOutput<InitDataGenSchema>;\n\nexport type LaunchParamsGenSchema = ReturnType<typeof launchParams>;\nexport type LaunchParamsGenType = InferOutput<LaunchParamsGenSchema>;\n\nexport type MiniAppsMessageGenSchema = ReturnType<typeof miniAppsMessage>;\nexport type MiniAppsMessageGenType = InferOutput<MiniAppsMessageGenSchema>;\n\nexport function initDataChat() {\n  return looseObject({\n    id: number(),\n    photo_url: optional(string()),\n    type: string(),\n    title: string(),\n    username: optional(string()),\n  } satisfies { [K in keyof Chat]-?: BaseSchema<unknown, Chat[K], any> });\n}\n\nexport function initDataUser() {\n  return looseObject({\n    added_to_attachment_menu: optional(boolean()),\n    allows_write_to_pm: optional(boolean()),\n    first_name: string(),\n    id: number(),\n    is_bot: optional(boolean()),\n    is_premium: optional(boolean()),\n    last_name: optional(string()),\n    language_code: optional(string()),\n    photo_url: optional(string()),\n    username: optional(string()),\n  } satisfies { [K in keyof User]-?: BaseSchema<unknown, User[K], any> });\n}\n\nexport function initData() {\n  return looseObject({\n    auth_date: pipe(\n      string(),\n      transform(input => new Date(Number(input) * 1000)),\n      date(),\n    ),\n    can_send_after: optional(pipe(string(), transform(Number), integer())),\n    chat: optional(pipeJsonToSchema(initDataChat())),\n    chat_type: optional(string()),\n    chat_instance: optional(string()),\n    hash: string(),\n    query_id: optional(string()),\n    receiver: optional(pipeJsonToSchema(initDataUser())),\n    start_param: optional(string()),\n    signature: string(),\n    user: optional(pipeJsonToSchema(initDataUser())),\n  } satisfies { [K in keyof InitData]-?: unknown });\n}\n\nexport function initDataQuery() {\n  return pipeQueryToSchema(initData());\n}\n\nexport function themeParams() {\n  return record(\n    string(),\n    pipe(\n      union([string(), number()]),\n      transform(value => {\n        return typeof value === 'number'\n          ? `#${(value & 0x00FFFFFF).toString(16).padStart(6, '0')}`\n          : value;\n      }),\n      check(isAnyRGB),\n    ),\n  ) as RecordSchema<\n    SchemaWithPipe<[\n      StringSchema<undefined>,\n      TransformAction<string, KnownThemeParamsKey>,\n    ]>,\n    SchemaWithPipe<[\n      UnionSchema<[StringSchema<undefined>, NumberSchema<undefined>], any>,\n      TransformAction<string | number, string>,\n      CheckAction<RGB, undefined>,\n    ]>,\n    undefined\n  >;\n}\n\nexport function launchParams() {\n  const optBool = optional(pipe(string(), transform(v => v === '1')));\n\n  return looseObject({\n    tgWebAppBotInline: optBool,\n    tgWebAppData: optional(initDataQuery()),\n    tgWebAppDefaultColors: optional(pipeJsonToSchema(themeParams())),\n    tgWebAppFullscreen: optBool,\n    tgWebAppPlatform: string(),\n    tgWebAppShowSettings: optBool,\n    tgWebAppStartParam: optional(string()),\n    tgWebAppThemeParams: pipeJsonToSchema(themeParams()),\n    tgWebAppVersion: string(),\n  } satisfies { [K in keyof LaunchParams]-?: BaseSchema<any, LaunchParams[K], any> });\n}\n\nexport function launchParamsQuery() {\n  return pipeQueryToSchema(launchParams());\n}\n\n/**\n * @returns True if the passed value contains valid launch parameters query.\n */\nexport function isLaunchParamsQuery(value: string | URLSearchParams): boolean {\n  try {\n    return is(launchParamsQuery(), value);\n  } catch {\n    return false;\n  }\n}\n\nexport function miniAppsMessage() {\n  return looseObject({\n    eventType: string(),\n    eventData: optional(unknown()),\n  });\n}\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    try {\n        return e instanceof Error ? e : new Error(String(e));\n    }\n    catch (error) {\n        return new Error();\n    }\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n","import { ap as ap_ } from './Apply';\nimport * as E from './Either';\nimport { flow, pipe } from './function';\nimport { map as map_ } from './Functor';\nexport function right(F) {\n    return flow(E.right, F.of);\n}\nexport function left(F) {\n    return flow(E.left, F.of);\n}\nexport function rightF(F) {\n    return function (fa) { return F.map(fa, E.right); };\n}\nexport function leftF(F) {\n    return function (fe) { return F.map(fe, E.left); };\n}\nexport function fromNullable(F) {\n    return function (e) { return flow(E.fromNullable(e), F.of); };\n}\nexport function fromNullableK(F) {\n    var fromNullableF = fromNullable(F);\n    return function (e) {\n        var fromNullableFE = fromNullableF(e);\n        return function (f) { return flow(f, fromNullableFE); };\n    };\n}\nexport function chainNullableK(M) {\n    var chainM = chain(M);\n    var fromNullableKM = fromNullableK(M);\n    return function (e) {\n        var fromNullableKMe = fromNullableKM(e);\n        return function (f) { return chainM(fromNullableKMe(f)); };\n    };\n}\nexport function map(F) {\n    return map_(F, E.Functor);\n}\nexport function ap(F) {\n    return ap_(F, E.Apply);\n}\nexport function chain(M) {\n    var flatMapM = flatMap(M);\n    return function (f) { return function (ma) { return flatMapM(ma, f); }; };\n}\n/** @internal */\nexport function flatMap(M) {\n    return function (ma, f) { return M.chain(ma, function (e) { return (E.isLeft(e) ? M.of(e) : f(e.right)); }); };\n}\nexport function alt(M) {\n    return function (second) { return function (first) { return M.chain(first, function (e) { return (E.isLeft(e) ? second() : M.of(e)); }); }; };\n}\nexport function bimap(F) {\n    var mapBothF = mapBoth(F);\n    return function (f, g) { return function (self) { return mapBothF(self, f, g); }; };\n}\n/** @internal */\nexport function mapBoth(F) {\n    return function (self, f, g) { return F.map(self, E.bimap(f, g)); };\n}\nexport function mapLeft(F) {\n    var mapErrorF = mapError(F);\n    return function (f) { return function (self) { return mapErrorF(self, f); }; };\n}\n/** @internal */\nexport function mapError(F) {\n    return function (self, f) { return F.map(self, E.mapLeft(f)); };\n}\nexport function altValidation(M, S) {\n    return function (second) { return function (first) {\n        return M.chain(first, E.match(function (e1) {\n            return M.map(second(), E.mapLeft(function (e2) { return S.concat(e1, e2); }));\n        }, right(M)));\n    }; };\n}\nexport function match(F) {\n    return function (onLeft, onRight) { return function (ma) { return F.map(ma, E.match(onLeft, onRight)); }; };\n}\nexport function matchE(M) {\n    return function (onLeft, onRight) { return function (ma) { return M.chain(ma, E.match(onLeft, onRight)); }; };\n}\nexport function getOrElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, E.match(onLeft, M.of)); }; };\n}\nexport function orElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, function (e) { return (E.isLeft(e) ? onLeft(e.left) : M.of(e)); }); }; };\n}\nexport function orElseFirst(M) {\n    var tapErrorM = tapError(M);\n    return function (onLeft) { return function (ma) { return tapErrorM(ma, onLeft); }; };\n}\n/** @internal */\nexport function tapError(M) {\n    var orElseM = orElse(M);\n    return function (ma, onLeft) {\n        return pipe(ma, orElseM(function (e) { return M.map(onLeft(e), function (eb) { return (E.isLeft(eb) ? eb : E.left(e)); }); }));\n    };\n}\nexport function orLeft(M) {\n    return function (onLeft) { return function (ma) {\n        return M.chain(ma, E.match(function (e) { return M.map(onLeft(e), E.left); }, function (a) { return M.of(E.right(a)); }));\n    }; };\n}\nexport function swap(F) {\n    return function (ma) { return F.map(ma, E.swap); };\n}\nexport function toUnion(F) {\n    return function (fa) { return F.map(fa, E.toUnion); };\n}\n/** @deprecated  */\n/* istanbul ignore next */\nexport function getEitherM(M) {\n    var _ap = ap(M);\n    var _map = map(M);\n    var _chain = chain(M);\n    var _alt = alt(M);\n    var _bimap = bimap(M);\n    var _mapLeft = mapLeft(M);\n    var _fold = matchE(M);\n    var _getOrElse = getOrElse(M);\n    var _orElse = orElse(M);\n    return {\n        map: function (fa, f) { return pipe(fa, _map(f)); },\n        ap: function (fab, fa) { return pipe(fab, _ap(fa)); },\n        of: right(M),\n        chain: function (ma, f) { return pipe(ma, _chain(f)); },\n        alt: function (fa, that) { return pipe(fa, _alt(that)); },\n        bimap: function (fea, f, g) { return pipe(fea, _bimap(f, g)); },\n        mapLeft: function (fea, f) { return pipe(fea, _mapLeft(f)); },\n        fold: function (fa, onLeft, onRight) { return pipe(fa, _fold(onLeft, onRight)); },\n        getOrElse: function (fa, onLeft) { return pipe(fa, _getOrElse(onLeft)); },\n        orElse: function (fa, f) { return pipe(fa, _orElse(f)); },\n        swap: swap(M),\n        rightM: rightF(M),\n        leftM: leftF(M),\n        left: left(M)\n    };\n}\n","/**\n * ```ts\n * interface Task<A> {\n *   (): Promise<A>\n * }\n * ```\n *\n * `Task<A>` represents an asynchronous computation that yields a value of type `A` and **never fails**.\n * If you want to represent an asynchronous computation that may fail, please see `TaskEither`.\n *\n * @since 2.0.0\n */\nimport { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { dual, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIO = function (ma) { return function () { return Promise.resolve().then(ma); }; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as T from 'fp-ts/Task'\n * import { takeRight } from 'fp-ts/Array'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = T.delay(20)(append('b'))\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])\n * }\n *\n * test()\n *\n * @since 2.0.0\n */\nexport function delay(millis) {\n    return function (ma) { return function () {\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                Promise.resolve().then(ma).then(resolve);\n            }, millis);\n        });\n    }; };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return function () {\n    return Promise.resolve().then(fa).then(f);\n}; }; };\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) { return function () {\n    return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function (_a) {\n        var f = _a[0], a = _a[1];\n        return f(a);\n    });\n}; }; };\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return function () { return Promise.resolve(a); }; };\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return function () {\n        return Promise.resolve()\n            .then(ma)\n            .then(function (a) { return f(a)(); });\n    };\n});\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Task';\n/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getRaceMonoid() {\n    return {\n        concat: function (x, y) { return function () { return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]); }; },\n        empty: never\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the value to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the value to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO\n};\n/**\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var fromTask = identity;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIO = _.flatMapIO(_FromIO, _FlatMap);\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as T from 'fp-ts/Task'\n * import * as Console from 'fp-ts/Console'\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effect = pipe(\n *   T.of('fp-ts'),\n *   T.tapIO((value) => Console.log(`Hello, ${value}`)),\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), 'fp-ts')\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOK = \n/*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * A `Task` that never completes.\n *\n * @since 2.0.0\n */\nexport var never = function () { return new Promise(function (_) { return undefined; }); };\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        return function () {\n            return Promise.all(as.map(function (a, i) { return Promise.resolve().then(function () { return f(i, a)(); }); }));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (bs) {\n                    return Promise.resolve()\n                        .then(f(i + 1, a))\n                        .then(function (b) {\n                        bs.push(b);\n                        return bs;\n                    });\n                });\n            }, Promise.resolve()\n                .then(f(0, _.head(as)))\n                .then(_.singleton));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) {\n    return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.task`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var task = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.taskSeq`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskSeq = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = /*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMonoid = /*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n","import { throwifyFpFn } from '@tma.js/toolkit';\nimport * as E from 'fp-ts/Either';\nimport { parse, type ValiError } from 'valibot';\n\nimport {\n  type InitDataGenSchema,\n  type InitDataGenType,\n  initDataQuery,\n  type LaunchParamsGenSchema,\n  type LaunchParamsGenType,\n  launchParamsQuery,\n} from './structures.js';\n\nexport type ParseInitDataQueryError = ValiError<InitDataGenSchema>;\nexport type ParseLaunchParamsQueryError = ValiError<LaunchParamsGenSchema>;\n\nexport function parseInitDataQueryFp(value: string | URLSearchParams): E.Either<\n  ParseInitDataQueryError,\n  InitDataGenType\n> {\n  return E.tryCatch(\n    () => parse(initDataQuery(), value),\n    e => e as ValiError<InitDataGenSchema>,\n  );\n}\n\nexport function parseLaunchParamsQueryFp(value: string | URLSearchParams): E.Either<\n  ParseLaunchParamsQueryError,\n  LaunchParamsGenType\n> {\n  return E.tryCatch(\n    () => parse(launchParamsQuery(), value),\n    e => e as ValiError<LaunchParamsGenSchema>,\n  );\n}\n\nexport const parseInitDataQuery = throwifyFpFn(parseInitDataQueryFp);\nexport const parseLaunchParamsQuery = throwifyFpFn(parseLaunchParamsQueryFp);\n","import type { InitData, LaunchParams } from '@tma.js/types';\nimport type { InferOutput } from 'valibot';\n\nimport type { initData, launchParams } from './structures.js';\n\nexport type InitDataLike = Partial<InferOutput<ReturnType<typeof initData>> | InitData>;\nexport type LaunchParamsLike = Partial<InferOutput<ReturnType<typeof launchParams>> | LaunchParams>;\n\n/**\n * Converts the passed object to query parameters.\n * @param value - value to serialize.\n * @param onObject - function returning serialized object value.\n */\nfunction serializeToQuery(\n  value: object,\n  onObject?: (key: string, value: object) => string,\n): string {\n  onObject ||= (_, value) => JSON.stringify(value);\n\n  return new URLSearchParams(\n    Object\n      .entries(value)\n      .reduce<[string, string][]>((acc, [key, value]) => {\n        if (Array.isArray(value)) {\n          acc.push(...value.map(v => [key, String(v)] as [string, string]));\n        } else {\n          if (value !== null && value !== undefined) {\n            acc.push([\n              key,\n              value instanceof Date\n                ? (value.getTime() / 1000 | 0).toString()\n                : typeof value === 'string' || typeof value === 'number'\n                  ? String(value)\n                  : typeof value === 'boolean'\n                    ? value ? '1' : '0'\n                    : onObject(key, value),\n            ]);\n          }\n        }\n        return acc;\n      }, []),\n  ).toString();\n}\n\n/**\n * Serializes the InitDataQuery shape.\n * @param value - value to serialize.\n */\nexport function serializeInitDataQuery(value: InitDataLike): string {\n  return serializeToQuery(value);\n}\n\n/**\n * Serializes the LaunchParamsQuery shape.\n * @param value - value to serialize.\n */\nexport function serializeLaunchParamsQuery(value: LaunchParamsLike): string {\n  return serializeToQuery(value, (k, v) => {\n    return k === 'tgWebAppData' ? serializeInitDataQuery(v as any) : JSON.stringify(v);\n  });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { getApplicativeMonoid } from './Applicative';\nimport { ap as ap_, apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { compact as compact_, separate as separate_ } from './Compactable';\nimport * as E from './Either';\nimport * as ET from './EitherT';\nimport { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, tapEither as tapEither_ } from './FromEither';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { fromTaskK as fromTaskK_, tapTask as tapTask_ } from './FromTask';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as T from './Task';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var left = /*#__PURE__*/ ET.left(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var right = /*#__PURE__*/ ET.right(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightTask = /*#__PURE__*/ ET.rightF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftTask = /*#__PURE__*/ ET.leftF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightIO = /*#__PURE__*/ flow(T.fromIO, rightTask);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftIO = /*#__PURE__*/ flow(T.fromIO, leftTask);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromIO = rightIO;\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromTask = rightTask;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = T.of;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIOEither = T.fromIO;\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromTaskOption = function (onNone) {\n    return T.map(E.fromOption(onNone));\n};\n/**\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = \n/*#__PURE__*/ ET.match(T.Functor);\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = match;\n/**\n * The `E` suffix (short for **E**ffect) means that the handlers return an effect (`Task`).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchE = /*#__PURE__*/ ET.matchE(T.Monad);\n/**\n * Alias of [`matchE`](#matche).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = matchE;\n/**\n * Less strict version of [`matchE`](#matche).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchEW = matchE;\n/**\n * Alias of [`matchEW`](#matchew).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchEW;\n/**\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = \n/*#__PURE__*/ ET.getOrElse(T.Monad);\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = getOrElse;\n/**\n * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { left, right } from 'fp-ts/Either'\n * import { tryCatch } from 'fp-ts/TaskEither'\n *\n * tryCatch(() => Promise.resolve(1), String)().then(result => {\n *   assert.deepStrictEqual(result, right(1))\n * })\n * tryCatch(() => Promise.reject('error'), String)().then(result => {\n *   assert.deepStrictEqual(result, left('error'))\n * })\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onRejected) {\n    return function () { return __awaiter(void 0, void 0, void 0, function () {\n        var reason_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, f().then(_.right)];\n                case 1: return [2 /*return*/, _a.sent()];\n                case 2:\n                    reason_1 = _a.sent();\n                    return [2 /*return*/, _.left(onRejected(reason_1))];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n};\n/**\n * Converts a function returning a `Promise` to one returning a `TaskEither`.\n *\n * @category interop\n * @since 2.5.0\n */\nexport var tryCatchK = function (f, onRejected) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onRejected);\n    };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ ET.toUnion(T.Functor);\n/**\n * @category conversions\n * @since 2.12.0\n */\nexport var fromNullable = /*#__PURE__*/ ET.fromNullable(T.Pointed);\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var fromNullableK = /*#__PURE__*/ ET.fromNullableK(T.Pointed);\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainNullableK = \n/*#__PURE__*/ ET.chainNullableK(T.Monad);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Returns `ma` if is a `Right` or the value returned by `onLeft` otherwise.\n *\n * See also [alt](#alt).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   const errorHandler = TE.orElse((error: string) => TE.right(`recovering from ${error}...`))\n *   assert.deepStrictEqual(await pipe(TE.right('ok'), errorHandler)(), E.right('ok'))\n *   assert.deepStrictEqual(await pipe(TE.left('ko'), errorHandler)(), E.right('recovering from ko...'))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = \n/*#__PURE__*/ ET.orElse(T.Monad);\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = orElse;\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @category error handling\n * @since 2.15.0\n */\nexport var tapError = /*#__PURE__*/ dual(2, ET.tapError(T.Monad));\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstIOK = function (onLeft) { return tapError(fromIOK(onLeft)); };\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstTaskK = function (onLeft) { return tapError(fromTaskK(onLeft)); };\n/**\n * @category error handling\n * @since 2.11.0\n */\nexport var orLeft = \n/*#__PURE__*/ ET.orLeft(T.Monad);\n/**\n * @since 2.0.0\n */\nexport var swap = /*#__PURE__*/ ET.swap(T.Functor);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromTaskOptionK = function (onNone) {\n    var from = fromTaskOption(onNone);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.3\n */\nexport var chainTaskOptionKW = function (onNone) {\n    return function (f) {\n        return function (ma) {\n            return flatMap(ma, fromTaskOptionK(onNone)(f));\n        };\n    };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainTaskOptionK = chainTaskOptionKW;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOEitherK = function (f) { return flow(f, fromIOEither); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = /*#__PURE__*/ ET.map(T.Functor);\n/**\n * Returns a `TaskEither` whose failure and success channels have been mapped by the specified pair of functions, `f` and `g`.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n * const g = (n: number) => n * 2\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.right(1), f, g)(), Either.right(2))\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.left('err'), f, g)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapBoth = /*#__PURE__*/ dual(3, ET.mapBoth(T.Functor));\n/**\n * Alias of `mapBoth`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var bimap = mapBoth;\n/**\n * Returns a `TaskEither` with its error channel mapped using the specified function.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.right(1), f)(), Either.right(1))\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.left('err'), f)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapError = /*#__PURE__*/ dual(2, ET.mapError(T.Functor));\n/**\n * Alias of `mapError`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var mapLeft = mapError;\n/**\n * @since 2.0.0\n */\nexport var ap = \n/*#__PURE__*/ ET.ap(T.ApplyPar);\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = ap;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, ET.flatMap(T.Monad));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `TaskEither` returns `fa` if is a `Right` or the value returned by `that` otherwise.\n *\n * See also [orElse](#orelse).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.right(1),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(1)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(2)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.left('b'))\n *     )(),\n *     E.left('b')\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = \n/*#__PURE__*/ ET.alt(T.Monad);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = alt;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = right;\n/**\n * @since 2.7.0\n */\nexport var throwError = left;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'TaskEither';\n/**\n * The default [`ApplicativePar`](#applicativepar) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n * import * as T from 'fp-ts/Task'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * interface User {\n *   readonly id: string\n *   readonly name: string\n * }\n *\n * const remoteDatabase: ReadonlyArray<User> = [\n *   { id: 'id1', name: 'John' },\n *   { id: 'id2', name: 'Mary' },\n *   { id: 'id3', name: 'Joey' }\n * ]\n *\n * const fetchUser = (id: string): TE.TaskEither<string, User> =>\n *   pipe(\n *     remoteDatabase,\n *     RA.findFirst((user) => user.id === id),\n *     TE.fromOption(() => `${id} not found`)\n *   )\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(TE.ApplicativePar)(fetchUser))(),\n *     E.left('id4 not found') // <= first error\n *   )\n *\n *   const Applicative = TE.getApplicativeTaskValidation(\n *     T.ApplyPar,\n *     pipe(string.Semigroup, S.intercalate(', '))\n *   )\n *\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(Applicative)(fetchUser))(),\n *     E.left('id4 not found, id5 not found') // <= all errors\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getApplicativeTaskValidation(A, S) {\n    var ap = ap_(A, E.getApplicativeValidation(S));\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return pipe(fab, ap(fa)); },\n        of: of\n    };\n}\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * See [`getAltValidation`](./Either.ts.html#getaltvalidation).\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getAltTaskValidation(S) {\n    var alt = ET.altValidation(T.Monad, S);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        alt: function (fa, that) { return pipe(fa, alt(that)); }\n    };\n}\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var C = E.getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: compact_(T.Functor, C),\n        separate: separate_(T.Functor, C, E.Functor)\n    };\n};\n/**\n * @category filtering\n * @since 2.1.0\n */\nexport function getFilterable(M) {\n    var F = E.getFilterable(M);\n    var C = getCompactable(M);\n    var filter = filter_(T.Functor, F);\n    var filterMap = filterMap_(T.Functor, F);\n    var partition = partition_(T.Functor, F);\n    var partitionMap = partitionMap_(T.Functor, F);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: C.compact,\n        separate: C.separate,\n        filter: function (fa, predicate) { return pipe(fa, filter(predicate)); },\n        filterMap: function (fa, f) { return pipe(fa, filterMap(f)); },\n        partition: function (fa, predicate) { return pipe(fa, partition(predicate)); },\n        partitionMap: function (fa, f) { return pipe(fa, partitionMap(f)); }\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `TaskEither` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `TaskEither` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Less strict version of [`apFirst`](#apfirst).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Less strict version of [`apSecond`](#apsecond).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * const checkString = (value: string) => pipe(\n *   TE.of(value),\n *   TE.tapEither(() => value.length > 0 ? E.right('ok') : E.left('error'))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await checkString('')(), E.left('error'))\n *   assert.deepStrictEqual(await checkString('fp-ts')(), E.right('fp-ts'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n * import * as E from 'fp-ts/Either'\n * import * as Console from 'fp-ts/Console'\n *\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effectA = TE.tapIO(\n *   TE.of(1),\n *   (value) => Console.log(`Hello, ${value}`)\n * )\n *\n * // No output to the stdout\n * const effectB = pipe(\n *   TE.left('error'),\n *   TE.tapIO((value) => Console.log(`Hello, ${value}`))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effectA(), E.of(1))\n *   assert.deepStrictEqual(await effectB(), E.left('error'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as TE from 'fp-ts/TaskEither'\n * import * as T from 'fp-ts/Task'\n * import * as E from 'fp-ts/Either'\n *\n *\n * const effect = TE.tapIO(\n *   TE.of(1),\n *   (value) => T.of(value + 1)\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), E.of(1))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapTask = /*#__PURE__*/ dual(2, tapTask_(FromTask, Chain));\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/** @internal */\nvar _FromTask = {\n    fromTask: fromTask\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapEither = /*#__PURE__*/ _.flatMapEither(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapIO = /*#__PURE__*/ _.flatMapIO(_FromIO, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTask = /*#__PURE__*/ _.flatMapTask(_FromTask, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIOEither = /*#__PURE__*/ dual(2, function (self, f) {\n    return flatMap(self, fromIOEitherK(f));\n});\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTaskOption = /*#__PURE__*/ dual(3, function (self, f, onNone) {\n    return flatMap(self, function (a) { return fromTaskOption(function () { return onNone(a); })(f(a)); });\n});\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainEitherK = flatMapEither;\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainEitherKW = flatMapEither;\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Alias of `tapEither`.\n *\n * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherKW = tapEither;\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromIOK = /*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromTaskK = /*#__PURE__*/ fromTaskK_(FromTask);\n/**\n * Alias of `flatMapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainTaskK = flatMapTask;\n/**\n * Alias of `tapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstTaskK = tapTask;\n/**\n * Alias of `flatMapIOEither`.\n *\n * Less strict version of [`chainIOEitherK`](#chainioeitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainIOEitherKW = flatMapIOEither;\n/**\n * Alias of `flatMapIOEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOEitherK = flatMapIOEither;\nexport function taskify(f) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        return function () {\n            return new Promise(function (resolve) {\n                var cbResolver = function (e, r) { return (e != null ? resolve(_.left(e)) : resolve(_.right(r))); };\n                f.apply(null, args.concat(cbResolver));\n            });\n        };\n    };\n}\n/**\n * Make sure that a resource is cleaned up in the event of an exception (\\*). The release action is called regardless of\n * whether the body action throws (\\*) or returns.\n *\n * (\\*) i.e. returns a `Left`\n *\n * @since 2.0.0\n */\nexport var bracket = function (acquire, use, release) { return bracketW(acquire, use, release); };\n/**\n * Less strict version of [`bracket`](#bracket).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var bracketW = function (acquire, use, release) {\n    return flatMap(acquire, function (a) { return T.flatMap(use(a), function (e) { return flatMap(release(a, e), function () { return T.of(e); }); }); });\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return flow(T.traverseReadonlyNonEmptyArrayWithIndex(f), T.map(E.traverseReadonlyNonEmptyArrayWithIndex(SK)));\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (ebs) {\n                    return _.isLeft(ebs)\n                        ? acc\n                        : f(i + 1, a)().then(function (eb) {\n                            if (_.isLeft(eb)) {\n                                return eb;\n                            }\n                            ebs.right.push(eb.right);\n                            return ebs;\n                        });\n                });\n            }, f(0, _.head(as))().then(E.map(_.singleton)));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) { return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirst = tapError;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirstW = tapError;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEither`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEither = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEitherSeq`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEitherSeq = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = function (S) {\n    return getApplySemigroup_(T.ApplySeq)(E.getSemigroup(S));\n};\n/**\n * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getTaskValidation(SE) {\n    var applicativeTaskValidation = getApplicativeTaskValidation(T.ApplicativePar, SE);\n    var altTaskValidation = getAltTaskValidation(SE);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: applicativeTaskValidation.ap,\n        of: of,\n        chain: flatMap,\n        bimap: mapBoth,\n        mapLeft: mapError,\n        alt: altTaskValidation.alt,\n        fromIO: fromIO,\n        fromTask: fromTask,\n        throwError: throwError\n    };\n}\n","import * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\nimport {\n  BetterPromise,\n  type BetterPromiseExecutorContext,\n  type BetterPromiseOptions,\n  type TimeoutError,\n} from 'better-promises';\n\nimport type { AnyFn } from '@/types/misc.js';\n\nexport type AnyEither<L = any, R = any> = E.Either<L, R> | TE.TaskEither<L, R>;\nexport type AnyFnAnyEither<L = any, R = any> = (...args: any) => AnyEither<L, R>;\n\nexport type RightOfEither<T extends AnyEither> = [T] extends [E.Either<any, infer U>]\n  ? U\n  : T extends TE.TaskEither<any, infer U>\n    ? U\n    : never;\nexport type LeftOfEither<T extends AnyEither> = [T] extends [E.Either<infer U, any>]\n  ? U\n  : T extends TE.TaskEither<infer U, any>\n    ? U\n    : never;\nexport type RightOfReturn<F extends AnyFnAnyEither> = RightOfEither<ReturnType<F>>;\nexport type LeftOfReturn<F extends AnyFnAnyEither> = LeftOfEither<ReturnType<F>>;\n\nexport type MaybeMonadToCommon<T> = [T] extends [E.Either<any, infer U>]\n  ? U\n  : T extends TE.TaskEither<any, infer U>\n    ? BetterPromise<U>\n    : T;\n\nexport type MaybeMonadReturnTypeToCommon<Fn extends AnyFn> = MaybeMonadToCommon<ReturnType<Fn>>;\n\nexport function throwifyAnyEither<E extends AnyEither>(either: E): MaybeMonadToCommon<E> {\n  const onError = (e: unknown) => {\n    throw e;\n  };\n  return (\n    typeof either === 'function'\n      ? BetterPromise.resolve(pipe(either, TE.match(onError, data => data))())\n      : pipe(either, E.match(onError, data => data))\n  ) as MaybeMonadToCommon<E>;\n}\n\nexport function throwifyFpFn<Fn extends AnyFnAnyEither>(\n  fn: Fn,\n): (\n  & ((...args: Parameters<Fn>) => MaybeMonadReturnTypeToCommon<Fn>)\n  & { [K in keyof Fn]: Fn[K] }\n) {\n  return Object.assign(\n    (...args: Parameters<Fn>) => {\n      return throwifyAnyEither(fn(...args)) as MaybeMonadReturnTypeToCommon<Fn>;\n    },\n    fn,\n  );\n}\n\nexport type BetterTaskEitherError = TimeoutError;\n\nexport const BetterTaskEither = Object.assign(\n  <E, T>(\n    executor: (\n      resolve: (data: T) => void,\n      reject: (reason: E) => void,\n      context: BetterPromiseExecutorContext<E.Either<E | BetterTaskEitherError, T>>,\n    ) => (void | Promise<void>),\n    options?: BetterPromiseOptions,\n  ): TE.TaskEither<E | BetterTaskEitherError, T> => {\n    return pipe(\n      TE.tryCatch(\n        () => {\n          return new BetterPromise<E.Either<E, T>>((res, _rej, context) => {\n            return executor(\n              result => res(E.right(result)),\n              error => res(E.left(error)),\n              context,\n            );\n          }, options);\n        },\n        e => e as E,\n      ),\n      TE.chainW(E.match(TE.left, TE.right<E, T>)),\n    );\n  },\n  {\n    fn: <E, T>(\n      fn: (context: BetterPromiseExecutorContext<E.Either<E | BetterTaskEitherError, T>>) => (\n        E.Either<E, T> | TE.TaskEither<E, T>\n      ),\n      options?: BetterPromiseOptions,\n    ): TE.TaskEither<E | BetterTaskEitherError, T> => {\n      return BetterTaskEither<E, T>((resolve, reject, context) => {\n        const result = fn(context);\n        void pipe(\n          typeof result === 'function' ? result : TE.fromEither(result),\n          TE.matchW(reject, resolve),\n        )();\n      }, options);\n    },\n  },\n);\n","export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n","import { looseObject, function as fn, is } from 'valibot';\n\n/**\n * Returns true in case, passed value contains path `TelegramWebviewProxy.postEvent` property and\n * `postEvent` is a function.\n * @param value - value to check.\n */\nexport function hasWebviewProxy<T>(value: T): value is T & {\n  TelegramWebviewProxy: {\n    postEvent: (...args: unknown[]) => unknown;\n  };\n} {\n  return is(\n    looseObject({ TelegramWebviewProxy: looseObject({ postEvent: fn() }) }),\n    value,\n  );\n}\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n","/**\n * @see https://stackoverflow.com/a/326076\n * @returns True, if current environment is iframe.\n */\nexport function isIframe(): boolean {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return true;\n  }\n}\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n","/**\n * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.\n *\n * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor\n * `f`.\n *\n * Instances must satisfy the following law in addition to the `Functor` laws:\n *\n * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`\n *\n * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)\n * const fa: O.Option<string> = O.some('s')\n * const fb: O.Option<number> = O.some(1)\n * const fc: O.Option<boolean> = O.some(true)\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     // lift a function\n *     O.some(f),\n *     // apply the first argument\n *     O.ap(fa),\n *     // apply the second argument\n *     O.ap(fb),\n *     // apply the third argument\n *     O.ap(fc)\n *   ),\n *   O.some('s1true')\n * )\n *\n * @since 2.0.0\n */\nimport { tuple } from './function';\nimport * as _ from './internal';\nexport function ap(F, G) {\n    return function (fa) {\n        return function (fab) {\n            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);\n        };\n    };\n}\nexport function apFirst(A) {\n    return function (second) { return function (first) {\n        return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);\n    }; };\n}\nexport function apSecond(A) {\n    return function (second) {\n        return function (first) {\n            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);\n        };\n    };\n}\nexport function apS(F) {\n    return function (name, fb) {\n        return function (fa) {\n            return F.ap(F.map(fa, function (a) { return function (b) {\n                var _a;\n                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n            }; }), fb);\n        };\n    };\n}\nexport function getApplySemigroup(F) {\n    return function (S) { return ({\n        concat: function (first, second) {\n            return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);\n        }\n    }); };\n}\nfunction curried(f, n, acc) {\n    return function (x) {\n        var combined = Array(acc.length + 1);\n        for (var i = 0; i < acc.length; i++) {\n            combined[i] = acc[i];\n        }\n        combined[acc.length] = x;\n        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);\n    };\n}\nvar tupleConstructors = {\n    1: function (a) { return [a]; },\n    2: function (a) { return function (b) { return [a, b]; }; },\n    3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },\n    4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },\n    5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }\n};\nfunction getTupleConstructor(len) {\n    if (!_.has.call(tupleConstructors, len)) {\n        tupleConstructors[len] = curried(tuple, len - 1, []);\n    }\n    return tupleConstructors[len];\n}\nexport function sequenceT(F) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var len = args.length;\n        var f = getTupleConstructor(len);\n        var fas = F.map(args[0], f);\n        for (var i = 1; i < len; i++) {\n            fas = F.ap(fas, args[i]);\n        }\n        return fas;\n    };\n}\nfunction getRecordConstructor(keys) {\n    var len = keys.length;\n    switch (len) {\n        case 1:\n            return function (a) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a);\n            };\n        case 2:\n            return function (a) { return function (b) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);\n            }; };\n        case 3:\n            return function (a) { return function (b) { return function (c) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);\n            }; }; };\n        case 4:\n            return function (a) { return function (b) { return function (c) { return function (d) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a);\n            }; }; }; };\n        case 5:\n            return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a[keys[4]] = e,\n                    _a);\n            }; }; }; }; };\n        default:\n            return curried(function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var r = {};\n                for (var i = 0; i < len; i++) {\n                    r[keys[i]] = args[i];\n                }\n                return r;\n            }, len - 1, []);\n    }\n}\nexport function sequenceS(F) {\n    return function (r) {\n        var keys = Object.keys(r);\n        var len = keys.length;\n        var f = getRecordConstructor(keys);\n        var fr = F.map(r[keys[0]], f);\n        for (var i = 1; i < len; i++) {\n            fr = F.ap(fr, r[keys[i]]);\n        }\n        return fr;\n    };\n}\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n","/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nimport { pipe } from './function';\nexport function map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexport function flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexport function bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\nexport { \n/**\n * @since 2.13.0\n */\nlet_ as let };\n/** @deprecated */\nexport function getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return pipe(fga, _map(f)); }\n    };\n}\n/** @internal */\nexport function as(F) {\n    return function (self, b) { return F.map(self, function () { return b; }); };\n}\n/** @internal */\nexport function asUnit(F) {\n    var asM = as(F);\n    return function (self) { return asM(self, undefined); };\n}\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    try {\n        return e instanceof Error ? e : new Error(String(e));\n    }\n    catch (error) {\n        return new Error();\n    }\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n","export function chainFirst(M) {\n    var tapM = tap(M);\n    return function (f) { return function (first) { return tapM(first, f); }; };\n}\n/** @internal */\nexport function tap(M) {\n    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };\n}\nexport function bind(M) {\n    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n    }); }); }; };\n}\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    try {\n        return e instanceof Error ? e : new Error(String(e));\n    }\n    catch (error) {\n        return new Error();\n    }\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_, tapEither as tapEither_ } from './FromEither';\nimport { constNull, constUndefined, dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { not } from './Predicate';\nimport { first, last } from './Semigroup';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = _.none;\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = _.some;\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getLeft = function (ma) { return (ma._tag === 'Right' ? none : some(ma.left)); };\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getRight = function (ma) { return (ma._tag === 'Left' ? none : some(ma.right)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (S) { return ({\n    show: function (ma) { return (isNone(ma) ? 'none' : \"some(\".concat(S.show(ma.value), \")\")); }\n}); };\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (E) { return ({\n    equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n}); };\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = function (O) { return ({\n    equals: getEq(O).equals,\n    compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : isSome(y) ? -1 : 0); }\n}); };\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(b) | some(b)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function (S) { return ({\n    concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n    empty: none\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Some` value of this `Option` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isNone(ma) ? none : f(ma.value)); });\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n}; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isNone(fa) ? M.empty : f(fa.value);\n}; }; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"fp-ts/Option\"\n *\n * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))\n * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var orElse = dual(2, function (self, that) { return (isNone(self) ? that() : self); });\n/**\n * Alias of `orElse`.\n *\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var altW = orElse;\n/**\n * Alias of `orElse`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var alt = orElse;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ flatMap(identity);\nvar defaultSeparated = /*#__PURE__*/ separated(none, none);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    return isNone(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (fa) {\n        return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n}; };\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return function (fa) {\n        return separated(_filter(fa, not(predicate)), _filter(fa, predicate));\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return flow(map(f), separate); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n        };\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getright)\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isSome = _.isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onNone, onSome) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : onSome(ma.value);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : ma.value;\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = compact;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   O.of(value),\n *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * assert.deepStrictEqual(compute(1), O.of(1))\n * assert.deepStrictEqual(compute(-42), O.none)\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainEitherK = \n/*#__PURE__*/ chainEitherK_(FromEither, Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (a) { return (a == null ? none : some(a)); };\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); });\n    };\n};\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category lifting\n * @since 2.9.0\n */\nexport var fromNullableK = function (f) { return flow(f, fromNullable); };\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   readonly company?: {\n *     readonly address?: {\n *       readonly street?: {\n *         readonly name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category sequencing\n * @since 2.9.0\n */\nexport var chainNullableK = function (f) {\n    return function (ma) {\n        return isNone(ma) ? none : fromNullable(f(ma.value));\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toNullable = /*#__PURE__*/ match(constNull, identity);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toUndefined = /*#__PURE__*/ match(constUndefined, identity);\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isNone(ma) ? false : E.equals(a, ma.value);\n    };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isNone(ma) ? false : predicate(ma.value);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var o = f(0, _.head(as));\n        if (isNone(o)) {\n            return none;\n        }\n        var out = [o.value];\n        for (var i = 1; i < as.length; i++) {\n            var o_1 = f(i, as[i]);\n            if (isNone(o_1)) {\n                return none;\n            }\n            out.push(o_1.value);\n        }\n        return some(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n/**\n * Use [`chainNullableK`](#chainnullablek) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`\n * (where `O` is from `import O from 'fp-ts/Option'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var option = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    zero: zero,\n    alt: _alt,\n    extend: _extend,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = /*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = /*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use\n *\n * ```ts\n * import { first } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(first())\n * ```\n *\n * instead.\n *\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstMonoid = function () { return getMonoid(first()); };\n/**\n * Use\n *\n * ```ts\n * import { last } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(last())\n * ```\n *\n * instead.\n *\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastMonoid = function () { return getMonoid(last()); };\n","import { ap as ap_ } from './Apply';\nimport * as E from './Either';\nimport { flow, pipe } from './function';\nimport { map as map_ } from './Functor';\nexport function right(F) {\n    return flow(E.right, F.of);\n}\nexport function left(F) {\n    return flow(E.left, F.of);\n}\nexport function rightF(F) {\n    return function (fa) { return F.map(fa, E.right); };\n}\nexport function leftF(F) {\n    return function (fe) { return F.map(fe, E.left); };\n}\nexport function fromNullable(F) {\n    return function (e) { return flow(E.fromNullable(e), F.of); };\n}\nexport function fromNullableK(F) {\n    var fromNullableF = fromNullable(F);\n    return function (e) {\n        var fromNullableFE = fromNullableF(e);\n        return function (f) { return flow(f, fromNullableFE); };\n    };\n}\nexport function chainNullableK(M) {\n    var chainM = chain(M);\n    var fromNullableKM = fromNullableK(M);\n    return function (e) {\n        var fromNullableKMe = fromNullableKM(e);\n        return function (f) { return chainM(fromNullableKMe(f)); };\n    };\n}\nexport function map(F) {\n    return map_(F, E.Functor);\n}\nexport function ap(F) {\n    return ap_(F, E.Apply);\n}\nexport function chain(M) {\n    var flatMapM = flatMap(M);\n    return function (f) { return function (ma) { return flatMapM(ma, f); }; };\n}\n/** @internal */\nexport function flatMap(M) {\n    return function (ma, f) { return M.chain(ma, function (e) { return (E.isLeft(e) ? M.of(e) : f(e.right)); }); };\n}\nexport function alt(M) {\n    return function (second) { return function (first) { return M.chain(first, function (e) { return (E.isLeft(e) ? second() : M.of(e)); }); }; };\n}\nexport function bimap(F) {\n    var mapBothF = mapBoth(F);\n    return function (f, g) { return function (self) { return mapBothF(self, f, g); }; };\n}\n/** @internal */\nexport function mapBoth(F) {\n    return function (self, f, g) { return F.map(self, E.bimap(f, g)); };\n}\nexport function mapLeft(F) {\n    var mapErrorF = mapError(F);\n    return function (f) { return function (self) { return mapErrorF(self, f); }; };\n}\n/** @internal */\nexport function mapError(F) {\n    return function (self, f) { return F.map(self, E.mapLeft(f)); };\n}\nexport function altValidation(M, S) {\n    return function (second) { return function (first) {\n        return M.chain(first, E.match(function (e1) {\n            return M.map(second(), E.mapLeft(function (e2) { return S.concat(e1, e2); }));\n        }, right(M)));\n    }; };\n}\nexport function match(F) {\n    return function (onLeft, onRight) { return function (ma) { return F.map(ma, E.match(onLeft, onRight)); }; };\n}\nexport function matchE(M) {\n    return function (onLeft, onRight) { return function (ma) { return M.chain(ma, E.match(onLeft, onRight)); }; };\n}\nexport function getOrElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, E.match(onLeft, M.of)); }; };\n}\nexport function orElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, function (e) { return (E.isLeft(e) ? onLeft(e.left) : M.of(e)); }); }; };\n}\nexport function orElseFirst(M) {\n    var tapErrorM = tapError(M);\n    return function (onLeft) { return function (ma) { return tapErrorM(ma, onLeft); }; };\n}\n/** @internal */\nexport function tapError(M) {\n    var orElseM = orElse(M);\n    return function (ma, onLeft) {\n        return pipe(ma, orElseM(function (e) { return M.map(onLeft(e), function (eb) { return (E.isLeft(eb) ? eb : E.left(e)); }); }));\n    };\n}\nexport function orLeft(M) {\n    return function (onLeft) { return function (ma) {\n        return M.chain(ma, E.match(function (e) { return M.map(onLeft(e), E.left); }, function (a) { return M.of(E.right(a)); }));\n    }; };\n}\nexport function swap(F) {\n    return function (ma) { return F.map(ma, E.swap); };\n}\nexport function toUnion(F) {\n    return function (fa) { return F.map(fa, E.toUnion); };\n}\n/** @deprecated  */\n/* istanbul ignore next */\nexport function getEitherM(M) {\n    var _ap = ap(M);\n    var _map = map(M);\n    var _chain = chain(M);\n    var _alt = alt(M);\n    var _bimap = bimap(M);\n    var _mapLeft = mapLeft(M);\n    var _fold = matchE(M);\n    var _getOrElse = getOrElse(M);\n    var _orElse = orElse(M);\n    return {\n        map: function (fa, f) { return pipe(fa, _map(f)); },\n        ap: function (fab, fa) { return pipe(fab, _ap(fa)); },\n        of: right(M),\n        chain: function (ma, f) { return pipe(ma, _chain(f)); },\n        alt: function (fa, that) { return pipe(fa, _alt(that)); },\n        bimap: function (fea, f, g) { return pipe(fea, _bimap(f, g)); },\n        mapLeft: function (fea, f) { return pipe(fea, _mapLeft(f)); },\n        fold: function (fa, onLeft, onRight) { return pipe(fa, _fold(onLeft, onRight)); },\n        getOrElse: function (fa, onLeft) { return pipe(fa, _getOrElse(onLeft)); },\n        orElse: function (fa, f) { return pipe(fa, _orElse(f)); },\n        swap: swap(M),\n        rightM: rightF(M),\n        leftM: leftF(M),\n        left: left(M)\n    };\n}\n","/**\n * ```ts\n * interface Task<A> {\n *   (): Promise<A>\n * }\n * ```\n *\n * `Task<A>` represents an asynchronous computation that yields a value of type `A` and **never fails**.\n * If you want to represent an asynchronous computation that may fail, please see `TaskEither`.\n *\n * @since 2.0.0\n */\nimport { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { dual, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIO = function (ma) { return function () { return Promise.resolve().then(ma); }; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as T from 'fp-ts/Task'\n * import { takeRight } from 'fp-ts/Array'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = T.delay(20)(append('b'))\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])\n * }\n *\n * test()\n *\n * @since 2.0.0\n */\nexport function delay(millis) {\n    return function (ma) { return function () {\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                Promise.resolve().then(ma).then(resolve);\n            }, millis);\n        });\n    }; };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return function () {\n    return Promise.resolve().then(fa).then(f);\n}; }; };\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) { return function () {\n    return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function (_a) {\n        var f = _a[0], a = _a[1];\n        return f(a);\n    });\n}; }; };\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return function () { return Promise.resolve(a); }; };\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return function () {\n        return Promise.resolve()\n            .then(ma)\n            .then(function (a) { return f(a)(); });\n    };\n});\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Task';\n/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getRaceMonoid() {\n    return {\n        concat: function (x, y) { return function () { return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]); }; },\n        empty: never\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the value to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the value to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO\n};\n/**\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var fromTask = identity;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIO = _.flatMapIO(_FromIO, _FlatMap);\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as T from 'fp-ts/Task'\n * import * as Console from 'fp-ts/Console'\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effect = pipe(\n *   T.of('fp-ts'),\n *   T.tapIO((value) => Console.log(`Hello, ${value}`)),\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), 'fp-ts')\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOK = \n/*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * A `Task` that never completes.\n *\n * @since 2.0.0\n */\nexport var never = function () { return new Promise(function (_) { return undefined; }); };\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        return function () {\n            return Promise.all(as.map(function (a, i) { return Promise.resolve().then(function () { return f(i, a)(); }); }));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (bs) {\n                    return Promise.resolve()\n                        .then(f(i + 1, a))\n                        .then(function (b) {\n                        bs.push(b);\n                        return bs;\n                    });\n                });\n            }, Promise.resolve()\n                .then(f(0, _.head(as)))\n                .then(_.singleton));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) {\n    return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.task`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var task = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.taskSeq`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskSeq = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = /*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMonoid = /*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n","import type { MaybeAccessor } from '@/types.js';\n\nexport function access<T>(value: MaybeAccessor<T>): T {\n  return typeof value === 'function' ? (value as any)() as T : value;\n}\n","import { batch, computed, signal } from '@tma.js/signals';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport interface MountableOptions<S, Err> {\n  /**\n   * A state to use if the `restoreState` function returned falsy value or\n   * `isPageReload` returned false.\n   */\n  initialState: S | (() => E.Either<Err, S>);\n  /**\n   * @returns True if the current page was reloaded.\n   */\n  isPageReload: MaybeAccessor<boolean>;\n  /**\n   * A function to call whenever the component was mounted.\n   * @param state - restored state.\n   */\n  onMounted?: (state: S) => void;\n  /**\n   * A function to call whenever the component was unmounted.\n   */\n  onUnmounted?: VoidFunction;\n  /**\n   * Attempts to restore previously saved component state. This function\n   * will only be called if the current page was reloaded.\n   */\n  restoreState: () => (S | undefined);\n}\n\nexport class Mountable<S extends object, Err = never> {\n  constructor({\n    onMounted,\n    restoreState,\n    initialState,\n    onUnmounted,\n    isPageReload,\n  }: MountableOptions<S, Err>) {\n    this.mount = () => {\n      if (this.isMounted()) {\n        return E.right(undefined);\n      }\n      const restored = access(isPageReload) ? restoreState() : undefined;\n      const state = restored\n        ? E.right(restored)\n        : (typeof initialState === 'function' ? initialState() : E.right(initialState));\n\n      return pipe(state, E.map(s => {\n        batch(() => {\n          this._isMounted.set(true);\n          onMounted?.(s);\n        });\n      }));\n    };\n\n    this.unmount = () => {\n      if (this._isMounted()) {\n        batch(() => {\n          this._isMounted.set(false);\n          onUnmounted?.();\n        });\n      }\n    };\n  }\n\n  private readonly _isMounted = signal(false);\n\n  /**\n   * Signal indicating if the component is mounted.\n   */\n  readonly isMounted = computed(this._isMounted);\n\n  /**\n   * Mounts the component restoring its state and calling required side effects.\n   */\n  readonly mount: () => E.Either<Err, void>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { getApplicativeMonoid } from './Applicative';\nimport { ap as ap_, apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { compact as compact_, separate as separate_ } from './Compactable';\nimport * as E from './Either';\nimport * as ET from './EitherT';\nimport { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, tapEither as tapEither_ } from './FromEither';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { fromTaskK as fromTaskK_, tapTask as tapTask_ } from './FromTask';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as T from './Task';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var left = /*#__PURE__*/ ET.left(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var right = /*#__PURE__*/ ET.right(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightTask = /*#__PURE__*/ ET.rightF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftTask = /*#__PURE__*/ ET.leftF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightIO = /*#__PURE__*/ flow(T.fromIO, rightTask);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftIO = /*#__PURE__*/ flow(T.fromIO, leftTask);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromIO = rightIO;\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromTask = rightTask;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = T.of;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIOEither = T.fromIO;\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromTaskOption = function (onNone) {\n    return T.map(E.fromOption(onNone));\n};\n/**\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = \n/*#__PURE__*/ ET.match(T.Functor);\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = match;\n/**\n * The `E` suffix (short for **E**ffect) means that the handlers return an effect (`Task`).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchE = /*#__PURE__*/ ET.matchE(T.Monad);\n/**\n * Alias of [`matchE`](#matche).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = matchE;\n/**\n * Less strict version of [`matchE`](#matche).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchEW = matchE;\n/**\n * Alias of [`matchEW`](#matchew).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchEW;\n/**\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = \n/*#__PURE__*/ ET.getOrElse(T.Monad);\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = getOrElse;\n/**\n * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { left, right } from 'fp-ts/Either'\n * import { tryCatch } from 'fp-ts/TaskEither'\n *\n * tryCatch(() => Promise.resolve(1), String)().then(result => {\n *   assert.deepStrictEqual(result, right(1))\n * })\n * tryCatch(() => Promise.reject('error'), String)().then(result => {\n *   assert.deepStrictEqual(result, left('error'))\n * })\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onRejected) {\n    return function () { return __awaiter(void 0, void 0, void 0, function () {\n        var reason_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, f().then(_.right)];\n                case 1: return [2 /*return*/, _a.sent()];\n                case 2:\n                    reason_1 = _a.sent();\n                    return [2 /*return*/, _.left(onRejected(reason_1))];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n};\n/**\n * Converts a function returning a `Promise` to one returning a `TaskEither`.\n *\n * @category interop\n * @since 2.5.0\n */\nexport var tryCatchK = function (f, onRejected) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onRejected);\n    };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ ET.toUnion(T.Functor);\n/**\n * @category conversions\n * @since 2.12.0\n */\nexport var fromNullable = /*#__PURE__*/ ET.fromNullable(T.Pointed);\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var fromNullableK = /*#__PURE__*/ ET.fromNullableK(T.Pointed);\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainNullableK = \n/*#__PURE__*/ ET.chainNullableK(T.Monad);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Returns `ma` if is a `Right` or the value returned by `onLeft` otherwise.\n *\n * See also [alt](#alt).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   const errorHandler = TE.orElse((error: string) => TE.right(`recovering from ${error}...`))\n *   assert.deepStrictEqual(await pipe(TE.right('ok'), errorHandler)(), E.right('ok'))\n *   assert.deepStrictEqual(await pipe(TE.left('ko'), errorHandler)(), E.right('recovering from ko...'))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = \n/*#__PURE__*/ ET.orElse(T.Monad);\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = orElse;\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @category error handling\n * @since 2.15.0\n */\nexport var tapError = /*#__PURE__*/ dual(2, ET.tapError(T.Monad));\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstIOK = function (onLeft) { return tapError(fromIOK(onLeft)); };\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstTaskK = function (onLeft) { return tapError(fromTaskK(onLeft)); };\n/**\n * @category error handling\n * @since 2.11.0\n */\nexport var orLeft = \n/*#__PURE__*/ ET.orLeft(T.Monad);\n/**\n * @since 2.0.0\n */\nexport var swap = /*#__PURE__*/ ET.swap(T.Functor);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromTaskOptionK = function (onNone) {\n    var from = fromTaskOption(onNone);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.3\n */\nexport var chainTaskOptionKW = function (onNone) {\n    return function (f) {\n        return function (ma) {\n            return flatMap(ma, fromTaskOptionK(onNone)(f));\n        };\n    };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainTaskOptionK = chainTaskOptionKW;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOEitherK = function (f) { return flow(f, fromIOEither); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = /*#__PURE__*/ ET.map(T.Functor);\n/**\n * Returns a `TaskEither` whose failure and success channels have been mapped by the specified pair of functions, `f` and `g`.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n * const g = (n: number) => n * 2\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.right(1), f, g)(), Either.right(2))\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.left('err'), f, g)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapBoth = /*#__PURE__*/ dual(3, ET.mapBoth(T.Functor));\n/**\n * Alias of `mapBoth`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var bimap = mapBoth;\n/**\n * Returns a `TaskEither` with its error channel mapped using the specified function.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.right(1), f)(), Either.right(1))\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.left('err'), f)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapError = /*#__PURE__*/ dual(2, ET.mapError(T.Functor));\n/**\n * Alias of `mapError`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var mapLeft = mapError;\n/**\n * @since 2.0.0\n */\nexport var ap = \n/*#__PURE__*/ ET.ap(T.ApplyPar);\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = ap;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, ET.flatMap(T.Monad));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `TaskEither` returns `fa` if is a `Right` or the value returned by `that` otherwise.\n *\n * See also [orElse](#orelse).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.right(1),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(1)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(2)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.left('b'))\n *     )(),\n *     E.left('b')\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = \n/*#__PURE__*/ ET.alt(T.Monad);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = alt;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = right;\n/**\n * @since 2.7.0\n */\nexport var throwError = left;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'TaskEither';\n/**\n * The default [`ApplicativePar`](#applicativepar) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n * import * as T from 'fp-ts/Task'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * interface User {\n *   readonly id: string\n *   readonly name: string\n * }\n *\n * const remoteDatabase: ReadonlyArray<User> = [\n *   { id: 'id1', name: 'John' },\n *   { id: 'id2', name: 'Mary' },\n *   { id: 'id3', name: 'Joey' }\n * ]\n *\n * const fetchUser = (id: string): TE.TaskEither<string, User> =>\n *   pipe(\n *     remoteDatabase,\n *     RA.findFirst((user) => user.id === id),\n *     TE.fromOption(() => `${id} not found`)\n *   )\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(TE.ApplicativePar)(fetchUser))(),\n *     E.left('id4 not found') // <= first error\n *   )\n *\n *   const Applicative = TE.getApplicativeTaskValidation(\n *     T.ApplyPar,\n *     pipe(string.Semigroup, S.intercalate(', '))\n *   )\n *\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(Applicative)(fetchUser))(),\n *     E.left('id4 not found, id5 not found') // <= all errors\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getApplicativeTaskValidation(A, S) {\n    var ap = ap_(A, E.getApplicativeValidation(S));\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return pipe(fab, ap(fa)); },\n        of: of\n    };\n}\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * See [`getAltValidation`](./Either.ts.html#getaltvalidation).\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getAltTaskValidation(S) {\n    var alt = ET.altValidation(T.Monad, S);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        alt: function (fa, that) { return pipe(fa, alt(that)); }\n    };\n}\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var C = E.getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: compact_(T.Functor, C),\n        separate: separate_(T.Functor, C, E.Functor)\n    };\n};\n/**\n * @category filtering\n * @since 2.1.0\n */\nexport function getFilterable(M) {\n    var F = E.getFilterable(M);\n    var C = getCompactable(M);\n    var filter = filter_(T.Functor, F);\n    var filterMap = filterMap_(T.Functor, F);\n    var partition = partition_(T.Functor, F);\n    var partitionMap = partitionMap_(T.Functor, F);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: C.compact,\n        separate: C.separate,\n        filter: function (fa, predicate) { return pipe(fa, filter(predicate)); },\n        filterMap: function (fa, f) { return pipe(fa, filterMap(f)); },\n        partition: function (fa, predicate) { return pipe(fa, partition(predicate)); },\n        partitionMap: function (fa, f) { return pipe(fa, partitionMap(f)); }\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `TaskEither` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `TaskEither` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Less strict version of [`apFirst`](#apfirst).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Less strict version of [`apSecond`](#apsecond).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * const checkString = (value: string) => pipe(\n *   TE.of(value),\n *   TE.tapEither(() => value.length > 0 ? E.right('ok') : E.left('error'))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await checkString('')(), E.left('error'))\n *   assert.deepStrictEqual(await checkString('fp-ts')(), E.right('fp-ts'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n * import * as E from 'fp-ts/Either'\n * import * as Console from 'fp-ts/Console'\n *\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effectA = TE.tapIO(\n *   TE.of(1),\n *   (value) => Console.log(`Hello, ${value}`)\n * )\n *\n * // No output to the stdout\n * const effectB = pipe(\n *   TE.left('error'),\n *   TE.tapIO((value) => Console.log(`Hello, ${value}`))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effectA(), E.of(1))\n *   assert.deepStrictEqual(await effectB(), E.left('error'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as TE from 'fp-ts/TaskEither'\n * import * as T from 'fp-ts/Task'\n * import * as E from 'fp-ts/Either'\n *\n *\n * const effect = TE.tapIO(\n *   TE.of(1),\n *   (value) => T.of(value + 1)\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), E.of(1))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapTask = /*#__PURE__*/ dual(2, tapTask_(FromTask, Chain));\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/** @internal */\nvar _FromTask = {\n    fromTask: fromTask\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapEither = /*#__PURE__*/ _.flatMapEither(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapIO = /*#__PURE__*/ _.flatMapIO(_FromIO, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTask = /*#__PURE__*/ _.flatMapTask(_FromTask, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIOEither = /*#__PURE__*/ dual(2, function (self, f) {\n    return flatMap(self, fromIOEitherK(f));\n});\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTaskOption = /*#__PURE__*/ dual(3, function (self, f, onNone) {\n    return flatMap(self, function (a) { return fromTaskOption(function () { return onNone(a); })(f(a)); });\n});\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainEitherK = flatMapEither;\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainEitherKW = flatMapEither;\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Alias of `tapEither`.\n *\n * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherKW = tapEither;\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromIOK = /*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromTaskK = /*#__PURE__*/ fromTaskK_(FromTask);\n/**\n * Alias of `flatMapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainTaskK = flatMapTask;\n/**\n * Alias of `tapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstTaskK = tapTask;\n/**\n * Alias of `flatMapIOEither`.\n *\n * Less strict version of [`chainIOEitherK`](#chainioeitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainIOEitherKW = flatMapIOEither;\n/**\n * Alias of `flatMapIOEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOEitherK = flatMapIOEither;\nexport function taskify(f) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        return function () {\n            return new Promise(function (resolve) {\n                var cbResolver = function (e, r) { return (e != null ? resolve(_.left(e)) : resolve(_.right(r))); };\n                f.apply(null, args.concat(cbResolver));\n            });\n        };\n    };\n}\n/**\n * Make sure that a resource is cleaned up in the event of an exception (\\*). The release action is called regardless of\n * whether the body action throws (\\*) or returns.\n *\n * (\\*) i.e. returns a `Left`\n *\n * @since 2.0.0\n */\nexport var bracket = function (acquire, use, release) { return bracketW(acquire, use, release); };\n/**\n * Less strict version of [`bracket`](#bracket).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var bracketW = function (acquire, use, release) {\n    return flatMap(acquire, function (a) { return T.flatMap(use(a), function (e) { return flatMap(release(a, e), function () { return T.of(e); }); }); });\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return flow(T.traverseReadonlyNonEmptyArrayWithIndex(f), T.map(E.traverseReadonlyNonEmptyArrayWithIndex(SK)));\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (ebs) {\n                    return _.isLeft(ebs)\n                        ? acc\n                        : f(i + 1, a)().then(function (eb) {\n                            if (_.isLeft(eb)) {\n                                return eb;\n                            }\n                            ebs.right.push(eb.right);\n                            return ebs;\n                        });\n                });\n            }, f(0, _.head(as))().then(E.map(_.singleton)));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) { return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirst = tapError;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirstW = tapError;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEither`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEither = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEitherSeq`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEitherSeq = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = function (S) {\n    return getApplySemigroup_(T.ApplySeq)(E.getSemigroup(S));\n};\n/**\n * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getTaskValidation(SE) {\n    var applicativeTaskValidation = getApplicativeTaskValidation(T.ApplicativePar, SE);\n    var altTaskValidation = getAltTaskValidation(SE);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: applicativeTaskValidation.ap,\n        of: of,\n        chain: flatMap,\n        bimap: mapBoth,\n        mapLeft: mapError,\n        alt: altTaskValidation.alt,\n        fromIO: fromIO,\n        fromTask: fromTask,\n        throwError: throwError\n    };\n}\n","import type { Version } from '@tma.js/types';\nimport { errorClass, errorClassWithData } from 'error-kid';\n\nexport class MethodUnsupportedError extends errorClass<\n  [method: string, version: Version]\n>('MethodUnsupportedError', (method, version) => [\n  `Method \"${method}\" is unsupported in Mini Apps version ${version}`,\n]) {\n}\n\nexport class MethodParameterUnsupportedError extends errorClass<\n  [method: string, param: string, version: Version]\n>('MethodParameterUnsupportedError', (method, param, version) => [\n  `Parameter \"${param}\" of \"${method}\" method is unsupported in Mini Apps version ${version}`,\n]) {\n}\n\nexport class LaunchParamsRetrieveError extends errorClassWithData<\n  { errors: { source: string; error: unknown }[] },\n  [{ source: string; error: unknown }[]]\n>(\n  'LaunchParamsRetrieveError',\n  errors => ({ errors }),\n  errors => [\n    [\n      'Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?',\n      ' Refer to docs for more information:',\n      'https://docs.telegram-mini-apps.com/packages/tma-js-bridge/environment',\n      '',\n      'Collected errors:',\n      ...errors.map(({ source, error }) => {\n        return `Source: ${source} / ${error instanceof Error ? error.message : String(error)}`;\n      }),\n    ].join('\\n'),\n  ],\n) {\n}\n\nexport class InvalidLaunchParamsError extends errorClass<\n  [launchParams: string, cause: unknown]\n>('InvalidLaunchParamsError', (launchParams, cause) => [\n  `Invalid value for launch params: ${launchParams}`,\n  { cause },\n]) {\n}\n\nexport class UnknownEnvError extends errorClass('UnknownEnvError') {\n}\n\nexport class InvokeCustomMethodFailedError extends errorClass<[error: string]>(\n  'InvokeCustomMethodError',\n  error => [`Server returned error: ${error}`],\n) {\n}\n","import type { UnionRequiredKeys } from '@tma.js/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}\n","export function shallowEqual<T extends object>(a: T, b: T): boolean {\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  return aKeys.length !== bKeys.length\n    ? false\n    : aKeys.every(aKey => {\n      return Object.prototype.hasOwnProperty.call(b, aKey)\n        && (a as any)[aKey] === (b as any)[aKey];\n    });\n}\n","import { type Computed, computed, type Signal, signal } from '@tma.js/signals';\n\nimport { removeUndefined } from '@/helpers/removeUndefined.js';\nimport { shallowEqual } from '@/helpers/shallowEqual.js';\n\nexport interface StatefulOptions<S> {\n  /**\n   * The initial state.\n   */\n  initialState: S;\n  /**\n   * A function to call whenever the state changes.\n   * @param state - updated state.\n   */\n  onChange: (state: S) => void;\n}\n\nexport class Stateful<S extends object> {\n  constructor({ initialState, onChange }: StatefulOptions<S>) {\n    this._state = signal(initialState, { equals: shallowEqual });\n    this.state = computed(this._state);\n    this.state.sub(onChange);\n  }\n\n  protected readonly _state: Signal<S>;\n\n  /**\n   * The current state.\n   */\n  readonly state: Computed<S>;\n\n  /**\n   * Creates a computed signal based on the state.\n   * @param key - a state key to use as a source.\n   */\n  getter<K extends keyof S>(key: K): Computed<S[K]> {\n    return computed(() => this._state()[key]);\n  }\n\n  /**\n   * Updates the state.\n   * @param state - updates to apply.\n   */\n  readonly setState = (state: Partial<S>): void => {\n    const nextState = { ...this.state(), ...removeUndefined(state) };\n    if (!shallowEqual(nextState, this.state())) {\n      this._state.set(nextState);\n    }\n  };\n\n  /**\n   * @returns True if specified payload will update the state.\n   * @param state\n   */\n  hasDiff(state: Partial<S>): boolean {\n    return !shallowEqual({ ...this.state(), ...removeUndefined(state) }, this.state());\n  }\n}\n","import { throwifyFpFn, getStorageValue, setStorageValue } from '@tma.js/toolkit';\nimport {\n  parseLaunchParamsQueryFp,\n  type LaunchParamsGenType,\n  type ParseLaunchParamsQueryError,\n} from '@tma.js/transformers';\nimport * as E from 'fp-ts/Either';\nimport * as O from 'fp-ts/Option';\nimport { flow, pipe } from 'fp-ts/function';\n\nimport { LaunchParamsRetrieveError } from '@/errors.js';\n\nconst SESSION_STORAGE_KEY = 'launchParams';\n\nexport type RetrieveRawInitDataError = RetrieveRawLaunchParamsError;\nexport type RetrieveRawLaunchParamsError = LaunchParamsRetrieveError;\nexport type RetrieveLaunchParamsError = RetrieveRawLaunchParamsError | ParseLaunchParamsQueryError;\nexport type RetrieveLaunchParamsResult = LaunchParamsGenType;\n\n/**\n * @param urlString - URL to extract launch parameters from.\n * @returns Launch parameters from the specified URL.\n * @throws Error if function was unable to extract launch parameters from the\n *   passed URL.\n */\nfunction retrieveLpFromUrl(urlString: string): string {\n  return urlString\n    // Replace everything before this first hashtag or question sign.\n    .replace(/^[^?#]*[?#]/, '')\n    // Replace all hashtags and question signs to make it look like some search\n    // params.\n    .replace(/[?#]/g, '&');\n}\n\n/**\n * @returns Launch parameters from any known source.\n */\nexport const retrieveLaunchParamsFp: () => E.Either<\n  RetrieveLaunchParamsError,\n  RetrieveLaunchParamsResult\n> = flow(retrieveRawLaunchParamsFp, E.chainW(parseLaunchParamsQueryFp));\n\n/**\n * @see retrieveLaunchParamsFp\n */\nexport const retrieveLaunchParams: () => RetrieveLaunchParamsResult =\n  throwifyFpFn(retrieveLaunchParamsFp);\n\n/**\n * @returns Raw init data from any known source.\n */\nexport const retrieveRawInitDataFp: () => E.Either<RetrieveRawInitDataError, O.Option<string>> =\n  flow(retrieveRawLaunchParamsFp, E.map(raw => {\n    const v = new URLSearchParams(raw).get('tgWebAppData');\n    return v ? O.some(v) : O.none;\n  }));\n\n/**\n * @see retrieveRawInitDataFp\n */\nexport const retrieveRawInitData: () => string | undefined = flow(\n  retrieveRawInitDataFp,\n  E.fold(err => {\n    throw err;\n  }, v => v),\n  O.match(() => undefined, v => v),\n);\n\n/**\n * @returns Launch parameters in a raw format from any known source.\n */\nexport function retrieveRawLaunchParamsFp(): E.Either<RetrieveRawLaunchParamsError, string> {\n  const errors: { source: string; error: unknown }[] = [];\n\n  for (const [retrieve, source] of [\n    // Try to retrieve launch parameters from the current location. This method\n    // can return nothing in case, location was changed, and then the page was\n    // reloaded.\n    [() => retrieveLpFromUrl(window.location.href), 'window.location.href'],\n    // Then, try using the lower level API - window.performance.\n    [() => {\n      const navigationEntry = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming | undefined;\n      return navigationEntry && retrieveLpFromUrl(navigationEntry.name);\n    }, 'performance navigation entries'],\n    // Finally, try using the session storage.\n    [() => getStorageValue<string>(SESSION_STORAGE_KEY), 'local storage'],\n  ] as const) {\n    const v = retrieve();\n    if (!v) {\n      errors.push({ source, error: new Error('Source is empty') });\n      continue;\n    }\n    const maybeError = pipe(\n      parseLaunchParamsQueryFp(v),\n      E.foldW(err => err, () => true as const),\n    );\n    if (typeof maybeError !== 'boolean') {\n      errors.push({ source, error: maybeError });\n      continue;\n    }\n    setStorageValue(SESSION_STORAGE_KEY, v);\n    return E.right(v);\n  }\n  return E.left(new LaunchParamsRetrieveError(errors));\n}\n\n/**\n * @see retrieveRawLaunchParamsFp\n */\nexport const retrieveRawLaunchParams = throwifyFpFn(retrieveRawLaunchParamsFp);\n","import { type MethodName, supports } from '@tma.js/bridge';\nimport { type Computed, computed } from '@tma.js/signals';\nimport type { Version } from '@tma.js/types';\n\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport function createIsSupportedSignal(\n  method: MethodName,\n  version: MaybeAccessor<Version>,\n): Computed<boolean> {\n  return computed(() => supports(method, access(version)));\n}\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_, tapEither as tapEither_ } from './FromEither';\nimport { constNull, constUndefined, dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { not } from './Predicate';\nimport { first, last } from './Semigroup';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = _.none;\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = _.some;\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getLeft = function (ma) { return (ma._tag === 'Right' ? none : some(ma.left)); };\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getRight = function (ma) { return (ma._tag === 'Left' ? none : some(ma.right)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (S) { return ({\n    show: function (ma) { return (isNone(ma) ? 'none' : \"some(\".concat(S.show(ma.value), \")\")); }\n}); };\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (E) { return ({\n    equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n}); };\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = function (O) { return ({\n    equals: getEq(O).equals,\n    compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : isSome(y) ? -1 : 0); }\n}); };\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(b) | some(b)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function (S) { return ({\n    concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n    empty: none\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Some` value of this `Option` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isNone(ma) ? none : f(ma.value)); });\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n}; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isNone(fa) ? M.empty : f(fa.value);\n}; }; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"fp-ts/Option\"\n *\n * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))\n * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var orElse = dual(2, function (self, that) { return (isNone(self) ? that() : self); });\n/**\n * Alias of `orElse`.\n *\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var altW = orElse;\n/**\n * Alias of `orElse`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var alt = orElse;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ flatMap(identity);\nvar defaultSeparated = /*#__PURE__*/ separated(none, none);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    return isNone(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (fa) {\n        return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n}; };\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return function (fa) {\n        return separated(_filter(fa, not(predicate)), _filter(fa, predicate));\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return flow(map(f), separate); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n        };\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getright)\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isSome = _.isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onNone, onSome) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : onSome(ma.value);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : ma.value;\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = compact;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   O.of(value),\n *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * assert.deepStrictEqual(compute(1), O.of(1))\n * assert.deepStrictEqual(compute(-42), O.none)\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainEitherK = \n/*#__PURE__*/ chainEitherK_(FromEither, Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (a) { return (a == null ? none : some(a)); };\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); });\n    };\n};\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category lifting\n * @since 2.9.0\n */\nexport var fromNullableK = function (f) { return flow(f, fromNullable); };\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   readonly company?: {\n *     readonly address?: {\n *       readonly street?: {\n *         readonly name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category sequencing\n * @since 2.9.0\n */\nexport var chainNullableK = function (f) {\n    return function (ma) {\n        return isNone(ma) ? none : fromNullable(f(ma.value));\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toNullable = /*#__PURE__*/ match(constNull, identity);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toUndefined = /*#__PURE__*/ match(constUndefined, identity);\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isNone(ma) ? false : E.equals(a, ma.value);\n    };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isNone(ma) ? false : predicate(ma.value);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var o = f(0, _.head(as));\n        if (isNone(o)) {\n            return none;\n        }\n        var out = [o.value];\n        for (var i = 1; i < as.length; i++) {\n            var o_1 = f(i, as[i]);\n            if (isNone(o_1)) {\n                return none;\n            }\n            out.push(o_1.value);\n        }\n        return some(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n/**\n * Use [`chainNullableK`](#chainnullablek) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`\n * (where `O` is from `import O from 'fp-ts/Option'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var option = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    zero: zero,\n    alt: _alt,\n    extend: _extend,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = /*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = /*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use\n *\n * ```ts\n * import { first } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(first())\n * ```\n *\n * instead.\n *\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstMonoid = function () { return getMonoid(first()); };\n/**\n * Use\n *\n * ```ts\n * import { last } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(last())\n * ```\n *\n * instead.\n *\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastMonoid = function () { return getMonoid(last()); };\n","import { throwifyFpFn, throwifyAnyEither, type AnyFn } from '@tma.js/toolkit';\nimport * as O from 'fp-ts/Option';\nimport { pipe } from 'fp-ts/function';\n\nimport type { WithChecksFp, WithChecks } from '@/with-checks/withChecksFp.js';\n\nexport function throwifyWithChecksFp<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsMapKeySchema extends string,\n>(\n  fn: WithChecksFp<Fn, HasSupportCheck, SupportsMapKeySchema>,\n): WithChecks<Fn, HasSupportCheck, SupportsMapKeySchema> {\n  return Object.assign(throwifyFpFn(fn), {\n    ifAvailable(...args: Parameters<Fn>) {\n      return pipe(\n        fn.ifAvailable(...args),\n        O.match(\n          () => ({ ok: false }),\n          data => ({\n            ok: true,\n            data: throwifyAnyEither(data),\n          }),\n        ),\n      );\n    },\n  }) as unknown as WithChecks<Fn, HasSupportCheck, SupportsMapKeySchema>;\n}\n","import type { If, IsNever, IsUndefined, Or } from '@tma.js/toolkit';\nimport mitt, {\n  type Emitter,\n  type EventHandlerMap,\n  type EventType,\n  type Handler,\n} from 'mitt';\n\nexport type WildcardHandler<E> = Handler<{\n  [K in keyof E]: {\n    name: K;\n    payload: If<Or<IsNever<E[K]>, IsUndefined<E[K]>>, never, E[K]>;\n  };\n}[keyof E]>;\n\nexport interface OnFn<E> {\n  /**\n   * Adds a new listener for the specified event.\n   * @param type - event name.\n   * @param handler - event listener.\n   * @param once - should this listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  <K extends keyof E>(type: K, handler: Handler<E[K]>, once?: boolean): VoidFunction;\n  /**\n   * Adds a listener to the wildcard event.\n   * @param type - event name.\n   * @param handler - event listener.\n   * @param once - should this listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  (type: '*', handler: WildcardHandler<E>, once?: boolean): VoidFunction;\n}\n\nexport interface OffFn<E> {\n  /**\n   * Removes a listener from the specified event.\n   * @param type - event to listen.\n   * @param handler - event listener to remove.\n   * @param once - had this listener to be called only once.\n   */\n  <K extends keyof E>(type: K, handler: Handler<E[K]>, once?: boolean): void;\n  /**\n   * Removes a listener from the wildcard event.\n   * @param type - event to stop listening.\n   * @param handler - event listener to remove.\n   * @param once - should this listener be called only once.\n   */\n  (type: '*', handler: WildcardHandler<E>, once?: boolean): void;\n}\n\nexport interface EmitFn<E> {\n  <K extends keyof E>(type: K, event: E[K]): void;\n  <K extends keyof E>(type: undefined extends E[K] ? K : never): void;\n}\n\n/**\n * Creates a new enhanced event emitter.\n * @param onFirst - a function to call every time when the events map appeared to be empty during\n * the event listener creation.\n * @param onEmpty - a function to call every tume when the events map became empty.\n */\nexport function createEmitter<E extends object>(\n  onFirst: VoidFunction,\n  onEmpty: VoidFunction,\n): {\n  on: OnFn<E>;\n  off: OffFn<E>;\n  emit: EmitFn<E>;\n  clear: VoidFunction;\n} {\n  // To understand the event handlers concept here, let's tell the underlying idea.\n  //\n  // We use a Map, where key is an event name, and the value is a Map we call HandlersMap.\n  //\n  // The HandlersMap is a Map, where the key is an event handler, added by the developer.\n  // The corresponding value is a list of tuples, with an internally generated function and a\n  // boolean value responsible for determining if the handler must be called only once. So, you\n  // can imagine the following map as:\n  //\n  // HandlersMap {\n  //   { developer_handler }: Array<[ internally_created_handler, once ]>;\n  // }\n  //\n  // The value for the key represents an array of tuples, as long as a single handler may be added\n  // many times, and for each addition we add a new tuple entry.\n  //\n  // The handler may also be added to be called only once. Trying to remove such kind of handler\n  // using a different value of the \"once\" argument will lead to nothing. The developer must\n  // specify the same argument value to avoid confusions.\n  //\n  // Here is the final EventToHandlersMap definition:\n  //\n  // EventToHandlersMap {\n  //   { event_name }: HandlersMap {\n  //     { developer_handler }: Array<[ internally_created_handler, once ]>;\n  //   }\n  // }\n  type HandlersMap = Map<\n    (...args: any) => void,\n    [handler: (...args: any) => void, once: boolean][]\n  >;\n\n  const eventToHandlersMap = new Map<keyof E | '*', HandlersMap>();\n\n  const emitter = (mitt as any as {\n    <E extends Record<EventType, unknown>>(all?: EventHandlerMap<E>): Emitter<E>;\n  })<E & Record<string | symbol, unknown>>();\n\n  const off: OffFn<E> = (\n    event: keyof E | '*',\n    handler: (...args: any) => void,\n    once = false,\n  ) => {\n    const handlersMap: HandlersMap = eventToHandlersMap.get(event) || new Map();\n    eventToHandlersMap.set(event, handlersMap);\n\n    const handlers = handlersMap.get(handler) || [];\n    handlersMap.set(handler, handlers);\n\n    const index = handlers.findIndex(item => item[1] === once);\n    if (index >= 0) {\n      // Remove the related handler.\n      emitter.off(event, handlers[index][0]);\n\n      // Remove the handler from the cache array.\n      handlers.splice(index, 1);\n\n      // If after removal, there are no handlers left, we should remove the entry from the cache.\n      if (!handlers.length) {\n        handlersMap.delete(handler);\n        if (!handlersMap.size) {\n          const prevSize = eventToHandlersMap.size;\n          eventToHandlersMap.delete(event);\n          prevSize && !eventToHandlersMap.size && onEmpty();\n        }\n      }\n    }\n  };\n\n  return {\n    on(event: keyof E | '*', handler: (...args: any[]) => any, once?: boolean) {\n      // The events' map became non-empty. Call the onFirst callback.\n      !eventToHandlersMap.size && onFirst();\n\n      const cleanup = () => {\n        off(event as any, handler, once);\n      };\n\n      const internalHandler = (...args: any[]) => {\n        once && cleanup();\n        if (event === '*') {\n          handler({ name: args[0], payload: args[1] });\n        } else {\n          handler(...args);\n        }\n      };\n\n      emitter.on(event, internalHandler);\n\n      // Add this handler to the cache, so we could remove it using the passed listener.\n      const handlersMap: HandlersMap = eventToHandlersMap.get(event) || new Map();\n      eventToHandlersMap.set(event, handlersMap);\n\n      const handlers = handlersMap.get(handler) || [];\n      handlersMap.set(handler, handlers);\n      handlers.push([internalHandler, once || false]);\n\n      return cleanup;\n    },\n    off,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    emit: emitter.emit,\n    clear() {\n      const prevSize = eventToHandlersMap.size;\n      emitter.all.clear();\n      eventToHandlersMap.clear();\n      prevSize && onEmpty();\n    },\n  };\n}\n","import { ap as ap_ } from './Apply';\nimport * as E from './Either';\nimport { flow, pipe } from './function';\nimport { map as map_ } from './Functor';\nexport function right(F) {\n    return flow(E.right, F.of);\n}\nexport function left(F) {\n    return flow(E.left, F.of);\n}\nexport function rightF(F) {\n    return function (fa) { return F.map(fa, E.right); };\n}\nexport function leftF(F) {\n    return function (fe) { return F.map(fe, E.left); };\n}\nexport function fromNullable(F) {\n    return function (e) { return flow(E.fromNullable(e), F.of); };\n}\nexport function fromNullableK(F) {\n    var fromNullableF = fromNullable(F);\n    return function (e) {\n        var fromNullableFE = fromNullableF(e);\n        return function (f) { return flow(f, fromNullableFE); };\n    };\n}\nexport function chainNullableK(M) {\n    var chainM = chain(M);\n    var fromNullableKM = fromNullableK(M);\n    return function (e) {\n        var fromNullableKMe = fromNullableKM(e);\n        return function (f) { return chainM(fromNullableKMe(f)); };\n    };\n}\nexport function map(F) {\n    return map_(F, E.Functor);\n}\nexport function ap(F) {\n    return ap_(F, E.Apply);\n}\nexport function chain(M) {\n    var flatMapM = flatMap(M);\n    return function (f) { return function (ma) { return flatMapM(ma, f); }; };\n}\n/** @internal */\nexport function flatMap(M) {\n    return function (ma, f) { return M.chain(ma, function (e) { return (E.isLeft(e) ? M.of(e) : f(e.right)); }); };\n}\nexport function alt(M) {\n    return function (second) { return function (first) { return M.chain(first, function (e) { return (E.isLeft(e) ? second() : M.of(e)); }); }; };\n}\nexport function bimap(F) {\n    var mapBothF = mapBoth(F);\n    return function (f, g) { return function (self) { return mapBothF(self, f, g); }; };\n}\n/** @internal */\nexport function mapBoth(F) {\n    return function (self, f, g) { return F.map(self, E.bimap(f, g)); };\n}\nexport function mapLeft(F) {\n    var mapErrorF = mapError(F);\n    return function (f) { return function (self) { return mapErrorF(self, f); }; };\n}\n/** @internal */\nexport function mapError(F) {\n    return function (self, f) { return F.map(self, E.mapLeft(f)); };\n}\nexport function altValidation(M, S) {\n    return function (second) { return function (first) {\n        return M.chain(first, E.match(function (e1) {\n            return M.map(second(), E.mapLeft(function (e2) { return S.concat(e1, e2); }));\n        }, right(M)));\n    }; };\n}\nexport function match(F) {\n    return function (onLeft, onRight) { return function (ma) { return F.map(ma, E.match(onLeft, onRight)); }; };\n}\nexport function matchE(M) {\n    return function (onLeft, onRight) { return function (ma) { return M.chain(ma, E.match(onLeft, onRight)); }; };\n}\nexport function getOrElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, E.match(onLeft, M.of)); }; };\n}\nexport function orElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, function (e) { return (E.isLeft(e) ? onLeft(e.left) : M.of(e)); }); }; };\n}\nexport function orElseFirst(M) {\n    var tapErrorM = tapError(M);\n    return function (onLeft) { return function (ma) { return tapErrorM(ma, onLeft); }; };\n}\n/** @internal */\nexport function tapError(M) {\n    var orElseM = orElse(M);\n    return function (ma, onLeft) {\n        return pipe(ma, orElseM(function (e) { return M.map(onLeft(e), function (eb) { return (E.isLeft(eb) ? eb : E.left(e)); }); }));\n    };\n}\nexport function orLeft(M) {\n    return function (onLeft) { return function (ma) {\n        return M.chain(ma, E.match(function (e) { return M.map(onLeft(e), E.left); }, function (a) { return M.of(E.right(a)); }));\n    }; };\n}\nexport function swap(F) {\n    return function (ma) { return F.map(ma, E.swap); };\n}\nexport function toUnion(F) {\n    return function (fa) { return F.map(fa, E.toUnion); };\n}\n/** @deprecated  */\n/* istanbul ignore next */\nexport function getEitherM(M) {\n    var _ap = ap(M);\n    var _map = map(M);\n    var _chain = chain(M);\n    var _alt = alt(M);\n    var _bimap = bimap(M);\n    var _mapLeft = mapLeft(M);\n    var _fold = matchE(M);\n    var _getOrElse = getOrElse(M);\n    var _orElse = orElse(M);\n    return {\n        map: function (fa, f) { return pipe(fa, _map(f)); },\n        ap: function (fab, fa) { return pipe(fab, _ap(fa)); },\n        of: right(M),\n        chain: function (ma, f) { return pipe(ma, _chain(f)); },\n        alt: function (fa, that) { return pipe(fa, _alt(that)); },\n        bimap: function (fea, f, g) { return pipe(fea, _bimap(f, g)); },\n        mapLeft: function (fea, f) { return pipe(fea, _mapLeft(f)); },\n        fold: function (fa, onLeft, onRight) { return pipe(fa, _fold(onLeft, onRight)); },\n        getOrElse: function (fa, onLeft) { return pipe(fa, _getOrElse(onLeft)); },\n        orElse: function (fa, f) { return pipe(fa, _orElse(f)); },\n        swap: swap(M),\n        rightM: rightF(M),\n        leftM: leftF(M),\n        left: left(M)\n    };\n}\n","import type { EventPayload, EventWithoutPayload, EventWithPayload } from '@/events/types/index.js';\n\n/**\n * Emits an event without payload sent from the Telegram native application like it was sent in\n * a default web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n */\nexport function emitEvent<E extends EventWithoutPayload>(eventType: E): void;\n\n/**\n * Emits an event with payload sent from the Telegram native application like it was sent in\n * a default web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent<E extends EventWithPayload>(\n  eventType: E,\n  eventData: EventPayload<E>,\n): void;\n\n/**\n * Emits an unknown event sent from the Telegram native application like it was sent in a default\n * web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent<E extends string>(\n  eventType: E,\n  eventData: E extends EventWithoutPayload\n    ? never\n    : E extends EventWithPayload\n      ? EventPayload<E>\n      : unknown,\n): void;\n\n/**\n * Emits an event sent from the Telegram native application like it was sent in a default web\n * environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent(eventType: string, eventData?: unknown): void {\n  window.dispatchEvent(new MessageEvent('message', {\n    data: JSON.stringify({ eventType, eventData }),\n    // We specify this kind of source here in order to allow the package's \"on\" function to\n    // capture it. The reason is this function always checks the event source and relies on\n    // it to be the parent window.\n    source: window.parent,\n  }));\n}\n","/**\n * ```ts\n * interface Task<A> {\n *   (): Promise<A>\n * }\n * ```\n *\n * `Task<A>` represents an asynchronous computation that yields a value of type `A` and **never fails**.\n * If you want to represent an asynchronous computation that may fail, please see `TaskEither`.\n *\n * @since 2.0.0\n */\nimport { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { dual, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIO = function (ma) { return function () { return Promise.resolve().then(ma); }; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as T from 'fp-ts/Task'\n * import { takeRight } from 'fp-ts/Array'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = T.delay(20)(append('b'))\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])\n * }\n *\n * test()\n *\n * @since 2.0.0\n */\nexport function delay(millis) {\n    return function (ma) { return function () {\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                Promise.resolve().then(ma).then(resolve);\n            }, millis);\n        });\n    }; };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return function () {\n    return Promise.resolve().then(fa).then(f);\n}; }; };\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) { return function () {\n    return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function (_a) {\n        var f = _a[0], a = _a[1];\n        return f(a);\n    });\n}; }; };\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return function () { return Promise.resolve(a); }; };\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return function () {\n        return Promise.resolve()\n            .then(ma)\n            .then(function (a) { return f(a)(); });\n    };\n});\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Task';\n/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getRaceMonoid() {\n    return {\n        concat: function (x, y) { return function () { return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]); }; },\n        empty: never\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the value to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the value to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO\n};\n/**\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var fromTask = identity;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIO = _.flatMapIO(_FromIO, _FlatMap);\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as T from 'fp-ts/Task'\n * import * as Console from 'fp-ts/Console'\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effect = pipe(\n *   T.of('fp-ts'),\n *   T.tapIO((value) => Console.log(`Hello, ${value}`)),\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), 'fp-ts')\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOK = \n/*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * A `Task` that never completes.\n *\n * @since 2.0.0\n */\nexport var never = function () { return new Promise(function (_) { return undefined; }); };\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        return function () {\n            return Promise.all(as.map(function (a, i) { return Promise.resolve().then(function () { return f(i, a)(); }); }));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (bs) {\n                    return Promise.resolve()\n                        .then(f(i + 1, a))\n                        .then(function (b) {\n                        bs.push(b);\n                        return bs;\n                    });\n                });\n            }, Promise.resolve()\n                .then(f(0, _.head(as)))\n                .then(_.singleton));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) {\n    return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.task`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var task = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.taskSeq`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskSeq = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = /*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMonoid = /*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n","import { signal, computed } from '@tma.js/signals';\nimport { createLogger, type Logger } from '@tma.js/toolkit';\n\nimport { off, offAll, on } from '@/events/emitter.js';\nimport type { SubscribeListener } from '@/events/types/index.js';\nimport type { PostMessage } from '@/methods/postMessage.js';\n\n/**\n * @internal\n */\nconst _debug = signal(false);\n/**\n * @internal\n */\nconst _targetOrigin = signal('https://web.telegram.org');\n\nconst onEventReceived: SubscribeListener = event => {\n  logger().log('Event received:', event);\n};\n\n/**\n * The current debug mode state.\n *\n * To update the value, use the `setDebug` function.\n * @see setDebug\n */\nexport const debug = computed(_debug);\n\n/**\n * Sets the package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  if (value !== _debug()) {\n    _debug.set(value);\n    (value ? on : off)('*', onEventReceived);\n  }\n}\n\n/**\n * The current target origin used by the `postEvent` method.\n *\n * You don't need to override this value until you know what you are doing.\n * To update the value, use the `setTargetOrigin` function.\n * @default 'https://web.telegram.org'\n * @see setTargetOrigin\n */\nexport const targetOrigin = computed(_targetOrigin);\n\n/**\n * Sets a new target origin that is being used when calling the `postEvent` function in Telegram\n * web versions.\n *\n * You don't need to override this value until you know what you are doing.\n * @param origin - allowed target origin value.\n * @see _targetOrigin\n */\nexport function setTargetOrigin(origin: string) {\n  _targetOrigin.set(origin);\n  logger().log('New target origin set', origin);\n}\n\n/**\n * Signal containing a custom implementation of the method to post a message to the parent\n * window. We usually use it to send a message in web versions of Telegram.\n *\n * @default A function behaving like the `window.parent.postMessage` method.\n */\nexport const postMessageImpl = signal<PostMessage>((...args) => {\n  window.parent.postMessage(...args as unknown as Parameters<PostMessage>);\n});\n\n/**\n * The package logger. You can override this value in order to use your own implementation.\n */\nexport const logger = signal<Logger>(createLogger('Bridge', {\n  bgColor: '#9147ff',\n  textColor: 'white',\n  shouldLog: debug,\n}));\n\n/**\n * Resets the package global values. Normally, you don't use this function in your application.\n * We are using it only for test purposes.\n */\nexport function resetGlobals() {\n  offAll();\n  [postMessageImpl, _targetOrigin, targetOrigin, _debug, debug, logger].forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n","/**\n * Defines a property, that is a functions compose. Trying to set a value in this property\n * will lead to adding it to a function's pool. The property value will always be equal to a\n * function, calling all collected functions in the pool.\n *\n * Returned function performs a cleanup. It does one of the following:\n * 1. Removes the property if no functions were to the pool added other than the initial one.\n * 2. Sets the value equal to the first added function to the pool after the initial one if\n * the only one additional function was added at all. In other words, if the pool length is equal\n * to 2, the second item will be selected as the property value.\n * 3. Leaves the value equal to a function calling all pool functions, but removes the initially\n * added one.\n * @param obj - object.\n * @param propertyName - object property.\n * @param initialFn - an initial function to set.\n */\nexport function defineFnComposer(\n  obj: any,\n  propertyName: string,\n  initialFn: (...args: any) => any,\n): void {\n  const assignedFunctions: any[] = [initialFn];\n\n  const property = obj[propertyName];\n  if (typeof property === 'function') {\n    assignedFunctions.push(property);\n  }\n\n  const callAssignedFunctions = (...args: any) => {\n    assignedFunctions.forEach(fn => fn(...args));\n  };\n\n  // Wrap the callPool function and add \"unwrap\" method to it.\n  const unwrappableCallAssignedFunctions = Object.assign((...args: any) => {\n    callAssignedFunctions(...args);\n  }, {\n    // Unwraps the composer.\n    unwrap() {\n      const { length: poolSize } = assignedFunctions;\n      if (poolSize === 1) {\n        // Only the initial handler is in the pool. In this case we just remove the property.\n        delete obj[propertyName];\n        return;\n      }\n      if (poolSize === 2) {\n        // Only one additional handler was added. We set it as a value for the property.\n        defineStaticProperty(obj, propertyName, assignedFunctions[1]);\n        return;\n      }\n      // Many additional handlers were added. In this case we remove the initially added function\n      // from the pool and leave the property value almost as is - only \"unwrap\" method will be\n      // removed.\n      assignedFunctions.unshift(1);\n      defineStaticProperty(obj, propertyName, callAssignedFunctions);\n    },\n  });\n\n  // This property should now always return our special function. Trying to set it to another\n  // function should lead to just adding it to the pool of called functions.\n  defineProxiedProperty(\n    obj,\n    propertyName,\n    () => unwrappableCallAssignedFunctions,\n    value => assignedFunctions.push(value),\n  );\n}\n\n/**\n * Wires the specified property in the object preventing it from being overwritten. Instead, it\n * enhances the previous value by merging the current one with the passed one.\n * @param obj - object.\n * @param prop - object property to rewire.\n */\nexport function defineMergeableProperty(obj: any, prop: string): void {\n  const value = obj[prop];\n  defineProxiedProperty(obj, prop, () => value, v => {\n    Object.entries(v).forEach(([objKey, objValue]) => {\n      value[objKey] = objValue;\n    });\n  });\n}\n\n/**\n * Defines an enumerable and configurable property with a getter and setter.\n * @param obj - object.\n * @param prop - object property name.\n * @param get - getter to use.\n * @param set - setter to use.\n */\nexport function defineProxiedProperty(\n  obj: any,\n  prop: string,\n  get: () => unknown,\n  set: (v: any) => void,\n) {\n  Object.defineProperty(obj, prop, {\n    enumerable: true,\n    configurable: true,\n    get,\n    set,\n  });\n}\n\n/**\n * Defines an enumerable, configurable and writable property with the initial value.\n * @param obj - object.\n * @param prop - object property name.\n * @param value - value to set.\n */\nexport function defineStaticProperty(obj: any, prop: string, value: any): void {\n  Object.defineProperty(obj, prop, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value,\n  });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { getApplicativeMonoid } from './Applicative';\nimport { ap as ap_, apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { compact as compact_, separate as separate_ } from './Compactable';\nimport * as E from './Either';\nimport * as ET from './EitherT';\nimport { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, tapEither as tapEither_ } from './FromEither';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { fromTaskK as fromTaskK_, tapTask as tapTask_ } from './FromTask';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as T from './Task';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var left = /*#__PURE__*/ ET.left(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var right = /*#__PURE__*/ ET.right(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightTask = /*#__PURE__*/ ET.rightF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftTask = /*#__PURE__*/ ET.leftF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightIO = /*#__PURE__*/ flow(T.fromIO, rightTask);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftIO = /*#__PURE__*/ flow(T.fromIO, leftTask);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromIO = rightIO;\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromTask = rightTask;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = T.of;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIOEither = T.fromIO;\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromTaskOption = function (onNone) {\n    return T.map(E.fromOption(onNone));\n};\n/**\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = \n/*#__PURE__*/ ET.match(T.Functor);\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = match;\n/**\n * The `E` suffix (short for **E**ffect) means that the handlers return an effect (`Task`).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchE = /*#__PURE__*/ ET.matchE(T.Monad);\n/**\n * Alias of [`matchE`](#matche).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = matchE;\n/**\n * Less strict version of [`matchE`](#matche).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchEW = matchE;\n/**\n * Alias of [`matchEW`](#matchew).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchEW;\n/**\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = \n/*#__PURE__*/ ET.getOrElse(T.Monad);\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = getOrElse;\n/**\n * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { left, right } from 'fp-ts/Either'\n * import { tryCatch } from 'fp-ts/TaskEither'\n *\n * tryCatch(() => Promise.resolve(1), String)().then(result => {\n *   assert.deepStrictEqual(result, right(1))\n * })\n * tryCatch(() => Promise.reject('error'), String)().then(result => {\n *   assert.deepStrictEqual(result, left('error'))\n * })\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onRejected) {\n    return function () { return __awaiter(void 0, void 0, void 0, function () {\n        var reason_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, f().then(_.right)];\n                case 1: return [2 /*return*/, _a.sent()];\n                case 2:\n                    reason_1 = _a.sent();\n                    return [2 /*return*/, _.left(onRejected(reason_1))];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n};\n/**\n * Converts a function returning a `Promise` to one returning a `TaskEither`.\n *\n * @category interop\n * @since 2.5.0\n */\nexport var tryCatchK = function (f, onRejected) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onRejected);\n    };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ ET.toUnion(T.Functor);\n/**\n * @category conversions\n * @since 2.12.0\n */\nexport var fromNullable = /*#__PURE__*/ ET.fromNullable(T.Pointed);\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var fromNullableK = /*#__PURE__*/ ET.fromNullableK(T.Pointed);\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainNullableK = \n/*#__PURE__*/ ET.chainNullableK(T.Monad);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Returns `ma` if is a `Right` or the value returned by `onLeft` otherwise.\n *\n * See also [alt](#alt).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   const errorHandler = TE.orElse((error: string) => TE.right(`recovering from ${error}...`))\n *   assert.deepStrictEqual(await pipe(TE.right('ok'), errorHandler)(), E.right('ok'))\n *   assert.deepStrictEqual(await pipe(TE.left('ko'), errorHandler)(), E.right('recovering from ko...'))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = \n/*#__PURE__*/ ET.orElse(T.Monad);\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = orElse;\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @category error handling\n * @since 2.15.0\n */\nexport var tapError = /*#__PURE__*/ dual(2, ET.tapError(T.Monad));\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstIOK = function (onLeft) { return tapError(fromIOK(onLeft)); };\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstTaskK = function (onLeft) { return tapError(fromTaskK(onLeft)); };\n/**\n * @category error handling\n * @since 2.11.0\n */\nexport var orLeft = \n/*#__PURE__*/ ET.orLeft(T.Monad);\n/**\n * @since 2.0.0\n */\nexport var swap = /*#__PURE__*/ ET.swap(T.Functor);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromTaskOptionK = function (onNone) {\n    var from = fromTaskOption(onNone);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.3\n */\nexport var chainTaskOptionKW = function (onNone) {\n    return function (f) {\n        return function (ma) {\n            return flatMap(ma, fromTaskOptionK(onNone)(f));\n        };\n    };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainTaskOptionK = chainTaskOptionKW;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOEitherK = function (f) { return flow(f, fromIOEither); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = /*#__PURE__*/ ET.map(T.Functor);\n/**\n * Returns a `TaskEither` whose failure and success channels have been mapped by the specified pair of functions, `f` and `g`.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n * const g = (n: number) => n * 2\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.right(1), f, g)(), Either.right(2))\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.left('err'), f, g)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapBoth = /*#__PURE__*/ dual(3, ET.mapBoth(T.Functor));\n/**\n * Alias of `mapBoth`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var bimap = mapBoth;\n/**\n * Returns a `TaskEither` with its error channel mapped using the specified function.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.right(1), f)(), Either.right(1))\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.left('err'), f)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapError = /*#__PURE__*/ dual(2, ET.mapError(T.Functor));\n/**\n * Alias of `mapError`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var mapLeft = mapError;\n/**\n * @since 2.0.0\n */\nexport var ap = \n/*#__PURE__*/ ET.ap(T.ApplyPar);\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = ap;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, ET.flatMap(T.Monad));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `TaskEither` returns `fa` if is a `Right` or the value returned by `that` otherwise.\n *\n * See also [orElse](#orelse).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.right(1),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(1)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(2)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.left('b'))\n *     )(),\n *     E.left('b')\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = \n/*#__PURE__*/ ET.alt(T.Monad);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = alt;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = right;\n/**\n * @since 2.7.0\n */\nexport var throwError = left;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'TaskEither';\n/**\n * The default [`ApplicativePar`](#applicativepar) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n * import * as T from 'fp-ts/Task'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * interface User {\n *   readonly id: string\n *   readonly name: string\n * }\n *\n * const remoteDatabase: ReadonlyArray<User> = [\n *   { id: 'id1', name: 'John' },\n *   { id: 'id2', name: 'Mary' },\n *   { id: 'id3', name: 'Joey' }\n * ]\n *\n * const fetchUser = (id: string): TE.TaskEither<string, User> =>\n *   pipe(\n *     remoteDatabase,\n *     RA.findFirst((user) => user.id === id),\n *     TE.fromOption(() => `${id} not found`)\n *   )\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(TE.ApplicativePar)(fetchUser))(),\n *     E.left('id4 not found') // <= first error\n *   )\n *\n *   const Applicative = TE.getApplicativeTaskValidation(\n *     T.ApplyPar,\n *     pipe(string.Semigroup, S.intercalate(', '))\n *   )\n *\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(Applicative)(fetchUser))(),\n *     E.left('id4 not found, id5 not found') // <= all errors\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getApplicativeTaskValidation(A, S) {\n    var ap = ap_(A, E.getApplicativeValidation(S));\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return pipe(fab, ap(fa)); },\n        of: of\n    };\n}\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * See [`getAltValidation`](./Either.ts.html#getaltvalidation).\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getAltTaskValidation(S) {\n    var alt = ET.altValidation(T.Monad, S);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        alt: function (fa, that) { return pipe(fa, alt(that)); }\n    };\n}\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var C = E.getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: compact_(T.Functor, C),\n        separate: separate_(T.Functor, C, E.Functor)\n    };\n};\n/**\n * @category filtering\n * @since 2.1.0\n */\nexport function getFilterable(M) {\n    var F = E.getFilterable(M);\n    var C = getCompactable(M);\n    var filter = filter_(T.Functor, F);\n    var filterMap = filterMap_(T.Functor, F);\n    var partition = partition_(T.Functor, F);\n    var partitionMap = partitionMap_(T.Functor, F);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: C.compact,\n        separate: C.separate,\n        filter: function (fa, predicate) { return pipe(fa, filter(predicate)); },\n        filterMap: function (fa, f) { return pipe(fa, filterMap(f)); },\n        partition: function (fa, predicate) { return pipe(fa, partition(predicate)); },\n        partitionMap: function (fa, f) { return pipe(fa, partitionMap(f)); }\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `TaskEither` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `TaskEither` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Less strict version of [`apFirst`](#apfirst).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Less strict version of [`apSecond`](#apsecond).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * const checkString = (value: string) => pipe(\n *   TE.of(value),\n *   TE.tapEither(() => value.length > 0 ? E.right('ok') : E.left('error'))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await checkString('')(), E.left('error'))\n *   assert.deepStrictEqual(await checkString('fp-ts')(), E.right('fp-ts'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n * import * as E from 'fp-ts/Either'\n * import * as Console from 'fp-ts/Console'\n *\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effectA = TE.tapIO(\n *   TE.of(1),\n *   (value) => Console.log(`Hello, ${value}`)\n * )\n *\n * // No output to the stdout\n * const effectB = pipe(\n *   TE.left('error'),\n *   TE.tapIO((value) => Console.log(`Hello, ${value}`))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effectA(), E.of(1))\n *   assert.deepStrictEqual(await effectB(), E.left('error'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as TE from 'fp-ts/TaskEither'\n * import * as T from 'fp-ts/Task'\n * import * as E from 'fp-ts/Either'\n *\n *\n * const effect = TE.tapIO(\n *   TE.of(1),\n *   (value) => T.of(value + 1)\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), E.of(1))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapTask = /*#__PURE__*/ dual(2, tapTask_(FromTask, Chain));\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/** @internal */\nvar _FromTask = {\n    fromTask: fromTask\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapEither = /*#__PURE__*/ _.flatMapEither(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapIO = /*#__PURE__*/ _.flatMapIO(_FromIO, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTask = /*#__PURE__*/ _.flatMapTask(_FromTask, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIOEither = /*#__PURE__*/ dual(2, function (self, f) {\n    return flatMap(self, fromIOEitherK(f));\n});\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTaskOption = /*#__PURE__*/ dual(3, function (self, f, onNone) {\n    return flatMap(self, function (a) { return fromTaskOption(function () { return onNone(a); })(f(a)); });\n});\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainEitherK = flatMapEither;\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainEitherKW = flatMapEither;\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Alias of `tapEither`.\n *\n * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherKW = tapEither;\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromIOK = /*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromTaskK = /*#__PURE__*/ fromTaskK_(FromTask);\n/**\n * Alias of `flatMapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainTaskK = flatMapTask;\n/**\n * Alias of `tapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstTaskK = tapTask;\n/**\n * Alias of `flatMapIOEither`.\n *\n * Less strict version of [`chainIOEitherK`](#chainioeitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainIOEitherKW = flatMapIOEither;\n/**\n * Alias of `flatMapIOEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOEitherK = flatMapIOEither;\nexport function taskify(f) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        return function () {\n            return new Promise(function (resolve) {\n                var cbResolver = function (e, r) { return (e != null ? resolve(_.left(e)) : resolve(_.right(r))); };\n                f.apply(null, args.concat(cbResolver));\n            });\n        };\n    };\n}\n/**\n * Make sure that a resource is cleaned up in the event of an exception (\\*). The release action is called regardless of\n * whether the body action throws (\\*) or returns.\n *\n * (\\*) i.e. returns a `Left`\n *\n * @since 2.0.0\n */\nexport var bracket = function (acquire, use, release) { return bracketW(acquire, use, release); };\n/**\n * Less strict version of [`bracket`](#bracket).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var bracketW = function (acquire, use, release) {\n    return flatMap(acquire, function (a) { return T.flatMap(use(a), function (e) { return flatMap(release(a, e), function () { return T.of(e); }); }); });\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return flow(T.traverseReadonlyNonEmptyArrayWithIndex(f), T.map(E.traverseReadonlyNonEmptyArrayWithIndex(SK)));\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (ebs) {\n                    return _.isLeft(ebs)\n                        ? acc\n                        : f(i + 1, a)().then(function (eb) {\n                            if (_.isLeft(eb)) {\n                                return eb;\n                            }\n                            ebs.right.push(eb.right);\n                            return ebs;\n                        });\n                });\n            }, f(0, _.head(as))().then(E.map(_.singleton)));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) { return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirst = tapError;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirstW = tapError;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEither`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEither = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEitherSeq`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEitherSeq = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = function (S) {\n    return getApplySemigroup_(T.ApplySeq)(E.getSemigroup(S));\n};\n/**\n * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getTaskValidation(SE) {\n    var applicativeTaskValidation = getApplicativeTaskValidation(T.ApplicativePar, SE);\n    var altTaskValidation = getAltTaskValidation(SE);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: applicativeTaskValidation.ap,\n        of: of,\n        chain: flatMap,\n        bimap: mapBoth,\n        mapLeft: mapError,\n        alt: altTaskValidation.alt,\n        fromIO: fromIO,\n        fromTask: fromTask,\n        throwError: throwError\n    };\n}\n","import { miniAppsMessage, pipeJsonToSchema, themeParams } from '@tma.js/transformers';\nimport {\n  boolean,\n  looseObject,\n  nullish,\n  number,\n  optional,\n  parse,\n  string,\n  unknown,\n  type BaseSchema,\n} from 'valibot';\n\nimport { createEmitter } from '@/events/createEmitter.js';\nimport { emitEvent } from '@/events/emitEvent.js';\nimport type { EventName, EventPayload, Events } from '@/events/types/index.js';\nimport { logger } from '@/globals.js';\nimport { defineFnComposer, defineMergeableProperty } from '@/obj-prop-helpers.js';\n\n/**\n * Transformers for problematic Mini Apps events.\n */\nconst transformers = {\n  clipboard_text_received: looseObject({\n    req_id: string(),\n    data: nullish(string()),\n  }),\n  custom_method_invoked: looseObject({\n    req_id: string(),\n    result: optional(unknown()),\n    error: optional(string()),\n  }),\n  popup_closed: nullish(\n    looseObject({ button_id: nullish(string(), () => undefined) }),\n    {},\n  ),\n  viewport_changed: nullish(\n    looseObject({\n      height: number(),\n      width: nullish(number(), () => window.innerWidth),\n      is_state_stable: boolean(),\n      is_expanded: boolean(),\n    }),\n    // TODO: At the moment, macOS has a bug with the invalid event payload - it is always equal to\n    //  null. Leaving this default value until the bug is fixed.\n    () => ({\n      height: window.innerHeight,\n      is_state_stable: true,\n      is_expanded: true,\n    }),\n  ),\n  theme_changed: looseObject({\n    theme_params: themeParams(),\n  }),\n} as const satisfies { [E in EventName]?: BaseSchema<unknown, EventPayload<E>, any> };\n\nfunction windowMessageListener(event: MessageEvent): void {\n  // Ignore non-parent window messages.\n  if (event.source !== window.parent) {\n    return;\n  }\n\n  // Parse incoming event data.\n  let message: { eventType: string; eventData?: unknown };\n  try {\n    message = parse(pipeJsonToSchema(miniAppsMessage()), event.data);\n  } catch {\n    // We ignore incorrect messages as they could be generated by any other code.\n    return;\n  }\n\n  const { eventType, eventData } = message;\n  const schema = transformers[eventType as keyof typeof transformers];\n\n  let data: unknown;\n  try {\n    data = schema ? parse(schema, eventData) : eventData;\n  } catch (cause) {\n    return logger().forceError(\n      [\n        `An error occurred processing the \"${eventType}\" event from the Telegram application.`,\n        'Please, file an issue here:',\n        'https://github.com/Telegram-Mini-Apps/tma.js/issues/new/choose',\n      ].join('\\n'),\n      message,\n      cause,\n    );\n  }\n  emit(eventType as any, data);\n}\n\nexport const {\n  on,\n  off,\n  emit,\n  clear: offAll,\n} = createEmitter<Events>(\n  () => {\n    const wnd = window as any;\n\n    // Define all functions responsible for receiving an event from the Telegram client.\n    // All these \"ports\" should narrow the communication way to a single specific one - the way\n    // accepted by the web version of Telegram between iframes.\n    //\n    // Here we consider 2 cases:\n    // 1. When the Telegram SDK is already connected. In this case the Telegram SDK already\n    // installed its own ports, and we should rewire them. The cleanup function should also work\n    // properly in this context, removing @tma.js/bridge handler only, not\n    // the Telegram SDK one.\n    // 2. When the Telegram SDK is not connected, but probably will be. We know, that\n    // the Telegram SDK is going to overwrite our own handlers. Due to this reason, we should\n    // protect them from being overwritten, but still support handlers defined by the Telegram SDK.\n\n    // TelegramGameProxy.receiveEvent\n    !wnd.TelegramGameProxy && (wnd.TelegramGameProxy = {});\n    defineFnComposer(wnd.TelegramGameProxy, 'receiveEvent', emitEvent);\n    defineMergeableProperty(wnd, 'TelegramGameProxy');\n\n    // Telegram.WebView.receiveEvent\n    !wnd.Telegram && (wnd.Telegram = {});\n    !wnd.Telegram.WebView && (wnd.Telegram.WebView = {});\n    defineFnComposer(wnd.Telegram.WebView, 'receiveEvent', emitEvent);\n    defineMergeableProperty(wnd.Telegram, 'WebView');\n\n    // TelegramGameProxy_receiveEvent\n    defineFnComposer(wnd, 'TelegramGameProxy_receiveEvent', emitEvent);\n\n    // Add a listener handling events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    // This handler should emit a new event using the library event emitter.\n    window.addEventListener('message', windowMessageListener);\n  },\n  () => {\n    [\n      ['TelegramGameProxy_receiveEvent'],\n      ['TelegramGameProxy', 'receiveEvent'],\n      ['Telegram', 'WebView', 'receiveEvent'],\n    ].forEach(path => {\n      const wnd = window as any;\n\n      // A tuple, where the first value is the receiveEvent function owner, and the second\n      // value is the receiveEvent itself.\n      let cursor: [obj: any, receieveEvent: any] = [undefined, wnd];\n      for (const item of path) {\n        cursor = [cursor[1], cursor[1][item]];\n        if (!cursor[1]) {\n          return;\n        }\n      }\n      const [receiveEventOwner, receiveEvent] = cursor;\n      if ('unwrap' in receiveEvent) {\n        receiveEvent.unwrap();\n        if (\n          receiveEventOwner\n          && receiveEventOwner !== wnd\n          && !Object.keys(receiveEventOwner).length\n        ) {\n          delete wnd[path[0]];\n        }\n      }\n    });\n    window.removeEventListener('message', windowMessageListener);\n  },\n);\n","import { errorClass, errorClassWithData } from 'error-kid';\nimport type { BaseIssue } from 'valibot';\n\nfunction msgToTuple(message?: string): [string?] {\n  return [message];\n}\n\nexport class ValidationError extends errorClassWithData<\n  { input: unknown; issues: BaseIssue<any>[] },\n  [input: unknown, issues: BaseIssue<any>[]]\n>(\n  'ValidationError',\n  (input, issues) => ({ input, issues }),\n  'Validation error',\n) {\n}\n\nexport class CSSVarsBoundError extends errorClass(\n  'CSSVarsBoundError',\n  'CSS variables are already bound',\n) {\n}\n\nexport class DeviceStorageMethodError extends errorClassWithData<\n  { error: string },\n  [error: string]\n>('DeviceStorageMethodError', error => ({ error }), error => [error]) {\n}\n\nexport class SecureStorageMethodError extends errorClassWithData<\n  { error: string },\n  [error: string]\n>('SecureStorageMethodError', error => ({ error }), error => [error]) {\n}\n\nexport class NotAvailableError extends errorClass<[message: string]>(\n  'NotAvailableError',\n  msgToTuple,\n) {\n}\n\nexport class InvalidEnvError extends errorClass<[message?: string]>(\n  'InvalidEnvError',\n  msgToTuple,\n) {\n}\n\nexport class FunctionUnavailableError extends errorClass<[message?: string]>(\n  'FunctionNotAvailableError',\n  msgToTuple,\n) {\n}\n\nexport class InvalidArgumentsError extends errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n) {\n}\n\nexport class ConcurrentCallError extends errorClass<[message: string]>(\n  'ConcurrentCallError',\n  msgToTuple,\n) {\n}\n\nexport class SetEmojiStatusError extends errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n) {\n}\n\nexport class AccessDeniedError extends errorClass<[message: string]>(\n  'AccessDeniedError',\n  msgToTuple,\n) {\n}\n\nexport class FullscreenFailedError extends errorClass<[message: string]>(\n  'FullscreenFailedError',\n  msgToTuple,\n) {\n}\n\nexport class ShareMessageError extends errorClass<[error: string]>(\n  'ShareMessageError',\n  msgToTuple,\n) {\n}\n\nexport class UnknownThemeParamsKeyError extends errorClass<[key: string]>(\n  'UnknownThemeParamsKeyError',\n  key => [`Unknown theme params key passed: ${key}`],\n) {\n}\n","import { postMessageImpl } from '@/globals.js';\n\nexport type PostMessage = typeof window.parent.postMessage;\n\n/**\n * Posts a message to the parent window. We usually use it to send a message in web versions of\n * Telegram.\n * @param args - `window.parent.postMessage` arguments.\n */\nexport const postMessage: PostMessage = (...args) => {\n  return postMessageImpl()(...args as unknown as Parameters<PostMessage>);\n};\n","import * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\nimport { function as fn, is, looseObject } from 'valibot';\n\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { isIframe } from '@/env/isIframe.js';\nimport { UnknownEnvError } from '@/errors.js';\nimport { logger, targetOrigin } from '@/globals.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\n\nimport { postMessage } from './postMessage.js';\n\nexport type PostEventError = UnknownEnvError;\nexport type PostEventFn = typeof postEvent;\nexport type PostEventFpFn = typeof postEventFp;\n\n/**\n * @see postEventFp\n */\nexport function postEvent<Method extends MethodNameWithRequiredParams>(\n  method: Method,\n  params: MethodParams<Method>,\n): void;\n/**\n * @see postEventFp\n */\nexport function postEvent(method: MethodNameWithoutParams): void;\n/**\n * @see postEventFp\n */\nexport function postEvent<Method extends MethodNameWithOptionalParams>(\n  method: Method,\n  params?: MethodParams<Method>,\n): void;\n\nexport function postEvent(\n  eventType: MethodName,\n  eventData?: MethodParams<MethodName>,\n): void {\n  pipe(\n    postEventFp(\n      // @ts-expect-error It's ok, TS can't determine a specific override.\n      eventType,\n      eventData,\n    ),\n    E.mapLeft(err => {\n      throw err;\n    }),\n  );\n}\n\n/**\n * Calls Mini Apps methods requiring parameters.\n * @param method - method name.\n * @param params - options along with params.\n */\nexport function postEventFp<Method extends MethodNameWithRequiredParams>(\n  method: Method,\n  params: MethodParams<Method>,\n): E.Either<PostEventError, void>;\n\n/**\n * Calls Mini Apps methods accepting no parameters at all.\n * @param method - method name.\n */\nexport function postEventFp(method: MethodNameWithoutParams): E.Either<PostEventError, void>;\n\n/**\n * Calls Mini Apps methods accepting optional parameters.\n * @param method - method name.\n * @param params - options along with params.\n */\nexport function postEventFp<Method extends MethodNameWithOptionalParams>(\n  method: Method,\n  params?: MethodParams<Method>,\n): E.Either<PostEventError, void>;\n\nexport function postEventFp(\n  eventType: MethodName,\n  eventData?: MethodParams<MethodName>,\n): E.Either<PostEventError, void> {\n  logger().log('Posting event:', eventData ? { eventType, eventData } : { eventType });\n\n  const w = window;\n  const message = JSON.stringify({ eventType, eventData });\n\n  // Telegram Web.\n  if (isIframe()) {\n    postMessage(message, targetOrigin());\n    return E.right(undefined);\n  }\n\n  // Telegram for iOS, macOS, Android and Telegram Desktop.\n  if (hasWebviewProxy(w)) {\n    w.TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));\n    return E.right(undefined);\n  }\n\n  // Telegram for Windows Phone or Android.\n  if (is(looseObject({ external: looseObject({ notify: fn() }) }), w)) {\n    w.external.notify(message);\n    return E.right(undefined);\n  }\n\n  // Otherwise, the current environment is unknown, and we are not able to send event.\n  return E.left(new UnknownEnvError());\n}\n","import { signal } from '@tma.js/signals';\nimport {\n  BetterTaskEither,\n  type If,\n  type IsNever,\n  createCbCollector,\n  throwifyAnyEither,\n} from '@tma.js/toolkit';\nimport { BetterPromise } from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { on } from '@/events/emitter.js';\nimport type { EventName, EventPayload } from '@/events/types/index.js';\nimport { postEventFp } from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithRequiredParams,\n  MethodNameWithoutParams,\n  MethodParams,\n} from '@/methods/types/index.js';\n\nimport type {\n  RequestCaptureEventFn,\n  RequestCaptureEventsFn,\n  RequestCaptureFn,\n  RequestError,\n  RequestFpOptions,\n  RequestOptions,\n  RequestCaptureFnEventsPayload,\n} from './request.js';\n\ntype AnyEventName = EventName | EventName[];\n\nexport type Request2Error = RequestError;\nexport type Request2CaptureEventsFn<E extends EventName[]> = RequestCaptureEventsFn<E>;\nexport type Request2CaptureEventFn<E extends EventName> = RequestCaptureEventFn<E>;\nexport type Request2CaptureFn<E extends AnyEventName> = RequestCaptureFn<E>;\nexport type Request2Options<E extends AnyEventName> = RequestOptions<E>;\nexport type Request2FpOptions<E extends AnyEventName> = RequestFpOptions<E>;\nexport type Request2CaptureFnEventsPayload<E extends EventName[]> =\n  RequestCaptureFnEventsPayload<E>;\nexport type Request2Result<E extends AnyEventName> =\n  E extends (infer U extends EventName)[]\n    ? U extends infer K extends EventName\n      ? { event: K; payload: If<IsNever<EventPayload<K>>, undefined, EventPayload<K>> }\n      : never\n    : E extends EventName\n      ? If<IsNever<EventPayload<E>>, undefined, EventPayload<E>>\n      : never;\n\nexport type Request2Fn = typeof request2;\nexport type Request2FpFn = typeof request2Fp;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request2Fp<\n  M extends MethodNameWithRequiredParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options: Request2FpOptions<E> & { params: MethodParams<M> },\n): TE.TaskEither<Request2Error | AbortError, Request2Result<E>>;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request2Fp<\n  M extends MethodNameWithOptionalParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2FpOptions<E> & { params?: MethodParams<M> },\n): TE.TaskEither<Request2Error | AbortError, Request2Result<E>>;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request2Fp<\n  M extends MethodNameWithoutParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2FpOptions<E>,\n): TE.TaskEither<Request2Error | AbortError, Request2Result<E>>;\n\nexport function request2Fp<\n  M extends MethodName,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options: Request2FpOptions<E> & { params?: MethodParams<M> } = {},\n): TE.TaskEither<Request2Error | AbortError, Request2Result<E>> {\n  const {\n    // If no capture function was passed, we capture the first compatible event.\n    capture = () => true,\n    postEvent = postEventFp,\n  } = options;\n\n  // TODO: Maybe we want to rewrite it using a simple BetterPromise.\n\n  const result = signal<undefined | [Request2Result<E>]>();\n  const [addCleanup, cleanup] = createCbCollector();\n  // Iterate over all the tracked events and add a listener, checking if the event should be\n  // captured.\n  (Array.isArray(eventOrEvents) ? eventOrEvents : [eventOrEvents]).forEach(event => {\n    // Each event listener waits for the event to occur.\n    // Then, if the capture function was passed, we should check if the event should\n    // be captured. If the function is omitted, we instantly capture the event.\n    addCleanup(\n      on(event, payload => {\n        const isEventsArray = Array.isArray(eventOrEvents);\n        if (\n          isEventsArray\n            ? (capture as Request2CaptureEventsFn<EventName[]>)({ event, payload })\n            : (capture as Request2CaptureEventFn<EventName>)(payload)\n        ) {\n          result.set([\n            (isEventsArray ? { event, payload } : payload) as Request2Result<E>,\n          ]);\n        }\n      }),\n    );\n  });\n  const withCleanup = <T>(value: T): T => {\n    cleanup();\n    return value;\n  };\n\n  return pipe(\n    async () => postEvent(method as any, (options as any).params),\n    TE.chainW(() => {\n      return BetterTaskEither<AbortError, Request2Result<E>>((resolve, _, context) => {\n        // When creating this BetterTaskEither, we could already have a value stored in\n        // the result signal. For example, when tracked events were generated via emitEvent in\n        // mockTelegramEnv.onEvent.\n        const data = result();\n        if (data) {\n          return resolve(data[0]);\n        }\n\n        const listener = (data: [Request2Result<E>] | undefined) => {\n          if (data) {\n            resolve(data[0]);\n          }\n        };\n        const unsub = () => {\n          result.unsub(listener);\n        };\n        result.sub(listener);\n        context.on('finalized', unsub);\n      }, options);\n    }),\n    TE.mapBoth(withCleanup, withCleanup),\n  );\n}\n\n/**\n * @see request2Fp\n */\nexport function request2<M extends MethodNameWithRequiredParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options: Request2Options<E> & { params: MethodParams<M> },\n): BetterPromise<Request2Result<E>>;\n\n/**\n * @see request2Fp\n */\nexport function request2<M extends MethodNameWithOptionalParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2Options<E> & { params?: MethodParams<M> },\n): BetterPromise<Request2Result<E>>;\n\n/**\n * @see request2Fp\n */\nexport function request2<M extends MethodNameWithoutParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2Options<E>,\n): BetterPromise<Request2Result<E>>;\n\nexport function request2<M extends MethodName, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2Options<E> & { params?: MethodParams<M> },\n): BetterPromise<Request2Result<E>> {\n  const { postEvent } = options || {};\n\n  return throwifyAnyEither(\n    // @ts-expect-error TypeScript will not be able to handle our overrides here.\n    request2Fp(method, eventOrEvents, {\n      ...options,\n      postEvent: postEvent\n        ? (...args: any[]) => {\n          try {\n            // @ts-expect-error TypeScript will not be able to handle our overrides here.\n            postEvent(...args);\n            return E.right(undefined);\n          } catch (e) {\n            return E.left(e);\n          }\n        }\n        : postEventFp,\n    }),\n  );\n}\n","import {\n  type MethodName,\n  supports,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@tma.js/bridge';\nimport { type Computed, computed } from '@tma.js/signals';\nimport type {\n  If,\n  IsNever,\n  AnyFnAnyEither,\n  RightOfReturn,\n  LeftOfReturn,\n  MaybeMonadReturnTypeToCommon,\n  MaybeCommonReturnTypeToMonad,\n  AnyFn,\n} from '@tma.js/toolkit';\nimport type { Version } from '@tma.js/types';\nimport * as E from 'fp-ts/Either';\nimport * as O from 'fp-ts/Option';\nimport * as TE from 'fp-ts/TaskEither';\n\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\n\ntype IfReturnsTask<Fn extends AnyFnAnyEither, A, B> =\n  ReturnType<Fn> extends TE.TaskEither<any, any> ? A : B;\n\ntype OptionsBasedRequires<O extends WithChecksOptions<any>> = O extends { requires: any }\n  ? true : false;\n\ntype OptionsBasedSupports<O extends WithChecksOptions<any>> = O extends { supports: any }\n  ? Extract<keyof O['supports'], string> : never;\n\ntype OptionsBasedFn<Opts extends WithChecksOptions<any>> = (...args: any[]) => (\n  Opts['returns'] extends 'plain'\n    ? any\n    : Opts['returns'] extends 'promise'\n      ? PromiseLike<any>\n      : Opts['returns'] extends 'task'\n        ? TE.TaskEither<any, any>\n        : E.Either<any, any>\n);\n\n/**\n * @returns Error text if something is wrong.\n */\nexport type CustomSupportFn = () => string | undefined;\n\nexport type Require =\n  | MethodName\n  | CustomSupportFn\n  | { every: (MethodName | CustomSupportFn)[] }\n  | { some: (MethodName | CustomSupportFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type SupportsMap<Args extends any[]> = {\n  [OptionName: string]: {\n    [M in MethodNameWithVersionedParams]: {\n      /**\n       * Method name.\n       * @example 'web_app_set_header_color'\n       */\n      method: M;\n      /**\n       * Method version-dependent parameter.\n       * @example `color`\n       */\n      param: MethodVersionedParams<M>;\n      /**\n       * @returns True if the support function should be called.\n       * @param args - function arguments.\n       */\n      shouldCheck: (...args: Args) => boolean;\n    };\n  }[MethodNameWithVersionedParams];\n};\n\ntype WrappedFnReturnType<Fn extends AnyFn> = ReturnType<Fn> extends E.Either<any, any>\n  ? E.Either<FunctionUnavailableError | LeftOfReturn<Fn>, RightOfReturn<Fn>>\n  : ReturnType<Fn> extends TE.TaskEither<any, any>\n    ? TE.TaskEither<FunctionUnavailableError | LeftOfReturn<Fn>, RightOfReturn<Fn>>\n    : ReturnType<Fn> extends PromiseLike<infer U>\n      ? TE.TaskEither<FunctionUnavailableError, U>\n      : E.Either<FunctionUnavailableError, ReturnType<Fn>>;\n\nexport type WrappedFn<Fn extends AnyFn> = (...args: Parameters<Fn>) => WrappedFnReturnType<Fn>;\n\nexport type WithChecksFp<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsMapKeySchema extends string = never,\n> =\n  & WrappedFn<Fn>\n  & {\n  /**\n   * A signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized (if this requirement is specified).\n   * 3. If passed, the `isSupported` signal returned true.\n   * 4. If passed, the `isMounted` signal returned true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (backButton.show.isAvailable()) {\n   *   backButton.show();\n   * }\n   */\n    isAvailable: Computed<boolean>;\n    /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is available for call.\n   * @example\n   * backButton.show.ifAvailable();\n   */\n    ifAvailable(...args: Parameters<Fn>): O.Option<MaybeCommonReturnTypeToMonad<Fn>>;\n  }\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (backButton.show.isSupported()) {\n   *   console.log('The method is supported');\n   * }\n   */\n    isSupported: Computed<boolean>;\n  }, {}>\n  & If<IsNever<SupportsMapKeySchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (miniApp.setHeaderColor.isAvailable()) {\n   *   if (miniApp.setHeaderColor.supports('rgb')) {\n   *     miniApp.setHeaderColor('#ffaabb');\n   *   } else {\n   *     miniApp.setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n    supports: (key: SupportsMapKeySchema) => boolean;\n  }>;\n\nexport type WithChecks<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsMapKeySchema extends string = never,\n> =\n  & ((...args: Parameters<Fn>) => MaybeMonadReturnTypeToCommon<Fn>)\n  & Omit<WithChecksFp<Fn, HasSupportCheck, SupportsMapKeySchema>, 'ifAvailable'>\n  & {\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is available for call.\n   * @example\n   * backButton.show.ifAvailable();\n   */\n    ifAvailable(...args: Parameters<Fn>):\n      | { ok: true; data: MaybeMonadReturnTypeToCommon<Fn> }\n      | { ok: false };\n  };\n\nexport interface WithChecksOptions<Fn extends AnyFn> {\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * A value determining the function requirements. This will enable additional checks for\n   * the function before being called.\n   */\n  requires?: Require;\n  /**\n   * A signal to retrieve the current Telegram Mini Apps version or the value itself.\n   */\n  isTma: MaybeAccessor<boolean>;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: SupportsMap<Parameters<Fn>>;\n  /**\n   * A signal to retrieve the current Telegram Mini Apps version or the value itself.\n   */\n  version?: MaybeAccessor<Version>;\n  /**\n   * Allows to determine what exactly should be returned from the function - TaskEither or Either.\n   * There is no other way to know it until the function itself is called, but we need to perform\n   * some checks before calling it and return a valid value based on the function return type.\n   */\n  returns: Fn extends AnyFnAnyEither\n    ? IfReturnsTask<Fn, 'task', 'either'>\n    : ReturnType<Fn> extends PromiseLike<any> ? 'promise' : 'plain';\n}\n\nexport function withChecksFp<Fn extends AnyFn, O extends WithChecksOptions<Fn>>(\n  fn: Fn,\n  options: O,\n): WithChecksFp<Fn, OptionsBasedRequires<O>, OptionsBasedSupports<O>> {\n  const version = computed(() => access(options.version) || '100');\n  const isTma = computed(() => access(options.isTma));\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const { requires: optionsIsSupported, returns } = options;\n  const isSupportedSimplified = optionsIsSupported\n    ? typeof optionsIsSupported === 'object'\n      ? optionsIsSupported\n      : { every: [optionsIsSupported] }\n    : undefined;\n\n  /**\n   * @param optionName - target option.\n   * @returns True if specified option is supported.\n   */\n  const isOptionSupported = (optionName: string): boolean => {\n    if (!options.supports) {\n      return true;\n    }\n    const optionSettings = options.supports[optionName];\n    return supports(optionSettings.method, optionSettings.param, version());\n  };\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  const calculateSupportError = (): string | undefined => {\n    // isSupported was not specified. In this case, we assume that the function has no\n    // dependencies and is always supported.\n    if (!isSupportedSimplified) {\n      return;\n    }\n    const [mode, requirements] = 'every' in isSupportedSimplified\n      ? ['every', isSupportedSimplified.every] as const\n      : ['some', isSupportedSimplified.some] as const;\n\n    for (let i = 0; i < requirements.length; i++) {\n      const requirement = requirements[i];\n      const error = typeof requirement === 'function'\n        ? requirement()\n        : supports(requirement, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n      // Return only if there was an error and all requirements must be satisfied, or\n      // this was the last one requirement (when some of the requirements must be met).\n      if (error && (mode === 'every' || i === requirements.length - 1)) {\n        return error;\n      }\n    }\n  };\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  const calculateOptionSupportError = (\n    ...args: Parameters<Fn>\n  ): string | undefined => {\n    for (const k in options.supports) {\n      if (options.supports[k].shouldCheck(...args) && !isOptionSupported(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  };\n\n  const isSupported = computed(() => !calculateSupportError());\n  const isInitialized = computed(() => version() !== '0.0');\n  const isMounted = computed(() => (options.isMounted ? options.isMounted() : true));\n  const isAvailable = computed(\n    () => isTma()\n      && isInitialized()\n      && isSupported()\n      && isMounted(),\n  );\n\n  const wrapError = (message: string): WrappedFnReturnType<Fn> => {\n    const err = new FunctionUnavailableError(message);\n    return (['task', 'promise'].includes(options.returns)\n      ? TE.left(err)\n      : E.left(err)) as WrappedFnReturnType<Fn>;\n  };\n\n  const call = (...args: Parameters<Fn>): MaybeCommonReturnTypeToMonad<Fn> => {\n    if (returns === 'plain') {\n      return E.tryCatch(() => fn(...args), e => e) as MaybeCommonReturnTypeToMonad<Fn>;\n    }\n    if (returns === 'promise') {\n      return TE.tryCatch(() => fn(...args), e => e) as MaybeCommonReturnTypeToMonad<Fn>;\n    }\n    return fn(...args);\n  };\n\n  return Object.assign(\n    (...args: Parameters<Fn>): WrappedFnReturnType<Fn> => {\n      const errMessagePrefix = 'Unable to call function:';\n      if (!isTma()) {\n        return wrapError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!isInitialized()) {\n        return wrapError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = calculateSupportError();\n      if (supportErr) {\n        return wrapError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = calculateOptionSupportError(...args);\n      if (supportsOptionErr) {\n        return wrapError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!isMounted()) {\n        const message = options.isMounting?.()\n          ? 'mounting. Wait for the mount completion'\n          : 'unmounted. Use the mount() method';\n        return wrapError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return call(...args) as WrappedFnReturnType<Fn>;\n    },\n    fn,\n    {\n      isAvailable,\n      ifAvailable(...args: Parameters<Fn>): O.Option<MaybeCommonReturnTypeToMonad<Fn>> {\n        return isAvailable() ? O.some(call(...args)) : O.none;\n      },\n    },\n    isSupportedSimplified ? { isSupported } : {},\n    options.supports ? { supports: isOptionSupported } : {},\n  );\n}\n\nexport function createWithChecksFp<O extends WithChecksOptions<any>>(options: O) {\n  return <Fn extends OptionsBasedFn<O>>(fn: Fn): WithChecksFp<\n    Fn,\n    OptionsBasedRequires<O>,\n    OptionsBasedSupports<O>\n  > => withChecksFp(fn, options);\n}\n","import { throwifyAnyEither } from '@tma.js/toolkit';\nimport {\n  BetterPromise,\n  type BetterPromiseOptions,\n  TimeoutError,\n} from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { UnknownEnvError } from '@/errors.js';\nimport { retrieveRawLaunchParamsFp } from '@/launch-params.js';\nimport { type Request2Error, request2Fp } from '@/utils/request2.js';\n\nexport type isTMAError = Exclude<Request2Error, TimeoutError>;\n\n/**\n * @see isTMAFp\n */\nexport function isTMA(): boolean;\n/**\n * @see isTMAFp\n */\nexport function isTMA(type: 'complete', options?: BetterPromiseOptions): BetterPromise<boolean>;\nexport function isTMA(\n  type?: 'complete',\n  options?: BetterPromiseOptions,\n): boolean | BetterPromise<boolean> {\n  const monad = isTMAFp(\n    // @ts-expect-error TS doesn't get what override we are going to use.\n    type,\n    options,\n  ) as boolean | TE.TaskEither<isTMAError, boolean>;\n  return typeof monad === 'function'\n    ? BetterPromise.fn(() => throwifyAnyEither(monad))\n    : monad;\n}\n\n/**\n * Returns true if the current environment is Telegram Mini Apps.\n *\n * It uses the `retrieveLaunchParams` function to determine if the environment\n * contains launch parameters. In case it does, true will be returned.\n *\n * In case you need stricter checks, use async override of this function.\n */\nexport function isTMAFp(): boolean;\n/**\n * Returns promise with true if the current environment is Telegram Mini Apps.\n *\n * First of all, it checks if the current environment contains traits specific\n * to the Mini Apps environment. Then, it attempts to call a Mini Apps method\n * and waits for a response to be received.\n *\n * In case you need less strict checks, use sync override of this function.\n */\nexport function isTMAFp(\n  type: 'complete',\n  options?: BetterPromiseOptions,\n): TE.TaskEither<isTMAError, boolean>;\nexport function isTMAFp(\n  type?: 'complete',\n  options?: BetterPromiseOptions,\n): boolean | TE.TaskEither<isTMAError, boolean> {\n  const hasProxy = hasWebviewProxy(window);\n  if (!type) {\n    return hasProxy || pipe(retrieveRawLaunchParamsFp(), E.match(() => false, () => true));\n  }\n  if (hasProxy) {\n    return TE.right(true);\n  }\n  const { timeout = 100 } = options || {};\n\n  return pipe(\n    request2Fp('web_app_request_theme', 'theme_changed', { ...options, timeout }),\n    TE.match(\n      error => (\n        TimeoutError.is(error) || UnknownEnvError.is(error)\n          ? E.right(false)\n          : E.left(error)\n      ),\n      () => E.right(true),\n    ),\n  );\n}\n","import { setStorageValue } from '@tma.js/toolkit';\nimport {\n  miniAppsMessage,\n  parseLaunchParamsQuery,\n  pipeJsonToSchema,\n  serializeLaunchParamsQuery,\n  type LaunchParamsLike,\n} from '@tma.js/transformers';\nimport { parse } from 'valibot';\n\nimport { isIframe } from '@/env/isIframe.js';\nimport { InvalidLaunchParamsError } from '@/errors.js';\nimport { logger, postMessageImpl } from '@/globals.js';\nimport type { MethodName, MethodParams } from '@/methods/types/index.js';\n\n/**\n * Mocks the environment and imitates Telegram Mini Apps behavior.\n *\n * We usually use this function in the following cases:\n * 1. We are developing an application outside the Telegram environment and would like to imitate\n * the Telegram client in order to re-create the same communication behavior.\n * 2. We would like to intercept some Telegram Mini Apps methods' calls in order to enhance them\n * or write a custom behavior. It is extremely useful in some Telegram clients improperly handling\n * Mini Apps methods' calls and not even responding.\n *\n * Note that calling this function in Telegram web clients, the `postMessageImplementation` signal\n * value will be updated with a new one, enhancing previously set signal value to allow wrapping\n * the original `window.parent.postMessage` function. In other words, calling `mockTelegramEnv`\n * function N times, you will effectively wrap previously set implementation N times, so be\n * careful calling this function several times during a single lifecycle of the app. In case you\n * would like to avoid such kind of behavior, use the `resetPostMessage` option.\n */\nexport function mockTelegramEnv({ launchParams, onEvent, resetPostMessage }: {\n  /**\n   * Launch parameters to mock. They will be saved in the storage, so the SDK functions could\n   * retrieve them.\n   *\n   * Note that this value must have `tgWebAppData` presented in a raw format as long as you will\n   * need it when retrieving init data in this format. Otherwise, init data may be broken.\n   */\n  launchParams?:\n    | (Omit<LaunchParamsLike, 'tgWebAppData'> & { tgWebAppData?: string | URLSearchParams })\n    | string\n    | URLSearchParams;\n  /**\n   * Function that will be called if a Mini Apps method call was requested by the mini app.\n   *\n   * It receives a Mini Apps method name along with the passed payload.\n   *\n   * Note that using the `next` function, in non-web environments it uses the\n   * `window.TelegramWebviewProxy.postEvent` method.\n   *\n   * Talking about the web versions of Telegram, the value of `next` is a bit more complex - it\n   * will be equal to the value stored in the `postMessageImpl` signal set previously. By default,\n   * this value contains a function utilizing the `window.parent.postMessage` method.\n   * @param event - event information.\n   * @param next - function to call the original method used to call a Mini Apps method.\n   */\n  onEvent?: (\n    event:\n      | { [M in MethodName]: { name: M; params: MethodParams<M> } }[MethodName]\n      | { name: string; params: unknown },\n    next: () => void,\n  ) => void;\n  /**\n   * Removes all previously set enhancements of the `window.parent.postMessage` function set\n   * by other `mockTelegramEnv` calls.\n   * @default false\n   */\n  resetPostMessage?: boolean;\n} = {}): void {\n  if (launchParams) {\n    // If launch parameters were passed, save them in the session storage, so\n    // the retrieveLaunchParams function would return them.\n    const launchParamsQuery =\n      typeof launchParams === 'string' || launchParams instanceof URLSearchParams\n        ? launchParams.toString()\n        : (\n          // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n          // value. We are doing it because we are working with tgWebAppData presented as a\n          // string, not an object as serializeLaunchParamsQuery requires.\n          serializeLaunchParamsQuery({ ...launchParams, tgWebAppData: undefined })\n          // Then, we just append init data.\n          + (launchParams.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(launchParams.tgWebAppData.toString())}` : '')\n        );\n\n    // Remember to check if launch params are valid.\n    try {\n      parseLaunchParamsQuery(launchParamsQuery);\n    } catch (e) {\n      throw new InvalidLaunchParamsError(launchParamsQuery, e);\n    }\n    setStorageValue('launchParams', launchParamsQuery);\n  }\n\n  // Original postEvent firstly checks if the current environment is iframe.\n  // That's why we have a separate branch for this environment here too.\n  if (isIframe()) {\n    if (!onEvent) {\n      return;\n    }\n    // As long as the postEvent function uses the postMessage method, we should rewire it.\n    if (resetPostMessage) {\n      postMessageImpl.reset();\n    }\n\n    const original = postMessageImpl();\n    postMessageImpl.set((...args) => {\n      const [message] = args;\n      const next = () => {\n        (original as any)(...args);\n      };\n\n      // Pass only Telegram Mini Apps events to the handler. All other calls should be passed\n      // to the original handler (window.parent.postMessage likely).\n      try {\n        const data = parse(pipeJsonToSchema(miniAppsMessage()), message);\n        onEvent({ name: data.eventType, params: data.eventData }, next);\n      } catch {\n        next();\n      }\n    });\n    return;\n  }\n\n  // In all other environments, it is enough to define window.TelegramWebviewProxy.postEvent.\n  const proxy = (window as any).TelegramWebviewProxy || {};\n  const postEventDefaulted = proxy.postEvent || (() => undefined);\n  (window as any).TelegramWebviewProxy = {\n    ...proxy,\n    postEvent(eventType: string, eventData: string) {\n      const next = () => {\n        postEventDefaulted(eventType, eventData);\n      };\n      onEvent\n        ? onEvent({\n          name: eventType,\n          params: eventData ? JSON.parse(eventData) : undefined,\n        }, next)\n        : next();\n    },\n  };\n\n  logger().log('Environment was mocked by the mockTelegramEnv function');\n}\n","import type { PostEventError, MethodName, MethodParams } from '@tma.js/bridge';\nimport { computed, type Computed } from '@tma.js/signals';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { removeUndefined } from '@/helpers/removeUndefined.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  type WithChecksFp,\n  type WithChecks,\n  createWithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\ntype ButtonEither = E.Either<PostEventError, void>;\n\ntype BoolFields<S> = {\n  [K in keyof S]-?: S[K] extends boolean ? K : never;\n}[keyof S];\n\nexport interface ButtonOptions<S, M extends MethodName>\n  extends SharedFeatureOptions,\n  WithStateRestore<S>,\n  WithPostEvent,\n  WithVersion {\n  /**\n   * The initial button state.\n   */\n  initialState: S;\n  /**\n   * Removes a component click listener.\n   * @param listener - a listener to remove.\n   * @param once - should the listener be called only once.\n   */\n  offClick: (listener: VoidFunction, once?: boolean) => void;\n  /**\n   * Adds a component click listener.\n   * @returns A function to remove listener.\n   * @param listener - a listener to add.\n   * @param once - should the listener be called only once.\n   */\n  onClick: (listener: VoidFunction, once?: boolean) => VoidFunction;\n  /**\n   * A Mini Apps method to commit changes.\n   */\n  method: M;\n  /**\n   * A function to create method payload.\n   * @param state\n   */\n  payload: (state: S) => MethodParams<M>;\n}\n\nexport class Button<S extends object, M extends MethodName> {\n  constructor({\n    isTma,\n    storage,\n    onClick,\n    offClick,\n    initialState,\n    isPageReload,\n    postEvent,\n    payload,\n    method,\n    version,\n  }: ButtonOptions<S, M>) {\n    const stateful = new Stateful({\n      initialState,\n      onChange(state) {\n        storage.set(state);\n      },\n    });\n    const mountable = new Mountable<S>({\n      initialState,\n      isPageReload,\n      onMounted: stateful.setState,\n      restoreState: storage.get,\n    });\n\n    const wrapOptions = { version, requires: method, isTma };\n    const wrapSupportedPlain = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'plain',\n    });\n    const wrapMountedEither = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'either',\n      isMounted: mountable.isMounted,\n    });\n\n    this.isMounted = mountable.isMounted;\n    this.isSupported = createIsSupportedSignal(method, version);\n    this.state = stateful.state;\n\n    this.setStateFp = wrapMountedEither(state => {\n      const nextState = { ...this.state(), ...removeUndefined(state) };\n      if (!stateful.hasDiff(nextState)) {\n        return E.right(undefined);\n      }\n      return pipe(\n        postEvent(method as any, payload(nextState)),\n        E.map(() => {\n          stateful.setState(nextState);\n        }),\n      );\n    });\n    this.setState = throwifyWithChecksFp(this.setStateFp);\n    this.onClickFp = wrapSupportedPlain(onClick);\n    this.onClick = throwifyWithChecksFp(this.onClickFp);\n    this.offClickFp = wrapSupportedPlain(offClick);\n    this.offClick = throwifyWithChecksFp(this.offClickFp);\n    this.mountFp = wrapSupportedPlain(() => {\n      const nothing = () => undefined;\n      return pipe(mountable.mount(), E.match(nothing, nothing));\n    });\n    this.mount = throwifyWithChecksFp(this.mountFp);\n    this.unmount = mountable.unmount;\n    this.stateSetters = key => {\n      const wrapped = wrapMountedEither(value => {\n        return this.setStateFp({ [key]: value } as unknown as Partial<S>);\n      });\n      return [throwifyWithChecksFp(wrapped), wrapped];\n    };\n    this.stateBoolSetters = <K extends keyof S>(key: K) => {\n      const [, setFp] = this.stateSetters(key);\n      const setFalse = wrapMountedEither(() => setFp(false as S[K]));\n      const setTrue = wrapMountedEither(() => setFp(true as S[K]));\n      return [\n        [throwifyWithChecksFp(setFalse), setFalse],\n        [throwifyWithChecksFp(setTrue), setTrue],\n      ];\n    };\n  }\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Complete button state.\n   */\n  readonly state: Computed<S>;\n\n  /**\n   * @returns A computed based on the specified state and its related key.\n   * @param key - a key to use.\n   */\n  stateGetter<K extends keyof S>(key: K): Computed<S[K]> {\n    return computed(() => this.state()[key]);\n  }\n\n  /**\n   * @returns A setter with checks for the specified key.\n   * @param key\n   */\n  readonly stateSetters: <K extends keyof S>(key: K) => [\n    throwing: WithChecks<(value: S[K]) => void, true>,\n    fp: WithChecksFp<(value: S[K]) => ButtonEither, true>,\n  ];\n\n  /**\n   * @returns Setters with checks to set a specified boolean key.\n   * @param key\n   */\n  readonly stateBoolSetters: <K extends BoolFields<S>>(key: K) => [\n    setFalse: [\n      throwing: WithChecks<() => void, true>,\n      fp: WithChecksFp<() => ButtonEither, true>,\n    ],\n    setTrue: [\n      throwing: WithChecks<() => void, true>,\n      fp: WithChecksFp<() => ButtonEither, true>,\n    ],\n  ];\n\n  /**\n   * Updates the button state.\n   */\n  readonly setStateFp: WithChecksFp<(state: Partial<S>) => ButtonEither, true>;\n\n  /**\n   * @see setStateFp\n   */\n  readonly setState: WithChecks<(state: Partial<S>) => void, true>;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * @see onClickFp\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => void,\n    true\n  >;\n\n  /**\n   * @see offClickFp\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, true>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v6.1\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   *\n   * Note that this function does not remove listeners added via the `onClick`\n   * function, so you have to remove them on your own.\n   * @see onClick\n   */\n  readonly unmount: () => void;\n}\n","type CaptureSameReqFn = (payload: { req_id: string }) => boolean;\n\n/**\n * Returns a function which can be used in `request` function `capture` property to capture\n * the event with the same request identifier.\n * @param reqId - request identifier.\n */\nexport function captureSameReq(reqId: string): CaptureSameReqFn {\n  return ({ req_id }) => req_id === reqId;\n}\n","import { Version } from '@tma.js/types';\n\nimport {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\n\nconst releases = {\n  '6.0': [\n    'iframe_ready',\n    'iframe_will_reload',\n    'web_app_close',\n    'web_app_data_send',\n    'web_app_expand',\n    'web_app_open_link',\n    'web_app_ready',\n    'web_app_request_theme',\n    'web_app_request_viewport',\n    'web_app_setup_main_button',\n    'web_app_setup_closing_behavior',\n  ],\n  6.1: [\n    'web_app_open_tg_link',\n    'web_app_open_invoice',\n    'web_app_setup_back_button',\n    'web_app_set_background_color',\n    'web_app_set_header_color',\n    'web_app_trigger_haptic_feedback',\n  ],\n  6.2: ['web_app_open_popup'],\n  6.4: [\n    'web_app_close_scan_qr_popup',\n    'web_app_open_scan_qr_popup',\n    'web_app_read_text_from_clipboard',\n    { method: 'web_app_open_link', param: 'try_instant_view' },\n  ],\n  6.7: ['web_app_switch_inline_query'],\n  6.9: [\n    'web_app_invoke_custom_method',\n    'web_app_request_write_access',\n    'web_app_request_phone',\n    { method: 'web_app_set_header_color', param: 'color' },\n  ],\n  '6.10': ['web_app_setup_settings_button'],\n  7.2: [\n    'web_app_biometry_get_info',\n    'web_app_biometry_open_settings',\n    'web_app_biometry_request_access',\n    'web_app_biometry_request_auth',\n    'web_app_biometry_update_token',\n  ],\n  7.6: [\n    { method: 'web_app_open_link', param: 'try_browser' },\n    { method: 'web_app_close', param: 'return_back' },\n  ],\n  7.7: ['web_app_setup_swipe_behavior'],\n  7.8: ['web_app_share_to_story'],\n  '7.10': [\n    'web_app_setup_secondary_button',\n    'web_app_set_bottom_bar_color',\n    { method: 'web_app_setup_main_button', param: 'has_shine_effect' },\n  ],\n  '8.0': [\n    'web_app_request_safe_area',\n    'web_app_request_content_safe_area',\n    'web_app_request_fullscreen',\n    'web_app_exit_fullscreen',\n    'web_app_set_emoji_status',\n    'web_app_add_to_home_screen',\n    'web_app_check_home_screen',\n    'web_app_request_emoji_status_access',\n    'web_app_check_location',\n    'web_app_open_location_settings',\n    'web_app_request_file_download',\n    'web_app_request_location',\n    'web_app_send_prepared_message',\n    'web_app_start_accelerometer',\n    'web_app_start_device_orientation',\n    'web_app_start_gyroscope',\n    'web_app_stop_accelerometer',\n    'web_app_stop_device_orientation',\n    'web_app_stop_gyroscope',\n    'web_app_toggle_orientation_lock',\n  ],\n  '9.0': [\n    'web_app_device_storage_clear',\n    'web_app_device_storage_get_key',\n    'web_app_device_storage_save_key',\n    'web_app_secure_storage_clear',\n    'web_app_secure_storage_get_key',\n    'web_app_secure_storage_restore_key',\n    'web_app_secure_storage_save_key',\n  ],\n  9.1: ['web_app_hide_keyboard'],\n};\n\n/**\n * @returns Version of the specified method parameter release. Returns `null`\n * if passed method or parameter are unknown.\n * @param method - method name\n * @param param - method parameter\n */\nexport function getReleaseVersion<M extends MethodNameWithVersionedParams>(\n  method: M,\n  param: MethodVersionedParams<M>,\n): Version | null;\n\n/**\n * @returns Version of the specified method release. Returns `null`\n * if passed method is unknown.\n * @param method - method name.\n */\nexport function getReleaseVersion(method: MethodName): Version | null;\nexport function getReleaseVersion(method: MethodName, param?: string): Version | null {\n  const versions = Object.keys(releases) as (`${keyof typeof releases}`)[];\n  return versions.find(version => {\n    return releases[version].some(item => {\n      if (param) {\n        return typeof item === 'object'\n          && item.method === method\n          && item.param === param;\n      }\n      return item === method;\n    });\n  }) || null;\n}\n","import type { Version } from '@tma.js/types';\n\nfunction parts(a: Version): number[] {\n  return a.split('.').map(Number);\n}\n\n/**\n * @param a - first version.\n * @param b - second version.\n * @returns\n * - `1` if the version \"a\" is greater than \"b\".\n * - `0` the version \"a\" is equal to \"b\".\n * - `-1` the version \"a\" is lower than \"b\".\n */\nexport function compareVersions(a: Version, b: Version): number {\n  const aParts = parts(a);\n  const bParts = parts(b);\n  const len = Math.max(aParts.length, bParts.length);\n\n  // Iterate over each part of versions and compare them. In case, part is\n  // missing, assume its value is equal to 0.\n  for (let i = 0; i < len; i += 1) {\n    const aVal = aParts[i] || 0;\n    const bVal = bParts[i] || 0;\n\n    if (aVal === bVal) {\n      continue;\n    }\n    return aVal > bVal ? 1 : -1;\n  }\n  return 0;\n}\n","import type { Version } from '@tma.js/types';\n\nimport { getReleaseVersion } from '@/methods/getReleaseVersion.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\nimport { compareVersions } from '@/utils/compareVersions.js';\n\n/**\n * Returns true in case, passed parameter in specified method is supported.\n * @param method - method name\n * @param param - method parameter\n * @param inVersion - platform version.\n */\nexport function supports<M extends MethodNameWithVersionedParams>(\n  method: M,\n  param: MethodVersionedParams<M>,\n  inVersion: Version,\n): boolean;\n\n/**\n * Returns true in case, specified method is supported in a passed version.\n * @param method - method name.\n * @param inVersion - platform version.\n */\nexport function supports(method: MethodName, inVersion: Version): boolean;\n\nexport function supports(\n  method: MethodName,\n  paramOrVersion: Version | string,\n  inVersion?: string,\n): boolean {\n  const version = inVersion\n    ? getReleaseVersion(\n      method as MethodNameWithVersionedParams,\n      paramOrVersion as MethodVersionedParams<MethodNameWithVersionedParams>,\n    )\n    : getReleaseVersion(method);\n  return version\n    ? compareVersions(version, inVersion || paramOrVersion) <= 0\n    : false;\n}\n","import type { Version } from '@tma.js/types';\nimport { any, is, looseObject } from 'valibot';\n\nimport { MethodParameterUnsupportedError, MethodUnsupportedError } from '@/errors.js';\nimport { logger } from '@/globals.js';\nimport { type PostEventFn, postEvent } from '@/methods/postEvent.js';\nimport { supports } from '@/methods/supports.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\n\nexport type OnUnsupportedFn = (\n  data: { version: Version } & (\n    | { method: MethodName }\n    | {\n      [M in MethodNameWithVersionedParams]: {\n        method: M;\n        param: MethodVersionedParams<M>;\n      };\n    }[MethodNameWithVersionedParams]),\n) => void;\n\nexport type CreatePostEventMode = 'strict' | 'non-strict';\n\n/**\n * Creates a function that checks if the specified method and parameters are supported.\n *\n * If the method or parameters are unsupported, the `onUnsupported` function will be called.\n *\n * If `strict` or `non-strict` value was passed as the second argument, the function\n * will create its own `onUnsupported` function with behavior depending on the value passed.\n *\n * - Passing `strict` will make the function to throw a `MethodParameterUnsupportedError`\n * or a `MethodUnsupportedError` error.\n * - Passing `non-strict` will just warn you about something being unsupported.\n *\n * @param version - Telegram Mini Apps version.\n * @param onUnsupportedOrMode - function or strict mode. Default: `strict`\n */\nexport function createPostEvent(\n  version: Version,\n  onUnsupportedOrMode: OnUnsupportedFn | CreatePostEventMode = 'strict',\n): PostEventFn {\n  const onUnsupported: OnUnsupportedFn = typeof onUnsupportedOrMode === 'function'\n    ? onUnsupportedOrMode\n    : data => {\n      const { method, version } = data;\n      const error = 'param' in data\n        ? new MethodParameterUnsupportedError(method, data.param, version)\n        : new MethodUnsupportedError(method, version);\n\n      if (onUnsupportedOrMode === 'strict') {\n        throw error;\n      }\n      return logger().forceWarn(error.message);\n    };\n\n  return ((method: any, params: any) => {\n    // Firstly, check if the method is supported.\n    if (!supports(method, version)) {\n      return onUnsupported({ version, method });\n    }\n\n    // Method could use parameters, which are supported only in specific versions of Mini Apps.\n    // We are validating only those parameters, which are not backward compatible.\n    if (\n      method === 'web_app_set_header_color'\n      && is(looseObject({ color: any() }), params)\n      && !supports(method, 'color', version)\n    ) {\n      return onUnsupported({ version, method, param: 'color' });\n    }\n\n    return postEvent(method, params);\n  }) as PostEventFn;\n}\n","import { BetterPromise } from 'better-promises';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { InvokeCustomMethodFailedError } from '@/errors.js';\nimport { captureSameReq } from '@/methods/captureSameReq.js';\nimport type { CustomMethodName, CustomMethodParams } from '@/methods/types/index.js';\n\nimport {\n  request2Fp,\n  type Request2Error,\n  type Request2FpOptions,\n  type Request2Options,\n} from './request2.js';\n\nexport type InvokeCustomMethodError = Request2Error | InvokeCustomMethodFailedError;\n\nexport type InvokeCustomMethodOptions = Omit<Request2Options<'custom_method_invoked'>, 'capture'>;\nexport type InvokeCustomMethodFn = typeof invokeCustomMethod;\n\nexport type InvokeCustomMethodFpOptions = Omit<Request2FpOptions<'custom_method_invoked'>, 'capture'>;\nexport type InvokeCustomMethodFpFn = typeof invokeCustomMethodFp;\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n */\nexport function invokeCustomMethodFp<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  requestId: string,\n  options?: InvokeCustomMethodFpOptions,\n): TE.TaskEither<InvokeCustomMethodError, unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n */\nexport function invokeCustomMethodFp(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodFpOptions,\n): TE.TaskEither<Request2Error, unknown>;\n\nexport function invokeCustomMethodFp(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodFpOptions,\n): TE.TaskEither<InvokeCustomMethodError, unknown> {\n  return pipe(\n    request2Fp('web_app_invoke_custom_method', 'custom_method_invoked', {\n      ...options || {},\n      params: { method, params, req_id: requestId },\n      capture: captureSameReq(requestId),\n    }),\n    TE.chain(({ result, error }) => {\n      return error\n        ? TE.left(new InvokeCustomMethodFailedError(error))\n        : TE.right(result);\n    }),\n  );\n}\n\n/**\n * @see invokeCustomMethodFp\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): BetterPromise<unknown>;\n\n/**\n * @see invokeCustomMethodFp\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): BetterPromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): BetterPromise<unknown> {\n  return BetterPromise.fn(() => {\n    return pipe(\n      // @ts-expect-error TypeScript is unable to determine required override.\n      invokeCustomMethodFp(method, params, requestId, options),\n      TE.match(\n        error => {\n          throw error;\n        },\n        result => result,\n      ),\n    )();\n  });\n}\n","import type { PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport * as E from 'fp-ts/Either';\n\nimport { Button, type ButtonOptions } from '@/composables/Button.js';\nimport type { WithChecksFp, WithChecks } from '@/with-checks/withChecksFp.js';\n\nexport interface BackButtonState {\n  isVisible: boolean;\n}\n\nexport type BackButtonOptions = Omit<\n  ButtonOptions<BackButtonState, 'web_app_setup_back_button'>,\n  'method' | 'payload' | 'initialState'\n>;\n\n/**\n * @since Mini Apps v6.1\n */\nexport class BackButton {\n  constructor(options: BackButtonOptions) {\n    const button = new Button({\n      ...options,\n      method: 'web_app_setup_back_button',\n      payload: state => ({ is_visible: state.isVisible }),\n      initialState: { isVisible: false },\n    });\n\n    this.isVisible = button.stateGetter('isVisible');\n    this.isMounted = button.isMounted;\n    this.isSupported = button.isSupported;\n    [[this.hide, this.hideFp], [this.show, this.showFp]] = button.stateBoolSetters('isVisible');\n    this.onClick = button.onClick;\n    this.onClickFp = button.onClickFp;\n    this.offClick = button.offClick;\n    this.offClickFp = button.offClickFp;\n    this.mount = button.mount;\n    this.mountFp = button.mountFp;\n    this.unmount = button.unmount;\n  }\n\n  /**\n   * Signal indicating if the component is currently visible.\n   */\n  readonly isVisible: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Hides the button.\n   * @since Mini Apps v6.1\n   */\n  readonly hideFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see hideFp\n   */\n  readonly hide: WithChecks<() => void, true>;\n\n  /**\n   * Shows the button.\n   * @since Mini Apps v6.1\n   */\n  readonly showFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<() => void, true>;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @since Mini Apps v6.1\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => VoidFunction,\n    true\n  >;\n\n  /**\n   * @see onClickFp\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @since Mini Apps v6.1\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => void,\n    true\n  >;\n\n  /**\n   * @see offClickFp\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, true>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v6.1\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   *\n   * Note that this function does not remove listeners added via the `onClick`\n   * function, so you have to remove them on your own.\n   * @see onClick\n   */\n  readonly unmount: () => void;\n}\n","import { signal } from '@tma.js/signals';\nimport {\n  createCbCollector,\n  throwifyAnyEither,\n  type If,\n  type IsNever,\n  BetterTaskEither,\n} from '@tma.js/toolkit';\nimport {\n  BetterPromise,\n  type BetterPromiseOptions,\n  type TimeoutError,\n} from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { on } from '@/events/emitter.js';\nimport type { EventName, EventPayload } from '@/events/types/index.js';\nimport {\n  postEventFp,\n  type PostEventError,\n  type PostEventFn,\n  type PostEventFpFn,\n} from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\n\ntype AnyEventName = EventName | EventName[];\n\nexport type RequestError = PostEventError | TimeoutError;\n\n/**\n * @example\n * { event: 'scan_qr_closed' }\n * @example\n * {\n *   event: 'popup_closed',\n *   payload: { button_id: 'ok' }\n * }\n */\nexport type RequestCaptureFnEventsPayload<E extends EventName[]> =\n  E extends (infer U extends EventName)[]\n    ? {\n      [K in U]: If<\n        IsNever<EventPayload<K>>,\n        { event: K },\n        { event: K; payload: EventPayload<K> }\n      >\n    }[U]\n    : never;\n\nexport type RequestCaptureEventsFn<E extends EventName[]> = (\n  payload: RequestCaptureFnEventsPayload<E>,\n) => boolean;\n\nexport type RequestCaptureEventFn<E extends EventName> = If<\n  IsNever<EventPayload<E>>,\n  () => boolean,\n  (payload: EventPayload<E>) => boolean\n>;\n\nexport type RequestCaptureFn<E extends AnyEventName> = E extends EventName[]\n  ? RequestCaptureEventsFn<E>\n  : E extends EventName\n    ? RequestCaptureEventFn<E>\n    : never;\n\nexport interface RequestOptions<E extends AnyEventName> extends Omit<RequestFpOptions<E>, 'postEvent'> {\n  /**\n   * Custom function to call mini apps methods.\n   */\n  postEvent?: PostEventFn;\n}\n\nexport type RequestResult<E extends AnyEventName> =\n  E extends (infer U extends EventName)[]\n    ? U extends infer K extends EventName\n      ? If<IsNever<EventPayload<K>>, undefined, EventPayload<K>>\n      : never\n    : E extends EventName\n      ? If<IsNever<EventPayload<E>>, undefined, EventPayload<E>>\n      : never;\n\nexport interface RequestFpOptions<E extends AnyEventName> extends Pick<\n  BetterPromiseOptions,\n  'abortSignal' | 'timeout'\n> {\n  /**\n   * A function that should return true if the event should be captured.\n   * The first compatible request will be captured if this property is omitted.\n   */\n  capture?: RequestCaptureFn<E>;\n  /**\n   * A custom function to call mini apps methods.\n   */\n  postEvent?: PostEventFpFn;\n}\n\nexport type RequestFn = typeof request;\nexport type RequestFpFn = typeof requestFp;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n * @deprecated To be removed in the next major update. Use `request2fp` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function requestFp<\n  M extends MethodNameWithRequiredParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options: RequestFpOptions<E> & { params: MethodParams<M> },\n): TE.TaskEither<RequestError | AbortError, RequestResult<E>>;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n * @deprecated To be removed in the next major update. Use `request2fp` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function requestFp<\n  M extends MethodNameWithOptionalParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestFpOptions<E> & { params?: MethodParams<M> },\n): TE.TaskEither<RequestError | AbortError, RequestResult<E>>;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n * @deprecated To be removed in the next major update. Use `request2fp` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function requestFp<\n  M extends MethodNameWithoutParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestFpOptions<E>,\n): TE.TaskEither<RequestError | AbortError, RequestResult<E>>;\n\nexport function requestFp<\n  M extends MethodName,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options: RequestFpOptions<E> & { params?: MethodParams<M> } = {},\n): TE.TaskEither<RequestError | AbortError, RequestResult<E>> {\n  const {\n    // If no capture function was passed, we capture the first compatible event.\n    capture = () => true,\n    postEvent = postEventFp,\n  } = options;\n\n  const result = signal<undefined | [RequestResult<E>]>();\n  const [addCleanup, cleanup] = createCbCollector();\n  // Iterate over all the tracked events and add a listener, checking if the event should be\n  // captured.\n  (Array.isArray(eventOrEvents) ? eventOrEvents : [eventOrEvents]).forEach(event => {\n    // Each event listener waits for the event to occur.\n    // Then, if the capture function was passed, we should check if the event should\n    // be captured. If the function is omitted, we instantly capture the event.\n    addCleanup(\n      on(event, payload => {\n        if (\n          Array.isArray(eventOrEvents)\n            ? (capture as RequestCaptureEventsFn<EventName[]>)({ event, payload })\n            : (capture as RequestCaptureEventFn<EventName>)(payload)\n        ) {\n          result.set([payload as RequestResult<E>]);\n        }\n      }),\n    );\n  });\n  const withCleanup = <T>(value: T): T => {\n    cleanup();\n    return value;\n  };\n\n  return pipe(\n    async () => postEvent(method as any, (options as any).params),\n    TE.chainW(() => {\n      return BetterTaskEither<AbortError, RequestResult<E>>((resolve, _, context) => {\n        // When creating this BetterTaskEither, we could already have a value stored in\n        // the result signal. For example, when tracked events were generated via emitEvent in\n        // mockTelegramEnv.onEvent.\n        const data = result();\n        if (data) {\n          return resolve(data[0]);\n        }\n\n        const listener = (data: [RequestResult<E>] | undefined) => {\n          if (data) {\n            resolve(data[0]);\n          }\n        };\n        const unsub = () => {\n          result.unsub(listener);\n        };\n        result.sub(listener);\n        context.on('finalized', unsub);\n      }, options);\n    }),\n    TE.mapBoth(withCleanup, withCleanup),\n  );\n}\n\n/**\n * @see requestFp\n * @deprecated To be removed in the next major update. Use `request2` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function request<M extends MethodNameWithRequiredParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options: RequestOptions<E> & { params: MethodParams<M> },\n): BetterPromise<RequestResult<E>>;\n\n/**\n * @see requestFp\n * @deprecated To be removed in the next major update. Use `request2` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function request<M extends MethodNameWithOptionalParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E> & { params?: MethodParams<M> },\n): BetterPromise<RequestResult<E>>;\n\n/**\n * @see requestFp\n * @deprecated To be removed in the next major update. Use `request2` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function request<M extends MethodNameWithoutParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E>,\n): BetterPromise<RequestResult<E>>;\n\nexport function request<M extends MethodName, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E> & { params?: MethodParams<M> },\n): BetterPromise<RequestResult<E>> {\n  const { postEvent } = options || {};\n\n  return throwifyAnyEither(\n    // @ts-expect-error TypeScript will not be able to handle our overrides here.\n    requestFp(method, eventOrEvents, {\n      ...options,\n      postEvent: postEvent\n        ? (...args: any[]) => {\n          try {\n            // @ts-expect-error TypeScript will not be able to handle our overrides here.\n            postEvent(...args);\n            return E.right(undefined);\n          } catch (e) {\n            return E.left(e);\n          }\n        }\n        : postEventFp,\n    }),\n  );\n}\n","/**\n * Applies polyfills required for stable work of the package:\n * - `Object.hasOwn` - used by `valibot`\n */\nexport function applyPolyfills(): void {\n  if (!Object.hasOwn) {\n    Object.hasOwn = function(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n  }\n}\n","import { throwifyFpFn } from '@tma.js/toolkit';\nimport * as E from 'fp-ts/Either';\n\nexport type DecodeBase64UrlError = DOMException;\n\n/**\n * Decodes a base-64-url ASCII string.\n * @param value - the value to decode.\n * @see Learn more about base64url:\n * https://herongyang.com/Encoding/Base64URL-Encoding-Algorithm.html\n * @see Source:\n * https://developer.mozilla.org/ru/docs/Glossary/Base64#solution_1__escaping_the_string_before_encoding_it\n */\nexport function decodeBase64UrlFp(value: string): E.Either<DecodeBase64UrlError, string> {\n  return E.tryCatch(() => {\n    return decodeURIComponent(\n      atob(\n        value\n          .replace(/-/g, '+')\n          .replace(/_/g, '/'),\n      )\n        .split('')\n        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n        .join(''),\n    );\n  }, e => e as DOMException);\n}\n\n/**\n * @see decodeBase64UrlFp\n */\nexport const decodeBase64Url = throwifyFpFn(decodeBase64UrlFp);\n\n/**\n * Creates a base-64-url encoded ASCII string from the passed value.\n * @param value - the value to encode.\n * @see Learn more about base64url:\n * https://herongyang.com/Encoding/Base64URL-Encoding-Algorithm.html\n * @see Source:\n * https://developer.mozilla.org/ru/docs/Glossary/Base64#solution_1__escaping_the_string_before_encoding_it\n */\nexport function encodeBase64Url(value: string): string {\n  // first we use encodeURIComponent to get percent-encoded UTF-8,\n  // then we convert the percent encodings into raw bytes which\n  // can be fed into btoa.\n  return btoa(\n    encodeURIComponent(value).replace(/%([0-9A-F]{2})/g, (_, p1) => {\n      return String.fromCharCode(parseInt(`0x${p1}`));\n    }),\n  )\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}\n","/**\n * @since 2.10.0\n */\nimport { tryCatch } from './Either';\nimport { identity } from './function';\n/**\n * Converts a JavaScript Object Notation (JSON) string into a `Json` type.\n *\n * @example\n * import * as J from 'fp-ts/Json'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('{\"a\":1}', J.parse), E.right({ a: 1 }))\n * assert.deepStrictEqual(pipe('{\"a\":}', J.parse), E.left(new SyntaxError(`Unexpected token '}', \"{\"a\":}\" is not valid JSON`)))\n *\n * @since 2.10.0\n */\nexport var parse = function (s) { return tryCatch(function () { return JSON.parse(s); }, identity); };\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import * as J from 'fp-ts/Json'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(J.stringify({ a: 1 }), E.right('{\"a\":1}'))\n * const circular: any = { ref: null }\n * circular.ref = circular\n * assert.deepStrictEqual(\n *   pipe(\n *     J.stringify(circular),\n *     E.mapLeft(e => e instanceof Error && e.message.includes('Converting circular structure to JSON'))\n *   ),\n *   E.left(true)\n * )\n *\n *  @since 2.10.0\n */\nexport var stringify = function (a) {\n    return tryCatch(function () {\n        var s = JSON.stringify(a);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, identity);\n};\n","import { throwifyFpFn, throwifyAnyEither } from '@tma.js/toolkit';\nimport * as E from 'fp-ts/Either';\nimport * as J from 'fp-ts/Json';\nimport { pipe } from 'fp-ts/function';\n\nimport { encodeBase64Url, type DecodeBase64UrlError, decodeBase64UrlFp } from '@/base64-url.js';\n\n/**\n * Creates a safe start parameter value. If the value is not a string, the\n * function applies JSON.stringify to it, so make sure you are not passing an\n * object with circular references.\n *\n * @param value - value to create start parameter from.\n * @see Learn more about start parameter:\n * https://docs.telegram-mini-apps.com/platform/start-parameter\n */\nexport function createStartParamFp(value: unknown): E.Either<Error, string> {\n  const b64 = encodeBase64Url(typeof value === 'string' ? value : JSON.stringify(value));\n  return b64.length > 512\n    ? E.left(new Error('Value is too long for start parameter'))\n    : E.right(b64);\n}\n\n/**\n * @see createStartParamFp\n */\nexport const createStartParam = throwifyFpFn(createStartParamFp);\n\n/**\n * @see decodeStartParamFp\n */\nexport function decodeStartParam<T>(value: string, parse: (value: string) => T): T;\n/**\n * @see decodeStartParamFp\n */\nexport function decodeStartParam(value: string, as: 'json'): J.Json;\n/**\n * @see decodeStartParamFp\n */\nexport function decodeStartParam(value: string): string;\nexport function decodeStartParam<T>(\n  value: string,\n  arg2?: 'json' | ((value: string) => T),\n): string | unknown | T {\n  return throwifyAnyEither(\n    decodeStartParamFp(\n      value,\n      // @ts-expect-error TypeScript is unable to detect a correct override.\n      typeof arg2 === 'function'\n        ? (value: string) => E.tryCatch(() => arg2(value), e => e)\n        : arg2,\n    ),\n  );\n}\n\n/**\n * Decodes a start parameter using a custom parser.\n * @param value - a start parameter value.\n * @param parse - a custom value parser.\n */\nexport function decodeStartParamFp<L, R>(\n  value: string,\n  parse: (value: string) => E.Either<L, R>,\n): E.Either<L | DecodeBase64UrlError, R>;\n/**\n * Decodes a start parameter assuming that the result is a JSON value.\n * @param value - a start parameter value.\n * @param as - result kind.\n */\nexport function decodeStartParamFp(\n  value: string,\n  as: 'json',\n): E.Either<SyntaxError | DecodeBase64UrlError, J.Json>;\n/**\n * Decodes a start parameter and returns its decoded representation.\n * @param value - a value to decode.\n */\nexport function decodeStartParamFp(value: string): E.Either<DecodeBase64UrlError, string>;\nexport function decodeStartParamFp<L, R>(\n  value: string,\n  arg2?: 'json' | ((value: string) => E.Either<L, R>),\n): E.Either<DecodeBase64UrlError | SyntaxError | L, R | string | J.Json> {\n  return pipe(\n    decodeBase64UrlFp(value),\n    E.chain<DecodeBase64UrlError | SyntaxError | L, string, R | string | J.Json>(decoded => {\n      if (!arg2) {\n        return E.right(decoded);\n      }\n      if (typeof arg2 === 'function') {\n        return arg2(decoded);\n      }\n      return J.parse(decoded) as E.Either<SyntaxError, J.Json>;\n    }),\n  );\n}\n\n/**\n * @returns True if the passed value is safe to be used to create a start parameter value from it.\n * If true is returned, the value can be safely passed to the `createStartParam` function.\n * @param value - value to check.\n * @see createStartParam\n */\nexport function isSafeToCreateStartParam(value: string): boolean {\n  return encodeBase64Url(value).length <= 512;\n}\n","import { isTMAFp } from '@tma.js/bridge';\nimport { computed } from '@tma.js/signals';\n\nimport type { MaybeAccessor } from '@/types.js';\n\nexport interface SharedFeatureOptions {\n  /**\n   * True if the current environment is Telegram Mini Apps.\n   */\n  isTma: MaybeAccessor<boolean>;\n}\n\nexport function sharedFeatureOptions(): SharedFeatureOptions {\n  return { isTma: computed(() => isTMAFp()) };\n}\n","import { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport function createFnOption<T>(mix: MaybeAccessor<T>) {\n  return <O extends object>(obj: O) => {\n    return { ...obj, ...access(mix) };\n  };\n}\n","import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@tma.js/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}\n","import { postEventFp as _postEventFp, type PostEventFpFn, type PostEventFn } from '@tma.js/bridge';\nimport { throwifyAnyEither } from '@tma.js/toolkit';\n\nimport { createSignal } from '@/globals/signals-registry.js';\n\nexport const postEventFpSignal = createSignal(_postEventFp);\n\nexport const postEventFp: PostEventFpFn = (...args: any[]) => {\n  return (postEventFpSignal as any)()(...args);\n};\n\nexport const postEvent: PostEventFn = (...args: any[]) => {\n  return throwifyAnyEither((postEventFp as any)(...args));\n};\n","import { type PostEventFpFn } from '@tma.js/bridge';\n\nimport { createFnOption } from '@/fn-options/createFnOption.js';\nimport { postEventFp } from '@/globals/postEvent.js';\n\nexport interface WithPostEvent {\n  /**\n   * A postEvent function to use to call Mini Apps methods.\n   */\n  postEvent: PostEventFpFn;\n}\n\nexport const withPostEvent = createFnOption<WithPostEvent>({\n  postEvent: postEventFp,\n});\n","import { getStorageValue, setStorageValue } from '@tma.js/toolkit';\n\nexport interface ComponentStorage<T> {\n  get: () => T | undefined;\n  set: (value: T) => void;\n}\n\n/**\n * Creates a new sessionStorage-based component storage.\n * @param key - session storage key to use.\n */\nexport function createComponentSessionStorage<T>(key: string): ComponentStorage<T> {\n  return {\n    get: () => getStorageValue<T>(key),\n    set(value) {\n      setStorageValue<T>(key, value);\n    },\n  };\n}\n","/**\n * Returns the first navigation entry from window.performance.\n * @returns First navigation entry or null, in case performance functionality is not supported\n * or navigation entry was not found.\n */\nfunction getFirstNavigationEntry(): PerformanceNavigationTiming | undefined {\n  return performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming | undefined;\n}\n\n/**\n * @returns True, if the current page was reloaded.\n * @see https://stackoverflow.com/a/36444134/11894710\n */\nexport function isPageReload(): boolean {\n  const entry = getFirstNavigationEntry();\n  return !!entry && entry.type === 'reload';\n}\n","import { createFnOption } from '@/fn-options/createFnOption.js';\nimport { type ComponentStorage, createComponentSessionStorage } from '@/helpers/component-storage.js';\nimport { isPageReload } from '@/helpers/navigation.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport interface WithStateRestore<T> {\n  /**\n   * A storage the component could use to store its data.\n   */\n  storage: ComponentStorage<T>;\n  /**\n   * True if the current page is reloaded.\n   */\n  isPageReload: MaybeAccessor<boolean>;\n}\n\nexport function withStateRestore<S>(storageName: string) {\n  return createFnOption<WithStateRestore<S>>({\n    storage: createComponentSessionStorage<S>(storageName),\n    isPageReload,\n  });\n}\n","import type { Version } from '@tma.js/types';\n\nimport { createSignal } from '@/globals/signals-registry.js';\n\n/**\n * The current Mini Apps version.\n */\nexport const version = createSignal<Version>('0.0');\n","import type { Version } from '@tma.js/types';\n\nimport { createFnOption } from '@/fn-options/createFnOption.js';\nimport { version } from '@/globals/version.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport interface WithVersion {\n  /**\n   * The currently supported Telegram Mini Apps version by the Telegram client.\n   */\n  version: MaybeAccessor<Version>;\n}\n\nexport const withVersion = createFnOption<WithVersion>({ version });\n","import { on, off, type EventName } from '@tma.js/bridge';\nimport { pipe } from 'fp-ts/function';\n\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport function buttonOptions<S>(storageName: string, trackedClickEvent: EventName) {\n  return {\n    ...pipe(\n      sharedFeatureOptions(),\n      withPostEvent,\n      withVersion,\n      withStateRestore<S>(storageName),\n    ),\n    onClick(listener: VoidFunction, once?: boolean): VoidFunction {\n      return on(trackedClickEvent, listener, once);\n    },\n    offClick(listener: VoidFunction, once?: boolean): void {\n      off(trackedClickEvent, listener, once);\n    },\n  };\n}\n","import { BackButton } from '@/features/BackButton/BackButton.js';\nimport { buttonOptions } from '@/fn-options/buttonOptions.js';\n\nexport const backButton = new BackButton(buttonOptions('backButton', 'back_button_pressed'));\n","import { batch, computed, signal } from '@tma.js/signals';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { access } from '@/helpers/access.js';\nimport type { AsyncOptions, MaybeAccessor } from '@/types.js';\n\nexport interface AsyncMountableOptions<S, E> {\n  /**\n   * A function to retrieve the initial state.\n   * @param options - additional options.\n   */\n  initialState: (options?: AsyncOptions) => TE.TaskEither<E, S>;\n  /**\n   * @returns True if the current page was reloaded.\n   */\n  isPageReload: MaybeAccessor<boolean>;\n  /**\n   * A function to call whenever the component was mounted.\n   * @param state - restored state.\n   */\n  onMounted?: (state: S) => void;\n  /**\n   * A function to call whenever the component was unmounted.\n   */\n  onUnmounted?: VoidFunction;\n  /**\n   * Attempts to restore previously saved component state. This function\n   * will only be called if the current page was reloaded.\n   */\n  restoreState: () => (S | undefined);\n}\n\nexport class AsyncMountable<S extends object, E> {\n  constructor({\n    initialState,\n    onMounted,\n    restoreState,\n    onUnmounted,\n    isPageReload,\n  }: AsyncMountableOptions<S, E>) {\n    this.mount = options => {\n      if (this._isMounted()) {\n        return TE.right(undefined);\n      }\n      const restored = access(isPageReload) ? restoreState() : undefined;\n      return pipe(\n        restored ? TE.right(restored) : initialState(options),\n        TE.map(state => {\n          // The user could call mount several times in a row while the\n          // component was still mounting. We should prevent calling the\n          // same hooks several times in this case.\n          if (!this._isMounted()) {\n            batch(() => {\n              this._isMounted.set(true);\n              onMounted?.(state);\n            });\n          }\n        }),\n      );\n    };\n\n    this.unmount = () => {\n      if (this._isMounted()) {\n        batch(() => {\n          this._isMounted.set(false);\n          onUnmounted?.();\n        });\n      }\n    };\n  }\n\n  private readonly _isMounted = signal(false);\n\n  /**\n   * Signal indicating if the component is mounted.\n   */\n  readonly isMounted = computed(this._isMounted);\n\n  /**\n   * Mounts the component restoring its state and calling required side effects.\n   * @param options - additional execution options.\n   */\n  readonly mount: (options?: AsyncOptions) => TE.TaskEither<E, void>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n}\n","import type {\n  RequestError,\n  PostEventError,\n  EventPayload,\n  BiometryAuthRequestStatus,\n  EventListener,\n  BiometryTokenUpdateStatus,\n} from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport { BetterPromise } from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { AsyncMountable } from '@/composables/AsyncMountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport { NotAvailableError } from '@/errors.js';\nimport type {\n  BiometryAuthenticateOptions, BiometryOptions,\n  BiometryRequestAccessOptions,\n  BiometryState,\n  BiometryUpdateTokenOptions,\n} from '@/features/Biometry/types.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, WithChecks, WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype BiometryTask<T> = TE.TaskEither<RequestError, T>;\n\ninterface AuthenticateResult {\n  /**\n   * Authentication status.\n   */\n  status: BiometryAuthRequestStatus;\n  /**\n   * Token from the local secure storage saved previously.\n   */\n  token?: string;\n}\n\nconst notAvailableError = new NotAvailableError('Biometry is not available');\n\nfunction eventToState(event: EventPayload<'biometry_info_received'>): BiometryState {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @since Mini Apps v7.2\n */\nexport class Biometry {\n  constructor({\n    version,\n    request,\n    postEvent,\n    storage,\n    onInfoReceived,\n    offInfoReceived,\n    isTma,\n    isPageReload,\n  }: BiometryOptions) {\n    const listener: EventListener<'biometry_info_received'> = event => {\n      stateful.setState(eventToState(event));\n    };\n\n    const stateful = new Stateful<BiometryState>({\n      initialState: {\n        available: false,\n        type: 'unknown',\n        accessGranted: false,\n        accessRequested: false,\n        deviceId: '',\n        tokenSaved: false,\n      },\n      onChange: storage.set,\n    });\n    const mountable = new AsyncMountable({\n      initialState(options) {\n        return pipe(\n          request('web_app_biometry_get_info', 'biometry_info_received', options),\n          TE.map(eventToState),\n        );\n      },\n      isPageReload,\n      onMounted(state) {\n        stateful.setState(state);\n        onInfoReceived(listener);\n      },\n      onUnmounted() {\n        offInfoReceived(listener);\n      },\n      restoreState: storage.get,\n    });\n\n    const wrapOptions = { version, requires: 'web_app_biometry_request_auth', isTma } as const;\n    const wrapSupportedEither = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'either',\n    });\n    const wrapSupportedTask = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'task',\n    });\n    const wrapMountedTask = createWithChecksFp({\n      ...wrapOptions,\n      isMounted: mountable.isMounted,\n      returns: 'task',\n    });\n\n    this.isAvailable = stateful.getter('available');\n    this.isMounted = mountable.isMounted;\n    this.isSupported = createIsSupportedSignal('web_app_biometry_request_auth', version);\n    this.state = stateful.state;\n    this.unmount = mountable.unmount;\n    this.mountFp = wrapSupportedTask(mountable.mount);\n\n    this.authenticateFp = wrapMountedTask(options => {\n      return !this.isAvailable()\n        ? TE.left(notAvailableError)\n        : pipe(\n          request('web_app_biometry_request_auth', 'biometry_auth_requested', {\n            ...options,\n            params: { reason: ((options || {}).reason || '').trim() },\n          }),\n          TE.map(response => {\n            stateful.setState({ token: response.token });\n            return response;\n          }),\n        );\n    });\n\n    this.openSettingsFp = wrapSupportedEither(() => postEvent('web_app_biometry_open_settings'));\n\n    this.requestAccessFp = wrapMountedTask(options => {\n      return pipe(\n        request('web_app_biometry_request_access', 'biometry_info_received', {\n          ...options,\n          params: { reason: ((options || {}).reason || '').trim() },\n        }),\n        TE.chain(response => {\n          const state = eventToState(response);\n          if (!state.available) {\n            return TE.left(notAvailableError);\n          }\n          stateful.setState(state);\n          return TE.right(state.accessRequested);\n        }),\n      );\n    });\n\n    this.updateTokenFp = wrapMountedTask((options = {}) => {\n      return pipe(\n        request('web_app_biometry_update_token', 'biometry_token_updated', {\n          ...options,\n          params: { token: options.token || '', reason: options.reason?.trim() },\n        }),\n        TE.map(response => response.status),\n      );\n    });\n\n    this.authenticate = throwifyWithChecksFp(this.authenticateFp);\n    this.openSettings = throwifyWithChecksFp(this.openSettingsFp);\n    this.requestAccess = throwifyWithChecksFp(this.requestAccessFp);\n    this.updateToken = throwifyWithChecksFp(this.updateTokenFp);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n  }\n\n  /**\n   * Signal indicating if biometry is available.\n   */\n  readonly isAvailable: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Complete component state.\n   */\n  readonly state: Computed<BiometryState>;\n\n  /**\n   * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n   * @param options - method options.\n   * @since Mini Apps v7.2\n   * @returns Token from the local secure storage saved previously or undefined.\n   * @example\n   * const { status, token } = await biometry.authenticate({\n   *   reason: 'Authenticate to open wallet',\n   * });\n   */\n  readonly authenticateFp: WithChecksFp<(options?: BiometryAuthenticateOptions) => BiometryTask<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }>, true>;\n\n  /**\n   * @see authenticateFp\n   */\n  readonly authenticate: WithChecks<\n    (options?: BiometryAuthenticateOptions) => BetterPromise<AuthenticateResult>,\n    true\n  >;\n\n  /**\n   * Opens the biometric access settings for bots. Useful when you need to request biometrics\n   * access to users who haven't granted it yet.\n   *\n   * _Note that this method can be called only in response to user interaction with the Mini App\n   * interface (e.g. a click inside the Mini App or on the main button)_.\n   * @since Mini Apps v7.2\n   */\n  readonly openSettingsFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see openSettingsFp\n   */\n  readonly openSettings: WithChecks<() => void, true>;\n\n  /**\n   * Requests permission to use biometrics.\n   * @since Mini Apps v7.2\n   * @returns Promise with true, if access was granted.\n   * @example\n   * const accessGranted = await biometry.requestAccess({\n   *   reason: 'Authenticate to open wallet',\n   * });\n   */\n  readonly requestAccessFp: WithChecksFp<\n    (options?: BiometryRequestAccessOptions) => BiometryTask<boolean>,\n    true\n  >;\n\n  /**\n   * @see requestAccessFp\n   */\n  readonly requestAccess: WithChecks<\n    (options?: BiometryRequestAccessOptions) => BetterPromise<boolean>,\n    true\n  >;\n\n  /**\n   * Updates the biometric token in a secure storage on the device.\n   * @since Mini Apps v7.2\n   * @returns Promise with `true`, if token was updated.\n   * @example Setting a new token\n   * biometry.updateToken({\n   *   token: 'abcdef',\n   * })\n   * @example Deleting the token\n   * biometry.updateToken();\n   */\n  readonly updateTokenFp: WithChecksFp<\n    (options?: BiometryUpdateTokenOptions) => BiometryTask<BiometryTokenUpdateStatus>,\n    true\n  >;\n\n  /**\n   * @see updateTokenFp\n   */\n  readonly updateToken: WithChecks<\n    (options?: BiometryUpdateTokenOptions) => BetterPromise<BiometryTokenUpdateStatus>,\n    true\n  >;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v7.2\n   */\n  readonly mountFp: WithChecksFp<(options?: AsyncOptions) => BiometryTask<void>, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, true>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n}\n","import {\n  requestFp as _requestFp,\n  request2Fp as _request2Fp,\n  type RequestFpFn,\n  type RequestFn,\n  type Request2FpFn,\n  type Request2Fn,\n} from '@tma.js/bridge';\nimport { BetterPromise } from 'better-promises';\n\nimport { postEventFp } from '@/globals/postEvent.js';\n\n/**\n * @deprecated To be removed in the next major update. Use `request2fp` instead, it provides\n * a proper way of handling multiple events.\n */\nexport const requestFp: RequestFpFn = (method: any, events: any, options: any) => {\n  return _requestFp(method, events, {\n    postEvent: postEventFp,\n    ...options,\n  });\n};\n\nexport const request2Fp: Request2FpFn = (method: any, events: any, options: any) => {\n  return _request2Fp(method, events, {\n    postEvent: postEventFp,\n    ...options,\n  });\n};\n\n/**\n * @deprecated To be removed in the next major update. Use `request` instead, it provides\n * a proper way of handling multiple events.\n */\nexport const request: RequestFn = (...args: any[]) => {\n  return BetterPromise.fn(() => (requestFp as any)(...args)());\n};\n\nexport const request2: Request2Fn = (...args: any[]) => {\n  return BetterPromise.fn(() => (request2Fp as any)(...args)());\n};\n","import type { Request2FpFn } from '@tma.js/bridge';\n\nimport { createFnOption } from '@/fn-options/createFnOption.js';\nimport { request2Fp } from '@/globals/request.js';\n\nexport interface WithRequest {\n  /**\n   * A request function to use to call Mini Apps methods.\n   */\n  request: Request2FpFn;\n}\n\nexport const withRequest = createFnOption<WithRequest>({ request: request2Fp });\n","import { on, off } from '@tma.js/bridge';\nimport { pipe } from 'fp-ts/function';\n\nimport { Biometry } from '@/features/Biometry/Biometry.js';\nimport type { BiometryState } from '@/features/Biometry/types.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport const biometry = new Biometry({\n  ...pipe(\n    sharedFeatureOptions(),\n    withPostEvent,\n    withVersion,\n    withRequest,\n    withStateRestore<BiometryState>('biometry'),\n  ),\n  offInfoReceived(listener) {\n    off('biometry_info_received', listener);\n  },\n  onInfoReceived(listener) {\n    return on('biometry_info_received', listener);\n  },\n});\n","import type { PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport interface ClosingBehaviorState {\n  isConfirmationEnabled: boolean;\n}\n\nexport interface ClosingBehaviorOptions\n  extends WithStateRestore<ClosingBehaviorState>,\n  WithPostEvent,\n  SharedFeatureOptions {\n}\n\nexport class ClosingBehavior {\n  constructor({ postEvent, storage, isTma, isPageReload }: ClosingBehaviorOptions) {\n    const stateful = new Stateful({\n      initialState: { isConfirmationEnabled: false },\n      onChange(state) {\n        storage.set(state);\n      },\n    });\n    const mountable = new Mountable({\n      onMounted: stateful.setState,\n      restoreState: storage.get,\n      initialState: { isConfirmationEnabled: false },\n      isPageReload,\n    });\n\n    const wrapOptions = { requires: 'web_app_setup_closing_behavior', isTma } as const;\n    const wrapSupportedPlain = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'plain',\n    });\n    const wrapMountedEither = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'either',\n      isMounted: mountable.isMounted,\n    });\n\n    const setClosingConfirmation = (isConfirmationEnabled: boolean) => {\n      if (isConfirmationEnabled === this.isConfirmationEnabled()) {\n        return E.right(undefined);\n      }\n      stateful.setState({ isConfirmationEnabled });\n      return postEvent('web_app_setup_closing_behavior', {\n        need_confirmation: isConfirmationEnabled,\n      });\n    };\n\n    this.isConfirmationEnabled = stateful.getter('isConfirmationEnabled');\n    this.isMounted = mountable.isMounted;\n\n    this.disableConfirmationFp = wrapMountedEither(() => {\n      return setClosingConfirmation(false);\n    });\n    this.enableConfirmationFp = wrapMountedEither(() => {\n      return setClosingConfirmation(true);\n    });\n    this.mountFp = wrapSupportedPlain(() => {\n      const nothing = () => undefined;\n      return pipe(mountable.mount(), E.match(nothing, nothing));\n    });\n    this.unmount = mountable.unmount;\n\n    this.disableConfirmation = throwifyWithChecksFp(this.disableConfirmationFp);\n    this.enableConfirmation = throwifyWithChecksFp(this.enableConfirmationFp);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n  }\n\n  /**\n   * Signal indicating if closing confirmation dialog is currently enabled.\n   */\n  readonly isConfirmationEnabled: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component restoring its state.\n   */\n  readonly mountFp: WithChecksFp<() => void, false>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, false>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n\n  /**\n   * Disables the closing confirmation dialog.\n   */\n  readonly disableConfirmationFp: WithChecksFp<() => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see disableConfirmationFp\n   */\n  readonly disableConfirmation: WithChecks<() => void, false>;\n\n  /**\n   * Enables the closing confirmation dialog.\n   */\n  readonly enableConfirmationFp: WithChecksFp<() => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see enableConfirmationFp\n   */\n  readonly enableConfirmation: WithChecks<() => void, false>;\n}\n","import { pipe } from 'fp-ts/function';\n\nimport {\n  ClosingBehavior,\n  type ClosingBehaviorState,\n} from '@/features/ClosingBehavior/ClosingBehavior.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\n\nexport const closingBehavior = new ClosingBehavior(pipe(\n  sharedFeatureOptions(),\n  withStateRestore<ClosingBehaviorState>('closingBehavior'),\n  withPostEvent,\n));\n","import type { InvokeCustomMethodFpOptions, RequestError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport { BetterPromise } from 'better-promises';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\nimport { array, parse, record, string } from 'valibot';\n\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithInvokeCustomMethod } from '@/fn-options/withInvokeCustomMethod.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecks, type WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype CloudStorageTask<T> = TE.TaskEither<RequestError, T>;\n\nexport interface CloudStorageOptions extends WithVersion,\n  WithInvokeCustomMethod,\n  SharedFeatureOptions {\n}\n\n/**\n * @since Mini Apps v6.9\n */\nexport class CloudStorage {\n  constructor({ version, isTma, invokeCustomMethod }: CloudStorageOptions) {\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      requires: 'web_app_invoke_custom_method',\n      isTma,\n      returns: 'task',\n    });\n\n    this.isSupported = createIsSupportedSignal('web_app_invoke_custom_method', version);\n    this.deleteItemFp = wrapSupportedTask((keyOrKeys, options) => {\n      const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n      return pipe(\n        keys.length\n          ? invokeCustomMethod('deleteStorageValues', { keys }, options)\n          : TE.right(undefined),\n        TE.map(() => undefined),\n      );\n    });\n    this.getItemFp = wrapSupportedTask((key, options) => {\n      return pipe(\n        this.getItemsFp([key], options),\n        TE.map(values => values[key] || ''),\n      );\n    });\n    this.getItemsFp = wrapSupportedTask((keys, options) => {\n      return pipe(\n        keys.length ? invokeCustomMethod('getStorageValues', { keys }, options) : TE.right({}),\n        TE.map(data => {\n          return {\n            // Fulfill the response with probably missing keys.\n            ...keys.reduce<Record<string, string>>((acc, key) => {\n              acc[key] = '';\n              return acc;\n            }, {}),\n            ...parse(record(string(), string()), data),\n          };\n        }),\n      );\n    });\n    this.getKeysFp = wrapSupportedTask(options => {\n      return pipe(\n        invokeCustomMethod('getStorageKeys', {}, options),\n        TE.map(data => parse(array(string()), data)),\n      );\n    });\n    this.setItemFp = wrapSupportedTask((key, value, options) => {\n      return pipe(\n        invokeCustomMethod('saveStorageValue', { key, value }, options),\n        TE.map(() => undefined),\n      );\n    });\n    this.clearFp = wrapSupportedTask(options => {\n      return pipe(this.getKeysFp(options), TE.chain(this.deleteItemFp));\n    });\n\n    this.deleteItem = throwifyWithChecksFp(this.deleteItemFp);\n    this.getItem = throwifyWithChecksFp(this.getItemFp);\n    this.getItems = throwifyWithChecksFp(this.getItemsFp);\n    this.getKeys = throwifyWithChecksFp(this.getKeysFp);\n    this.setItem = throwifyWithChecksFp(this.setItemFp);\n    this.clear = throwifyWithChecksFp(this.clearFp);\n  }\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Deletes specified key or keys from the cloud storage.\n   * @param keyOrKeys - key or keys to delete.\n   * @param options - request execution options.\n   * @since Mini Apps v6.9\n   */\n  readonly deleteItemFp: WithChecksFp<\n    (keyOrKeys: string | string[], options?: InvokeCustomMethodFpOptions) => CloudStorageTask<void>,\n    true\n  >;\n\n  readonly deleteItem: WithChecks<\n    (keyOrKeys: string | string[], options?: InvokeCustomMethodFpOptions) => BetterPromise<void>,\n    true\n  >;\n\n  /**\n   * Gets a single key value from the cloud storage.\n   * @param key - a key to get.\n   * @param options - request execution options.\n   * @returns A key value as a string.\n   * @since Mini Apps v6.9\n   */\n  readonly getItemFp: WithChecksFp<\n    (key: string, options?: InvokeCustomMethodFpOptions) => CloudStorageTask<string>,\n    true\n  >;\n\n  /**\n   * @see getItemFp\n   */\n  readonly getItem: WithChecks<{\n    <K extends string>(\n      keys: K[],\n      options?: InvokeCustomMethodFpOptions,\n    ): BetterPromise<Record<K, string>>;\n    (key: string, options?: InvokeCustomMethodFpOptions): BetterPromise<string>;\n  }, true>;\n\n  /**\n   * Gets multiple keys' values from the cloud storage.\n   * @param keys - keys list.\n   * @param options - request execution options.\n   * @returns A map, where a key is one of the specified in the `keys` argument,\n   * and a value is a corresponding storage value if an array of keys was passed.\n   * @since Mini Apps v6.9\n   */\n  readonly getItemsFp: WithChecksFp<\n    <K extends string>(\n      keys: K[],\n      options?: InvokeCustomMethodFpOptions,\n    ) => CloudStorageTask<Record<K, string>>,\n    true\n  >;\n\n  /**\n   * @see getItemsFp\n   */\n  readonly getItems: WithChecks<\n    <K extends string>(\n      keys: K[],\n      options?: InvokeCustomMethodFpOptions,\n    ) => BetterPromise<Record<K, string>>,\n    true\n  >;\n\n  /**\n   * Returns a list of all keys presented in the cloud storage.\n   * @param options - request execution options.\n   * @since Mini Apps v6.9\n   */\n  readonly getKeysFp: WithChecksFp<\n    (options?: InvokeCustomMethodFpOptions) => CloudStorageTask<string[]>,\n    true\n  >;\n\n  /**\n   * @see getKeysFp\n   */\n  readonly getKeys: WithChecks<\n    (options?: InvokeCustomMethodFpOptions) => BetterPromise<string[]>,\n    true\n  >;\n\n  /**\n   * Saves the specified value by a key.\n   * @param key - storage key.\n   * @param value - storage value.\n   * @param options - request execution options.\n   * @since Mini Apps v6.9\n   */\n  readonly setItemFp: WithChecksFp<\n    (key: string, value: string, options?: InvokeCustomMethodFpOptions) => CloudStorageTask<void>,\n    true\n  >;\n\n  /**\n   * @see setItemFp\n   */\n  readonly setItem: WithChecks<\n    (key: string, value: string, options?: InvokeCustomMethodFpOptions) => BetterPromise<void>,\n    true\n  >;\n\n  /**\n   * Clears the cloud storage.\n   * @param options - additional options.\n   * @since Mini Apps v6.9\n   */\n  readonly clearFp: WithChecksFp<\n    (options?: InvokeCustomMethodFpOptions) => CloudStorageTask<void>,\n    true\n  >;\n\n  /**\n   * @see clearFp\n   */\n  readonly clear: WithChecks<(options?: InvokeCustomMethodFpOptions) => BetterPromise<void>, true>;\n}\n","import { createSignal } from '@/globals/signals-registry.js';\n\nconst lastRequestId = createSignal(0);\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  lastRequestId.set(lastRequestId() + 1);\n  return lastRequestId().toString();\n}\n","import {\n  type RequestError,\n  type CustomMethodName,\n  type CustomMethodParams,\n  type InvokeCustomMethodOptions,\n  invokeCustomMethodFp,\n} from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\n\nimport { createRequestId } from '@/globals/createRequestId.js';\nimport { postEventFp } from '@/globals/postEvent.js';\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): TE.TaskEither<RequestError, unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): TE.TaskEither<RequestError, unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): TE.TaskEither<RequestError, unknown> {\n  return invokeCustomMethodFp(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEventFp,\n  });\n}\n","import type {\n  CustomMethodParams,\n  CustomMethodName,\n  InvokeCustomMethodError,\n  InvokeCustomMethodFpOptions,\n  RequestError,\n} from '@tma.js/bridge';\nimport type * as TE from 'fp-ts/TaskEither';\n\nimport { createFnOption } from '@/fn-options/createFnOption.js';\nimport { invokeCustomMethod } from '@/globals/invokeCustomMethod.js';\n\nexport type { InvokeCustomMethodError };\n\nexport interface InvokeCustomMethodNoRequestIdFn {\n  <M extends CustomMethodName>(\n    this: void,\n    method: M,\n    params: CustomMethodParams<M>,\n    options?: InvokeCustomMethodFpOptions,\n  ): TE.TaskEither<InvokeCustomMethodError, unknown>;\n\n  (\n    this: void,\n    method: string,\n    params: object,\n    options?: InvokeCustomMethodFpOptions,\n  ): TE.TaskEither<RequestError, unknown>;\n}\n\nexport interface WithInvokeCustomMethod {\n  invokeCustomMethod: InvokeCustomMethodNoRequestIdFn;\n}\n\nexport const withInvokeCustomMethod = createFnOption<WithInvokeCustomMethod>({\n  invokeCustomMethod,\n});\n","import { pipe } from 'fp-ts/function';\n\nimport { CloudStorage } from '@/features/CloudStorage/CloudStorage.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withInvokeCustomMethod } from '@/fn-options/withInvokeCustomMethod.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport const cloudStorage = new CloudStorage(pipe(\n  sharedFeatureOptions(),\n  withVersion,\n  withInvokeCustomMethod,\n));\n","import { EventPayload, type MethodParams, type Request2CaptureFn, RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { DeviceStorageMethodError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithCreateRequestId } from '@/fn-options/withCreateRequestId.js';\nimport type { WithRequest } from '@/fn-options/withRequest.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport type DeviceStorageError = RequestError | DeviceStorageMethodError;\n\nexport interface DeviceStorageOptions extends SharedFeatureOptions,\n  WithVersion,\n  WithRequest,\n  WithCreateRequestId {\n}\n\n/**\n * @since Mini Apps v9.0\n */\nexport class DeviceStorage {\n  constructor({ isTma, request, version, createRequestId }: DeviceStorageOptions) {\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      requires: 'web_app_device_storage_get_key',\n      isTma,\n      returns: 'task',\n    });\n\n    const invokeMethod = <\n      M extends (\n        | 'web_app_device_storage_save_key'\n        | 'web_app_device_storage_get_key'\n        | 'web_app_device_storage_save_key'\n        | 'web_app_device_storage_clear'\n      ),\n      E extends (\n        | 'device_storage_key_saved'\n        | 'device_storage_key_received'\n        | 'device_storage_cleared'\n      ),\n    >(\n      method: M,\n      event: E,\n      params: Omit<MethodParams<M>, 'req_id'>,\n    ): TE.TaskEither<DeviceStorageError, EventPayload<E>> => {\n      const requestId = createRequestId();\n      return pipe(\n        request<M, ('device_storage_failed' | E)[]>(method, ['device_storage_failed', event], {\n          params: { ...params, req_id: requestId },\n          capture: (event => {\n            return 'payload' in event ? event.payload.req_id === requestId : true;\n          }) as Request2CaptureFn<('device_storage_failed' | E)[]>,\n        }),\n        TE.chain(response => (\n          response.event === 'device_storage_failed'\n            ? TE.left(new DeviceStorageMethodError(response.payload.error || 'UNKNOWN_ERROR'))\n            : TE.right(response.payload as EventPayload<E>)\n        )),\n      );\n    };\n\n    this.getItemFp = wrapSupportedTask(key => {\n      return pipe(\n        invokeMethod('web_app_device_storage_get_key', 'device_storage_key_received', { key }),\n        TE.map(payload => payload.value),\n      );\n    });\n    this.setItemFp = wrapSupportedTask((key, value) => {\n      return pipe(\n        invokeMethod('web_app_device_storage_save_key', 'device_storage_key_saved', { key, value }),\n        TE.map(() => undefined),\n      );\n    });\n    this.deleteItemFp = wrapSupportedTask(key => {\n      return this.setItemFp(key, null);\n    });\n    this.clearFp = wrapSupportedTask(() => {\n      return pipe(\n        invokeMethod('web_app_device_storage_clear', 'device_storage_cleared', {}),\n        TE.map(() => undefined),\n      );\n    });\n\n    this.getItem = throwifyWithChecksFp(this.getItemFp);\n    this.setItem = throwifyWithChecksFp(this.setItemFp);\n    this.deleteItem = throwifyWithChecksFp(this.deleteItemFp);\n    this.clear = throwifyWithChecksFp(this.clearFp);\n  }\n\n  /**\n    * Retrieves an item using its key.\n    * @since Mini Apps v9.0\n    */\n  readonly getItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<DeviceStorageError, string | null>,\n    true\n  >;\n\n  /**\n   * @see getItemFp\n   */\n  readonly getItem: WithChecks<(key: string) => Promise<string | null>, true>;\n\n  /**\n    * Sets a new item in the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly setItemFp: WithChecksFp<\n    (key: string, value: string | null) => TE.TaskEither<DeviceStorageError, void>,\n    true\n  >;\n\n  /**\n   * @see setItemFp\n   */\n  readonly setItem: WithChecks<(key: string, value: string | null) => Promise<void>, true>;\n\n  /**\n    * Removes a key from the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly deleteItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<DeviceStorageError, void>,\n    true\n  >;\n\n  /**\n   * @see deleteItemFp\n   */\n  readonly deleteItem: WithChecks<(key: string) => Promise<void>, true>;\n\n  /**\n    * Removes all keys from the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly clearFp: WithChecksFp<() => TE.TaskEither<DeviceStorageError, void>, true>;\n\n  /**\n   * @see clearFp\n   */\n  readonly clear: WithChecks<() => Promise<void>, true>;\n}\n","import { createFnOption } from '@/fn-options/createFnOption.js';\nimport { createRequestId } from '@/globals/createRequestId.js';\n\nexport interface WithCreateRequestId {\n  /**\n   * A function generating a request identifier.\n   */\n  createRequestId: () => string;\n}\n\nexport const withCreateRequestId = createFnOption<WithCreateRequestId>({ createRequestId });\n","import { pipe } from 'fp-ts/function';\n\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withCreateRequestId } from '@/fn-options/withCreateRequestId.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nimport { DeviceStorage } from './DeviceStorage.js';\n\nexport const deviceStorage = new DeviceStorage(pipe(\n  sharedFeatureOptions(),\n  withVersion,\n  withRequest,\n  withCreateRequestId,\n));\n","import type { EmojiStatusAccessRequestedStatus, RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithVersion, WithRequest {\n}\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    options: AsyncOptions,\n  ): TE.TaskEither<RequestError, EmojiStatusAccessRequestedStatus> => {\n    return pipe(\n      request('web_app_request_emoji_status_access', 'emoji_status_access_requested', options),\n      TE.map(response => response.status),\n    );\n  }, { ...rest, requires: 'web_app_request_emoji_status_access', returns: 'task' });\n}\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @returns Emoji status access status.\n * @since Mini Apps v8.0\n * @example\n * const status = await requestEmojiStatusAccess();\n */\nexport const requestEmojiStatusAccessFp = create(pipe(\n  sharedFeatureOptions(),\n  withVersion,\n  withRequest,\n));\n\n/**\n * @see requestEmojiStatusAccessFp\n */\nexport const requestEmojiStatusAccess = throwifyWithChecksFp(requestEmojiStatusAccessFp);\n","import { RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { SetEmojiStatusError } from '@/errors.js';\nimport {\n  type SharedFeatureOptions,\n  sharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\nexport interface SetEmojiStatusOptions extends AsyncOptions {\n  duration?: number;\n}\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    customEmojiId: string,\n    options?: SetEmojiStatusOptions,\n  ): TE.TaskEither<RequestError | SetEmojiStatusError, void> => {\n    return pipe(\n      request('web_app_set_emoji_status', ['emoji_status_set', 'emoji_status_failed'], {\n        params: {\n          custom_emoji_id: customEmojiId,\n          duration: (options || {}).duration,\n        },\n        ...options,\n      }),\n      TE.chainW(response => (\n        response.event === 'emoji_status_failed'\n          ? TE.left(new SetEmojiStatusError(response.payload.error))\n          : TE.right(undefined)\n      )),\n    );\n  }, {\n    ...rest,\n    requires: 'web_app_set_emoji_status',\n    returns: 'task',\n  });\n}\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Nothing if status set was successful.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @example\n * pipe(\n *   setEmojiStatusFp('5361800828313167608'),\n *   TE.match(error => {\n *     console.error('Error occurred', error);\n *   }, () => {\n *     console.log('Status set');\n *   }),\n * );\n * const statusSet = await setEmojiStatus('5361800828313167608');\n */\nexport const setEmojiStatusFp = create(pipe(\n  sharedFeatureOptions(),\n  withRequest,\n  withVersion,\n));\n\n/**\n * @see setEmojiStatusFp\n */\nexport const setEmojiStatus = throwifyWithChecksFp(setEmojiStatusFp);\n","import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n  PostEventError,\n} from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport * as E from 'fp-ts/Either';\n\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecksFp, type WithChecks } from '@/with-checks/withChecksFp.js';\n\ntype HapticFeedbackEither = E.Either<PostEventError, void>;\n\nexport interface HapticFeedbackOptions extends WithVersion, WithPostEvent, SharedFeatureOptions {\n}\n\n/**\n * @since Mini Apps v6.1\n */\nexport class HapticFeedback {\n  constructor({ postEvent, isTma, version }: HapticFeedbackOptions) {\n    const HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\n    const wrapSupported = createWithChecksFp({\n      requires: HAPTIC_METHOD_NAME,\n      isTma,\n      version,\n      returns: 'plain',\n    });\n\n    this.isSupported = createIsSupportedSignal(HAPTIC_METHOD_NAME, version);\n    this.impactOccurredFp = wrapSupported(style => {\n      return postEvent(HAPTIC_METHOD_NAME, { type: 'impact', impact_style: style });\n    });\n    this.notificationOccurredFp = wrapSupported(type => {\n      return postEvent(HAPTIC_METHOD_NAME, { type: 'notification', notification_type: type });\n    });\n    this.selectionChangedFp = wrapSupported(() => {\n      return postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n    });\n\n    this.impactOccurred = throwifyWithChecksFp(this.impactOccurredFp);\n    this.notificationOccurred = throwifyWithChecksFp(this.notificationOccurredFp);\n    this.selectionChanged = throwifyWithChecksFp(this.selectionChangedFp);\n  }\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * A method that tells if an impact occurred. The Telegram app may play the\n   * appropriate haptics based on style value passed.\n   * @param style - impact style.\n   * @since Mini Apps v6.1\n   */\n  impactOccurredFp: WithChecksFp<(style: ImpactHapticFeedbackStyle) => HapticFeedbackEither, true>;\n\n  /**\n   * @see impactOccurredFp\n   */\n  impactOccurred: WithChecks<(style: ImpactHapticFeedbackStyle) => void, true>;\n\n  /**\n   * A method tells that a task or action has succeeded, failed, or produced\n   * a warning. The Telegram app may play the appropriate haptics based on type\n   * value passed.\n   * @param type - notification type.\n   * @since Mini Apps v6.1\n   */\n  notificationOccurredFp: WithChecksFp<\n    (type: NotificationHapticFeedbackType) => HapticFeedbackEither,\n    true\n  >;\n\n  /**\n   * @see notificationOccurredFp\n   */\n  notificationOccurred: WithChecks<(type: NotificationHapticFeedbackType) => void, true>;\n\n  /**\n   * A method tells that the user has changed a selection. The Telegram app may\n   * play the appropriate haptics.\n   *\n   * Do not use this feedback when the user makes or confirms a selection; use\n   * it only when the selection changes.\n   * @since Mini Apps v6.1\n   */\n  selectionChangedFp: WithChecksFp<() => HapticFeedbackEither, true>;\n\n  /**\n   * @see selectionChangedFp\n   */\n  selectionChanged: WithChecks<() => void, true>;\n}\n","import { pipe } from 'fp-ts/function';\n\nimport { HapticFeedback } from '@/features/HapticFeedback/HapticFeedback.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport const hapticFeedback = new HapticFeedback(pipe(\n  sharedFeatureOptions(),\n  withPostEvent,\n  withVersion,\n));\n","import type { PostEventError } from '@tma.js/bridge';\nimport type * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n}\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((): E.Either<PostEventError, void> => {\n    return postEvent('web_app_add_to_home_screen');\n  }, { ...rest, requires: 'web_app_add_to_home_screen', returns: 'either' });\n}\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n */\nexport const addToHomeScreenFp = create(pipe(\n  sharedFeatureOptions(),\n  withVersion,\n  withPostEvent,\n));\n\n/**\n * @see addToHomeScreenFp\n */\nexport const addToHomeScreen = throwifyWithChecksFp(addToHomeScreenFp);\n","import type { HomeScreenStatus, RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((options?: AsyncOptions): TE.TaskEither<RequestError, HomeScreenStatus> => {\n    return pipe(\n      request('web_app_check_home_screen', 'home_screen_checked', options),\n      TE.map(response => response.status || 'unknown'),\n    );\n  }, { ...rest, requires: 'web_app_check_home_screen', returns: 'task' });\n}\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n */\nexport const checkHomeScreenStatusFp = create(pipe(\n  sharedFeatureOptions(),\n  withVersion,\n  withRequest,\n));\n\n/**\n * @see checkHomeScreenStatusFp\n */\nexport const checkHomeScreenStatus = throwifyWithChecksFp(checkHomeScreenStatusFp);\n","import { computed, type Computed, signal } from '@tma.js/signals';\nimport { throwifyFpFn } from '@tma.js/toolkit';\nimport type { InitData as InitDataType } from '@tma.js/types';\nimport * as E from 'fp-ts/Either';\nimport * as O from 'fp-ts/Option';\nimport { pipe } from 'fp-ts/function';\n\nexport interface InitDataOptions<Err> {\n  /**\n   * Retrieves init data from the current environment.\n   */\n  retrieveInitData: () => E.Either<Err, O.Option<{\n    raw: string;\n    obj: InitDataType;\n  }>>;\n}\n\nexport class InitData<Err extends Error> {\n  constructor({ retrieveInitData }: InitDataOptions<Err>) {\n    this.restoreFp = () => {\n      return pipe(\n        retrieveInitData(),\n        E.map(O.match(() => undefined, ({ raw, obj }) => {\n          this._state.set(obj);\n          this._raw.set(raw);\n        })),\n      );\n    };\n    this.restore = throwifyFpFn(this.restoreFp);\n  }\n\n  private fromState<K extends keyof InitDataType>(key: K): Computed<InitDataType[K] | undefined> {\n    return computed(() => {\n      const s = this._state();\n      return s ? s[key] : undefined;\n    });\n  }\n\n  private readonly _state = signal<InitDataType>();\n\n  private readonly _raw = signal<string>();\n\n  /**\n   * Complete component state.\n   */\n  readonly state = computed(this._state);\n\n  /**\n   * @see InitDataType.auth_date\n   */\n  readonly authDate = this.fromState('auth_date');\n\n  /**\n   * @see InitDataType.can_send_after\n   */\n  readonly canSendAfter = this.fromState('can_send_after');\n\n  /**\n   * Date after which it is allowed to call\n   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n   */\n  readonly canSendAfterDate = computed(() => {\n    const authDateValue = this.authDate();\n    const canSendAfterValue = this.canSendAfter();\n\n    return canSendAfterValue && authDateValue\n      ? new Date(authDateValue.getTime() + (canSendAfterValue * 1000))\n      : undefined;\n  });\n\n  /**\n   * @see InitDataType.chat\n   */\n  readonly chat = this.fromState('chat');\n\n  /**\n   * @see InitDataType.chat_type\n   */\n  readonly chatType = this.fromState('chat_type');\n\n  /**\n   * @see InitDataType.chat_instance\n   */\n  readonly chatInstance = this.fromState('chat_instance');\n\n  /**\n   * @see InitDataType.hash\n   */\n  readonly hash = this.fromState('hash');\n\n  /**\n   * @see InitDataType.query_id\n   */\n  readonly queryId = this.fromState('query_id');\n\n  /**\n   * Raw representation of init data.\n   */\n  readonly raw = computed(this._raw);\n\n  /**\n   * @see InitDataType.receiver\n   */\n  readonly receiver = this.fromState('receiver');\n\n  /**\n   * @see InitDataType.signature\n   */\n  readonly signature = this.fromState('signature');\n\n  /**\n   * @see InitDataType.start_param\n   */\n  readonly startParam = this.fromState('start_param');\n\n  /**\n   * @see InitDataType.user\n   */\n  readonly user = this.fromState('user');\n\n  /**\n   * Restores the component state.\n   */\n  readonly restoreFp: () => E.Either<Err, void>;\n\n  /**\n   * @see restoreFp\n   */\n  readonly restore: () => void;\n}\n","import { retrieveRawInitDataFp, retrieveLaunchParamsFp } from '@tma.js/bridge';\nimport * as E from 'fp-ts/Either';\nimport * as O from 'fp-ts/Option';\nimport { pipe } from 'fp-ts/function';\n\nimport { InitData } from '@/features/InitData/InitData.js';\n\nexport const initData = new InitData({\n  retrieveInitData() {\n    return pipe(\n      E.Do,\n      E.bindW('obj', () => pipe(\n        retrieveLaunchParamsFp(),\n        E.map(({ tgWebAppData }) => {\n          return tgWebAppData ? O.some(tgWebAppData) : O.none;\n        }),\n      )),\n      E.bindW('raw', retrieveRawInitDataFp),\n      E.map(({ obj, raw }) => {\n        return pipe(\n          O.Do,\n          O.bind('obj', () => obj),\n          O.bind('raw', () => raw),\n        );\n      }),\n    );\n  },\n});\n","import type { InvoiceStatus, RequestError } from '@tma.js/bridge';\nimport { computed, type Computed, signal } from '@tma.js/signals';\nimport { BetterPromise } from 'better-promises';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { ConcurrentCallError, InvalidArgumentsError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithRequest } from '@/fn-options/withRequest.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecks, type WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype InvoiceTask<E, T> = TE.TaskEither<RequestError | ConcurrentCallError | E, T>;\n\nexport interface InvoiceOptions extends WithVersion, WithRequest, SharedFeatureOptions {\n}\n\n/**\n * @since Mini Apps v6.1\n */\nexport class Invoice {\n  constructor({ version, request, isTma }: InvoiceOptions) {\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      isTma,\n      requires: 'web_app_open_invoice',\n      returns: 'task',\n    });\n\n    const isOpened = signal(false);\n    const toggleClosed = () => {\n      isOpened.set(false);\n    };\n\n    this.isSupported = createIsSupportedSignal('web_app_open_invoice', version);\n    this.isOpened = computed(isOpened);\n    this.openSlugFp = wrapSupportedTask((slug, options) => {\n      return pipe(\n        this.isOpened()\n          ? TE.left(new ConcurrentCallError('Invoice is already opened'))\n          : TE.right(undefined as never),\n        TE.chain(() => {\n          isOpened.set(true);\n          return request('web_app_open_invoice', 'invoice_closed', {\n            ...options,\n            params: { slug },\n            capture: data => slug === data.slug,\n          });\n        }),\n        TE.mapBoth(err => {\n          toggleClosed();\n          return err;\n        }, data => {\n          toggleClosed();\n          return data.status;\n        }),\n      );\n    });\n    this.openUrlFp = wrapSupportedTask((url, options) => {\n      const { hostname, pathname } = new URL(url, window.location.href);\n      if (hostname !== 't.me') {\n        return TE.left(new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`));\n      }\n\n      // Valid examples:\n      // \"/invoice/my-slug\"\n      // \"/$my-slug\"\n      const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n      if (!match) {\n        return TE.left(new InvalidArgumentsError(\n          'Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/${slug}\"',\n        ));\n      }\n      return this.openSlugFp(match[2], options);\n    });\n\n    this.openUrl = throwifyWithChecksFp(this.openUrlFp);\n    this.openSlug = throwifyWithChecksFp(this.openSlugFp);\n  }\n\n  /**\n   * Signal indicating if any invoice is currently opened.\n   */\n  readonly isOpened: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Opens an invoice using its slug or URL.\n   * @param slug - invoice slug.\n   * @param options - additional options.\n   * @since Mini Apps v6.1\n   * @example\n   * const status = await invoice.openSlug('kJNFS331');\n   */\n  readonly openSlugFp: WithChecksFp<\n    (slug: string, options?: AsyncOptions) => InvoiceTask<never, InvoiceStatus>,\n    true\n  >;\n\n  /**\n   * @see openSlugFp\n   */\n  readonly openSlug: WithChecks<\n    (slug: string, options?: AsyncOptions) => BetterPromise<InvoiceStatus>,\n    true\n  >;\n\n  /**\n   * Opens an invoice using its URL.\n   * @param url - invoice URL.\n   * @param options - additional options.\n   * @since Mini Apps v6.1\n   * @example\n   * const status = await invoice.openUrl('https://t.me/$kJNFS331');\n   */\n  readonly openUrlFp: WithChecksFp<\n    (url: string, options?: AsyncOptions) => (\n      InvoiceTask<InvalidArgumentsError, InvoiceStatus>\n    ),\n    true\n  >;\n\n  /**\n   * @see openUrlFp\n   */\n  readonly openUrl: WithChecks<\n    (url: string, options?: AsyncOptions) => BetterPromise<InvoiceStatus>,\n    true\n  >;\n}\n","import { pipe } from 'fp-ts/function';\n\nimport { Invoice } from '@/features/Invoice/Invoice.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport const invoice = new Invoice(pipe(sharedFeatureOptions(), withRequest, withVersion));\n","import type { OpenLinkBrowser, PostEventError } from '@tma.js/bridge';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { InvalidArgumentsError } from '@/errors.js';\nimport {\n  type SharedFeatureOptions,\n  sharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { type WithPostEvent, withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent {\n}\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nexport type OpenLinkError = PostEventError | InvalidArgumentsError;\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((\n    url: string | URL,\n    options: OpenLinkOptions = {},\n  ): E.Either<OpenLinkError, void> => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        return E.left(new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e));\n      }\n    }\n    return postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  }, { ...rest, returns: 'either' });\n}\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @example\n * openLink('https://google.com', {\n *   tryInstantView: true,\n *   tryBrowser: 'chrome',\n * });\n */\nexport const openLinkFp = create(pipe(\n  sharedFeatureOptions(),\n  withPostEvent,\n));\n\nexport const openLink = throwifyWithChecksFp(openLinkFp);\n","import { supports, type PostEventError } from '@tma.js/bridge';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { InvalidArgumentsError } from '@/errors.js';\nimport {\n  type SharedFeatureOptions,\n  sharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { access } from '@/helpers/access.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n}\n\nexport type OpenTelegramLinkError = PostEventError | InvalidArgumentsError;\n\nfunction create({ postEvent, version, ...rest }: CreateOptions) {\n  return withChecksFp((\n    url: string | URL,\n  ): E.Either<OpenTelegramLinkError, void> => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      return E.left(new InvalidArgumentsError(`\"${urlString}\" is invalid URL`));\n    }\n\n    if (supports('web_app_open_tg_link', access(version))) {\n      url = new URL(url);\n      return postEvent('web_app_open_tg_link', { path_full: url.pathname + url.search });\n    }\n\n    window.location.href = urlString;\n    return E.right(undefined);\n  }, { ...rest, returns: 'either' });\n}\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @example\n * openTelegramLink('https://t.me/heyqbnk');\n */\nexport const openTelegramLinkFp = create(pipe(\n  sharedFeatureOptions(),\n  withPostEvent,\n  withVersion,\n));\n\n/**\n * @see openTelegramLinkFp\n */\nexport const openTelegramLink = throwifyWithChecksFp(openTelegramLinkFp);\n","import type { PostEventError } from '@tma.js/bridge';\nimport type * as E from 'fp-ts/Either';\n\nimport { openTelegramLinkFp } from '@/features/links/openTelegramLink.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions {\n  openTelegramLink: (url: string) => E.Either<PostEventError, void>;\n}\n\nexport type ShareURLError = PostEventError;\n\nfunction create({ openTelegramLink, ...rest }: CreateOptions) {\n  return withChecksFp((url: string, text?: string): E.Either<ShareURLError, void> => {\n    return openTelegramLink(\n      'https://t.me/share/url?' + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  }, { ...rest, returns: 'either' });\n}\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURLFp = create({\n  ...sharedFeatureOptions(),\n  openTelegramLink: openTelegramLinkFp,\n});\n\n/**\n * @see shareURLFp\n */\nexport const shareURL = throwifyWithChecksFp(shareURLFp);\n","import type { EventPayload, RequestError, PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport type { Maybe } from '@tma.js/toolkit';\nimport { BetterPromise } from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { AsyncMountable } from '@/composables/AsyncMountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport type {\n  LocationManagerOptions,\n  LocationManagerRequestLocationResponse,\n  LocationManagerState,\n} from '@/features/LocationManager/types.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecks, type WithChecksFp } from '@/with-checks/withChecksFp.js';\n\nfunction eventToState(event: EventPayload<'location_checked'>): LocationManagerState {\n  let available = false;\n  let accessRequested: Maybe<boolean>;\n  let accessGranted: Maybe<boolean>;\n  if (event.available) {\n    available = true;\n    accessRequested = event.access_requested;\n    accessGranted = event.access_granted;\n  }\n  return {\n    available,\n    accessGranted: accessGranted || false,\n    accessRequested: accessRequested || false,\n  };\n}\n\n/**\n * @since Mini Apps v8.0\n */\nexport class LocationManager {\n  constructor({\n    version,\n    request,\n    postEvent,\n    storage,\n    isTma,\n    isPageReload,\n  }: LocationManagerOptions) {\n    const stateful = new Stateful({\n      initialState: {\n        available: false,\n        accessGranted: false,\n        accessRequested: false,\n      },\n      onChange: storage.set,\n    });\n    const mountable = new AsyncMountable<LocationManagerState, RequestError>({\n      isPageReload,\n      restoreState: storage.get,\n      onMounted: stateful.setState,\n      initialState(options) {\n        return pipe(\n          request('web_app_check_location', 'location_checked', options),\n          TE.map(eventToState),\n        );\n      },\n    });\n\n    const wrapOptions = { version, requires: 'web_app_check_location', isTma } as const;\n    const wrapSupportedEither = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'either',\n    });\n    const wrapSupportedTask = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'task',\n    });\n    const wrapMountedTask = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'task',\n      isMounted: mountable.isMounted,\n    });\n\n    this.isAvailable = stateful.getter('available');\n    this.isAccessRequested = stateful.getter('accessRequested');\n    this.isAccessGranted = stateful.getter('accessGranted');\n    this.isSupported = createIsSupportedSignal('web_app_check_location', version);\n    this.isMounted = mountable.isMounted;\n    this.state = stateful.state;\n\n    this.unmount = mountable.unmount;\n    this.mountFp = wrapSupportedTask(mountable.mount);\n    this.openSettingsFp = wrapSupportedEither(() => {\n      return postEvent('web_app_open_location_settings');\n    });\n    this.requestLocationFp = wrapMountedTask(options => {\n      return pipe(\n        request('web_app_request_location', 'location_requested', options),\n        TE.map(response => {\n          if (!response.available) {\n            stateful.setState({ available: false });\n            return null;\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { available, ...rest } = response;\n          return rest;\n        }),\n      );\n    });\n\n    this.mount = throwifyWithChecksFp(this.mountFp);\n    this.openSettings = throwifyWithChecksFp(this.openSettingsFp);\n    this.requestLocation = throwifyWithChecksFp(this.requestLocationFp);\n  }\n\n  /**\n   * Complete location manager state.\n   */\n  readonly state: Computed<LocationManagerState>;\n\n  /**\n   * Signal indicating whether the location data tracking is currently available.\n   */\n  readonly isAvailable: Computed<boolean>;\n\n  /**\n   * Signal indicating whether the user has granted the app permission to track location data.\n   */\n  readonly isAccessGranted: Computed<boolean>;\n\n  /**\n   * Signal indicating whether the app has previously requested permission to track location data.\n   */\n  readonly isAccessRequested: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Opens the location access settings for bots. Useful when you need to request location access\n   * from users who haven't granted it yet.\n   *\n   * Note that this method can be called only in response to user interaction with the Mini App\n   * interface (e.g., a click inside the Mini App or on the main button).\n   * @since Mini Apps v8.0\n   */\n  readonly openSettingsFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see openSettingsFp\n   */\n  readonly openSettings: WithChecks<() => void, true>;\n\n  /**\n   * Requests location data.\n   * @since Mini Apps v8.0\n   * @returns Promise with location data or null it access was not granted.\n   */\n  readonly requestLocationFp: WithChecksFp<\n    (options?: AsyncOptions) => (\n      TE.TaskEither<RequestError, LocationManagerRequestLocationResponse | null>\n    ),\n    true\n  >;\n\n  /**\n   * @see requestLocationFp\n   */\n  readonly requestLocation: WithChecks<\n    (options?: AsyncOptions) => BetterPromise<LocationManagerRequestLocationResponse | null>,\n    true\n  >;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v8.0\n   */\n  readonly mountFp: WithChecksFp<\n    (options?: AsyncOptions) => TE.TaskEither<RequestError, void>,\n    true\n  >;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, true>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n}\n","import { pipe } from 'fp-ts/function';\n\nimport { LocationManager } from '@/features/LocationManager/LocationManager.js';\nimport type { LocationManagerState } from '@/features/LocationManager/types.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport const locationManager = new LocationManager(pipe(\n  sharedFeatureOptions(),\n  withPostEvent,\n  withVersion,\n  withRequest,\n  withStateRestore<LocationManagerState>('locationManager'),\n));\n","import type { PostEventError } from '@tma.js/bridge';\nimport { computed, type Computed } from '@tma.js/signals';\nimport type { RGB } from '@tma.js/types';\nimport * as E from 'fp-ts/Either';\n\nimport { Button, type ButtonOptions } from '@/composables/Button.js';\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\nimport type { WithChecks, WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype MainButtonEither = E.Either<PostEventError, void>;\n\nexport interface MainButtonState {\n  isVisible: boolean;\n  bgColor?: RGB;\n  hasShineEffect: boolean;\n  isEnabled: boolean;\n  isLoaderVisible: boolean;\n  text: string;\n  textColor?: RGB;\n}\n\nexport interface MainButtonOptions extends Omit<\n  ButtonOptions<MainButtonState, 'web_app_setup_main_button'>,\n  'initialState' | 'method' | 'payload' | 'version'\n> {\n  /**\n   * Default values for different kinds of the button properties.\n   */\n  defaults: {\n    bgColor: MaybeAccessor<RGB>;\n    textColor: MaybeAccessor<RGB>;\n  };\n}\n\nexport class MainButton {\n  constructor({ defaults, ...options }: MainButtonOptions) {\n    const button = new Button({\n      ...options,\n      version: '100',\n      initialState: {\n        hasShineEffect: false,\n        isEnabled: true,\n        isLoaderVisible: false,\n        isVisible: false,\n        text: 'Continue',\n      },\n      method: 'web_app_setup_main_button',\n      payload: state => ({\n        has_shine_effect: state.hasShineEffect,\n        is_visible: state.isVisible,\n        is_active: state.isEnabled,\n        is_progress_visible: state.isLoaderVisible,\n        text: state.text,\n        color: state.bgColor,\n        text_color: state.textColor,\n      }),\n    });\n\n    const withDefault = (\n      field: 'bgColor' | 'textColor',\n      getDefault: MaybeAccessor<RGB>,\n    ) => {\n      const fromState = button.stateGetter(field);\n      return computed(() => fromState() || access(getDefault));\n    };\n\n    this.bgColor = withDefault('bgColor', defaults.bgColor);\n    this.textColor = withDefault('textColor', defaults.textColor);\n    this.hasShineEffect = button.stateGetter('hasShineEffect');\n    this.isEnabled = button.stateGetter('isEnabled');\n    this.isLoaderVisible = button.stateGetter('isLoaderVisible');\n    this.text = button.stateGetter('text');\n    this.isVisible = button.stateGetter('isVisible');\n    this.isMounted = button.isMounted;\n    this.state = button.state;\n\n    [this.setBgColor, this.setBgColorFp] = button.stateSetters('bgColor');\n    [this.setTextColor, this.setTextColorFp] = button.stateSetters('textColor');\n    [\n      [this.disableShineEffect, this.disableShineEffectFp],\n      [this.enableShineEffect, this.enableShineEffectFp],\n    ] = button.stateBoolSetters('hasShineEffect');\n    [\n      [this.disable, this.disableFp],\n      [this.enable, this.enableFp],\n    ] = button.stateBoolSetters('isEnabled');\n    [\n      [this.hideLoader, this.hideLoaderFp],\n      [this.showLoader, this.showLoaderFp],\n    ] = button.stateBoolSetters('isLoaderVisible');\n\n    [this.setText, this.setTextFp] = button.stateSetters('text');\n    [[this.hide, this.hideFp], [this.show, this.showFp]] = button.stateBoolSetters('isVisible');\n    this.setParams = button.setState;\n    this.setParamsFp = button.setStateFp;\n    this.onClick = button.onClick;\n    this.onClickFp = button.onClickFp;\n    this.offClick = button.offClick;\n    this.offClickFp = button.offClickFp;\n    this.mount = button.mount;\n    this.mountFp = button.mountFp;\n    this.unmount = button.unmount;\n  }\n\n  //#region Properties.\n  /**\n   * The button background color.\n   */\n  readonly bgColor: Computed<RGB>;\n\n  /**\n   * True if the button has a shining effect.\n   */\n  readonly hasShineEffect: Computed<boolean>;\n\n  /**\n   * True if the button is clickable.\n   */\n  readonly isEnabled: Computed<boolean>;\n\n  /**\n   * True if the button loader is visible.\n   */\n  readonly isLoaderVisible: Computed<boolean>;\n\n  /**\n   * True if the button is visible.\n   */\n  readonly isVisible: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * The complete button state.\n   */\n  readonly state: Computed<MainButtonState>;\n\n  /**\n   * The button displayed text.\n   */\n  readonly text: Computed<string>;\n\n  /**\n   * The button text color.\n   *\n   * Note that this value is computed based on the external defaults. For\n   * example, if not explicitly set, this value may be equal to one of theme\n   * params colors.\n   */\n  readonly textColor: Computed<RGB>;\n  //#endregion\n\n  //#region Methods.\n  /**\n   * Shows the button.\n   */\n  readonly showFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<() => void, false>;\n\n  /**\n   * Hides the button.\n   */\n  readonly hideFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see hideFp\n   */\n  readonly hide: WithChecks<() => void, false>;\n\n  /**\n   * Enables the button.\n   */\n  readonly enableFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see enableFp\n   */\n  readonly enable: WithChecks<() => void, false>;\n\n  /**\n   * Enables the button.\n   */\n  readonly enableShineEffectFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see enableShineEffectFp\n   */\n  readonly enableShineEffect: WithChecks<() => void, false>;\n\n  /**\n   * Disables the button.\n   */\n  readonly disableFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see disableFp\n   */\n  readonly disable: WithChecks<() => void, false>;\n\n  /**\n   * Enables the button.\n   */\n  readonly disableShineEffectFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see disableShineEffectFp\n   */\n  readonly disableShineEffect: WithChecks<() => void, false>;\n\n  /**\n   * Updates the button background color.\n   */\n  readonly setBgColorFp: WithChecksFp<(value: RGB) => MainButtonEither, false>;\n\n  /**\n   * @see setBgColorFp\n   */\n  readonly setBgColor: WithChecks<(value: RGB) => void, false>;\n\n  /**\n   * Updates the button text color.\n   */\n  readonly setTextColorFp: WithChecksFp<(value: RGB) => MainButtonEither, false>;\n\n  /**\n   * @see setTextColorFp\n   */\n  readonly setTextColor: WithChecks<(value: RGB) => void, false>;\n\n  /**\n   * Updates the button text.\n   */\n  readonly setTextFp: WithChecksFp<(value: string) => MainButtonEither, false>;\n\n  /**\n   * @see setTextFp\n   */\n  readonly setText: WithChecks<(value: string) => void, false>;\n\n  /**\n   * Shows the button loader.\n   */\n  readonly showLoaderFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see showLoaderFp\n   */\n  readonly showLoader: WithChecks<() => void, false>;\n\n  /**\n   * Hides the button loader.\n   */\n  readonly hideLoaderFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see hideLoaderFp\n   */\n  readonly hideLoader: WithChecks<() => void, false>;\n\n  /**\n   * Updates the button state.\n   * @param state - updates to apply.\n   * @example\n   * button.setParams({\n   *   text: 'Submit',\n   *   isEnabled: true,\n   *   hasShineEffect: true,\n   * });\n   */\n  readonly setParamsFp: WithChecksFp<(state: Partial<MainButtonState>) => MainButtonEither, false>;\n\n  readonly setParams: WithChecks<(state: Partial<MainButtonState>) => void, false>;\n\n  /**\n   * Mounts the component restoring its state.\n   */\n  readonly mountFp: WithChecksFp<() => void, false>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, false>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => VoidFunction, false>;\n\n  /**\n   * @see onClickFp\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, false>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => void, false>;\n\n  /**\n   * @see offClickFp\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, false>;\n  //#endregion\n}\n","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n","import { throwifyFpFn } from '@tma.js/toolkit';\nimport { toRGBFullFp } from '@tma.js/transformers';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDarkFp(color: string): E.Either<Error, boolean> {\n  return pipe(\n    toRGBFullFp(color),\n    E.map(rgb => {\n      // Actual formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n      // See: https://stackoverflow.com/a/596243\n      return Math.sqrt(\n        [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n          // Extract part of #RRGGBB pattern and convert it to DEC.\n          const dec = parseInt(rgb.slice(1 + (idx * 2), 1 + ((idx + 1) * 2)), 16);\n          return acc + (dec * dec * modifier);\n        }, 0),\n      ) < 120;\n    }),\n  );\n}\n\n/**\n * @see isColorDarkFp\n */\nexport const isColorDark = throwifyFpFn(isColorDarkFp);\n","import type { EventListener } from '@tma.js/bridge';\nimport { computed, type Computed, signal } from '@tma.js/signals';\nimport { snakeToKebab } from '@tma.js/toolkit';\nimport type { ThemeParams as ThemeParamsType, RGB } from '@tma.js/types';\nimport * as E from 'fp-ts/Either';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport { access } from '@/helpers/access.js';\nimport { deleteCssVar, setCssVar } from '@/helpers/css-vars.js';\nimport { isColorDark } from '@/helpers/isColorDark.js';\nimport type { MaybeAccessor } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport type ThemeParamsState = ThemeParamsType;\n\nexport interface ThemeParamsOptions extends WithStateRestore<ThemeParamsState>,\n  SharedFeatureOptions {\n  /**\n   * Removes a theme change listener.\n   * @param listener - a listener to remove.\n   */\n  offChange: (listener: EventListener<'theme_changed'>) => void;\n  /**\n   * Adds a theme change listener.\n   * @returns A function to remove listener.\n   * @param listener - a listener to add.\n   */\n  onChange: (listener: EventListener<'theme_changed'>) => void;\n  /**\n   * Theme parameters initial state.\n   */\n  initialState: MaybeAccessor<ThemeParamsType>;\n}\n\nexport interface ThemeParamsGetCssVarNameFn {\n  /**\n   * @param property - palette key.\n   * @returns Computed complete CSS variable name.\n   */\n  (property: Extract<keyof ThemeParamsType, string>): string;\n}\n\nexport class ThemeParams {\n  constructor({\n    initialState,\n    onChange,\n    offChange,\n    isTma,\n    storage,\n    isPageReload,\n  }: ThemeParamsOptions) {\n    const stateful = new Stateful<ThemeParamsState>({\n      initialState: {},\n      onChange: storage.set,\n    });\n    const listener: EventListener<'theme_changed'> = event => {\n      stateful.setState(event.theme_params);\n    };\n    const mountable = new Mountable<ThemeParamsType>({\n      initialState: () => E.right(access(initialState)),\n      isPageReload,\n      onMounted(state) {\n        stateful.setState(state);\n        onChange(listener);\n      },\n      onUnmounted() {\n        offChange(listener);\n      },\n      restoreState: storage.get,\n    });\n\n    const wrapOptions = { isTma, returns: 'either' } as const;\n    const wrapSupportedEither = createWithChecksFp(wrapOptions);\n    const wrapMountedEither = createWithChecksFp({\n      ...wrapOptions,\n      isMounted: mountable.isMounted,\n    });\n\n    // Colors.\n    this.accentTextColor = stateful.getter('accent_text_color');\n    this.bgColor = stateful.getter('bg_color');\n    this.buttonColor = stateful.getter('button_color');\n    this.buttonTextColor = stateful.getter('button_text_color');\n    this.bottomBarBgColor = stateful.getter('bottom_bar_bg_color');\n    this.destructiveTextColor = stateful.getter('destructive_text_color');\n    this.headerBgColor = stateful.getter('header_bg_color');\n    this.hintColor = stateful.getter('hint_color');\n    this.linkColor = stateful.getter('link_color');\n    this.secondaryBgColor = stateful.getter('secondary_bg_color');\n    this.sectionBgColor = stateful.getter('section_bg_color');\n    this.sectionHeaderTextColor = stateful.getter('section_header_text_color');\n    this.sectionSeparatorColor = stateful.getter('section_separator_color');\n    this.subtitleTextColor = stateful.getter('subtitle_text_color');\n    this.textColor = stateful.getter('text_color');\n\n    // Other public signals.\n    this.state = stateful.state;\n    this.isMounted = mountable.isMounted;\n    this.bindCssVarsFp = wrapMountedEither(getCSSVarName => {\n      if (this._isCssVarsBound()) {\n        return E.left(new CSSVarsBoundError());\n      }\n      getCSSVarName ||= prop => `--tg-theme-${snakeToKebab(prop)}`;\n\n      const forEachEntry = (fn: (key: string, value: RGB) => void): void => {\n        Object.entries(stateful.state()).forEach(([k, v]) => {\n          v && fn(k, v);\n        });\n      };\n\n      const actualize = (): void => {\n        forEachEntry((k, v) => {\n          setCssVar(getCSSVarName(k), v);\n        });\n      };\n\n      actualize();\n      stateful.state.sub(actualize);\n      this._isCssVarsBound.set(true);\n\n      return E.right(() => {\n        forEachEntry(deleteCssVar);\n        stateful.state.unsub(actualize);\n        this._isCssVarsBound.set(false);\n      });\n    });\n    this.mountFp = wrapSupportedEither(mountable.mount);\n    this.unmount = mountable.unmount;\n\n    this.bindCssVars = throwifyWithChecksFp(this.bindCssVarsFp);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n  }\n\n  //#region Colors.\n  /**\n   * @since v6.10\n   */\n  readonly accentTextColor: Computed<RGB | undefined>;\n\n  readonly bgColor: Computed<RGB | undefined>;\n\n  readonly buttonColor: Computed<RGB | undefined>;\n\n  readonly buttonTextColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v7.10\n   */\n  readonly bottomBarBgColor: Computed<RGB | undefined>;\n\n  readonly destructiveTextColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v6.10\n   */\n  readonly headerBgColor: Computed<RGB | undefined>;\n\n  readonly hintColor: Computed<RGB | undefined>;\n\n  readonly linkColor: Computed<RGB | undefined>;\n\n  readonly secondaryBgColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v6.10\n   */\n  readonly sectionBgColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v6.10\n   */\n  readonly sectionHeaderTextColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v7.6\n   */\n  readonly sectionSeparatorColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v6.10\n   */\n  readonly subtitleTextColor: Computed<RGB | undefined>;\n\n  readonly textColor: Computed<RGB | undefined>;\n  //#endregion\n\n  //#region CSS variables.\n  private readonly _isCssVarsBound = signal(false);\n\n  /**\n   * True if CSS variables are currently bound.\n   */\n  readonly isCssVarsBound = computed(this._isCssVarsBound);\n\n  /**\n   * Creates CSS variables connected with the current theme parameters.\n   *\n   * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n   * {name} is a theme parameters key name converted from snake case to kebab case.\n   *\n   * Default variables:\n   * - `--tg-theme-bg-color`\n   * - `--tg-theme-secondary-text-color`\n   *\n   * Variables are being automatically updated if theme parameters were changed.\n   *\n   * @param getCSSVarName - function, returning complete CSS variable name for the specified\n   * theme parameters key.\n   * @returns Function to stop updating variables.\n   * @throws {CSSVarsBoundError} CSS variables are already bound\n   * @example Using custom CSS vars generator\n   * themeParams.bindCssVars(key => `--my-prefix-${key}`);\n   */\n  readonly bindCssVarsFp: WithChecksFp<\n    (getCSSVarName?: ThemeParamsGetCssVarNameFn) => E.Either<CSSVarsBoundError, VoidFunction>,\n    false\n  >;\n\n  /**\n   * @see bindCssVarsFp\n   */\n  readonly bindCssVars: WithChecks<\n    (getCSSVarName?: ThemeParamsGetCssVarNameFn) => VoidFunction,\n    false\n  >;\n  //#endregion\n\n  //#region Other public signals.\n  /**\n   * Complete component state.\n   */\n  readonly state: Computed<ThemeParamsType>;\n\n  /**\n   * @returns True if the current color scheme is recognized as dark.\n   * This value is calculated based on the current theme's background color.\n   */\n  readonly isDark = computed(() => {\n    const color = this.bgColor();\n    return !color || isColorDark(color);\n  });\n  //#endregion\n\n  //#region Mounting.\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component restoring its state.\n   */\n  readonly mountFp: WithChecksFp<() => E.Either<never, void>, false>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, false>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n  //#endregion\n}\n","import type { ThemeParams } from '@tma.js/types';\n\nimport { createSignal } from '@/globals/signals-registry.js';\n\n/**\n * Mini application's theme parameters.\n */\nexport const themeParams = createSignal<ThemeParams>({});\n","import { on, off } from '@tma.js/bridge';\nimport { pipe } from 'fp-ts/function';\n\nimport { ThemeParams, type ThemeParamsState } from '@/features/ThemeParams/ThemeParams.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { themeParams as globalThemeParams } from '@/globals/themeParams.js';\n\nexport const themeParams = new ThemeParams({\n  ...pipe(\n    sharedFeatureOptions(),\n    withStateRestore<ThemeParamsState>('themeParams'),\n  ),\n  offChange(listener) {\n    off('theme_changed', listener);\n  },\n  onChange(listener) {\n    on('theme_changed', listener);\n  },\n  initialState: globalThemeParams,\n});\n","import type { EventName } from '@tma.js/bridge';\nimport { pipe } from 'fp-ts/function';\n\nimport { buttonOptions } from '@/fn-options/buttonOptions.js';\n\nexport function bottomButtonOptions<S, D>(\n  storageName: string,\n  trackedClickEvent: EventName,\n  defaults: D,\n) {\n  return pipe(\n    buttonOptions<S>(storageName, trackedClickEvent),\n    obj => ({ ...obj, defaults }),\n  );\n}\n","import { computed } from '@tma.js/signals';\n\nimport { MainButton } from '@/features/MainButton/MainButton.js';\nimport { themeParams } from '@/features/ThemeParams/instance.js';\nimport { bottomButtonOptions } from '@/fn-options/bottomButtonOptions.js';\n\nexport const mainButton = new MainButton(\n  bottomButtonOptions('mainButton', 'main_button_pressed', {\n    bgColor: computed(() => themeParams.buttonColor() || '#2481cc'),\n    textColor: computed(() => themeParams.buttonTextColor() || '#ffffff'),\n  }),\n);\n","import {\n  supports,\n  type PostEventError,\n  type EventPayload,\n  type EventListener,\n} from '@tma.js/bridge';\nimport { type Computed, computed } from '@tma.js/signals';\nimport { signal } from '@tma.js/signals';\nimport { createCbCollector, camelToKebab } from '@tma.js/toolkit';\nimport { isRGB } from '@tma.js/transformers';\nimport type { KnownThemeParamsKey, RGB, ThemeParams } from '@tma.js/types';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport { CSSVarsBoundError, UnknownThemeParamsKeyError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { access } from '@/helpers/access.js';\nimport { deleteCssVar, setCssVar } from '@/helpers/css-vars.js';\nimport { isColorDark } from '@/helpers/isColorDark.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  withChecksFp,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\ntype AnyColor = RGB | KnownThemeParamsKey | string;\n\nexport interface MiniAppState {\n  bgColor: AnyColor;\n  bottomBarColor: AnyColor;\n  headerColor: AnyColor;\n  isActive: boolean;\n}\n\nexport interface MiniAppGetCssVarNameFn {\n  /**\n   * @param property - mini app property.\n   * @returns Computed complete CSS variable name.\n   */\n  (property: 'bgColor' | 'bottomBarColor' | 'headerColor'): string;\n}\n\ntype WithListeners<Handlers extends string, Payload> = {\n  [K in Handlers]: (listener: (payload: Payload) => void) => void;\n};\n\nexport interface MiniAppOptions extends WithPostEvent,\n  WithVersion,\n  WithStateRestore<MiniAppState>,\n  WithListeners<'onVisibilityChanged' | 'offVisibilityChanged', EventPayload<'visibility_changed'>>,\n  SharedFeatureOptions {\n  /**\n   * The current theme parameters.\n   */\n  theme: Computed<ThemeParams>;\n}\n\n/**\n * @since Mini Apps v6.1\n */\nexport class MiniApp {\n  constructor({\n    storage,\n    isPageReload,\n    version,\n    postEvent,\n    isTma,\n    theme,\n    onVisibilityChanged,\n    offVisibilityChanged,\n  }: MiniAppOptions) {\n    //#region Mounting.\n    const visibilityChangedListener: EventListener<'visibility_changed'> = event => {\n      stateful.setState({ isActive: event.is_visible });\n    };\n    const themeChangedListener = (theme: ThemeParams) => {\n      // Sometimes we may have the following colors to be specified as some theme params keys.\n      // Due to the Mini Apps nature, we are not really allowed to do that, but we want to provide\n      // such an opportunity to developers.\n      //\n      // So if the developer specified some field as a reference to some theme params key, we\n      // should find an according RGB color for it and send it to the Telegram client. We have one\n      // exclusion here - the method 'web_app_set_header_color' may accept values 'bg_color'\n      // and 'secondary_bg_color'. Other methods accept only RGB values.\n      ([\n        [this.headerColor, 'web_app_set_header_color'],\n        [this.bgColor, 'web_app_set_background_color'],\n        [this.bottomBarColor, 'web_app_set_bottom_bar_color'],\n      ] as const).forEach(([signal, method]) => {\n        const color = signal();\n        // The value is already in RGB format, we have nothing to update here.\n        if (isRGB(color)) {\n          return;\n        }\n        // The real RGB value should only be extracted for the following methods:\n        // - 'web_app_set_background_color'\n        // - 'web_app_set_bottom_bar_color'\n        // We should also do it in case of the 'web_app_set_header_color' method, if the value\n        // specified is not 'bg_color' and 'secondary_bg_color' (unknown key to\n        // the Telegram client).\n        if (\n          method !== 'web_app_set_header_color'\n          || !['bg_color', 'secondary_bg_color'].includes(color)\n        ) {\n          const rgb = theme[color];\n          if (rgb) {\n            postEvent(method, { color: rgb });\n          }\n        }\n      });\n    };\n    const mountable = new Mountable({\n      initialState() {\n        return E.right({\n          bgColor: 'bg_color',\n          headerColor: 'header_bg_color',\n          bottomBarColor: 'bottom_bar_bg_color',\n          isActive: true,\n        });\n      },\n      isPageReload,\n      onMounted: state => {\n        onVisibilityChanged(visibilityChangedListener);\n        theme.sub(themeChangedListener);\n        stateful.setState(state);\n      },\n      onUnmounted() {\n        offVisibilityChanged(visibilityChangedListener);\n        theme.unsub(themeChangedListener);\n      },\n      restoreState: storage.get,\n    });\n    this.isMounted = mountable.isMounted;\n    this.mountFp = withChecksFp(() => {\n      const nothing = () => undefined;\n      return pipe(mountable.mount(), E.match(nothing, nothing));\n    }, { isTma, returns: 'plain' });\n    this.mount = throwifyWithChecksFp(this.mountFp);\n    this.unmount = mountable.unmount;\n    //#endregion\n\n    //#region State.\n    const stateful = new Stateful({\n      initialState: {\n        bgColor: 'bg_color',\n        bottomBarColor: 'bottom_bar_bg_color',\n        headerColor: 'bg_color',\n        isActive: false,\n      },\n      onChange: storage.set,\n    });\n    this.state = stateful.state;\n\n    const rgbBasedOn = (color: AnyColor): RGB | undefined => {\n      return isRGB(color) ? color : access(theme)[color];\n    };\n    const computedRgbBasedOn = (signal: Computed<AnyColor>): Computed<RGB | undefined> => {\n      return computed(() => rgbBasedOn(signal()));\n    };\n    //#endregion\n\n    //#region Other properties.\n    this.isActive = stateful.getter('isActive');\n    this.isSupported = computed(() => {\n      return ([\n        'web_app_set_header_color',\n        'web_app_set_background_color',\n        'web_app_set_bottom_bar_color',\n      ] as const).some(method => supports(method, access(version)));\n    });\n    //#endregion\n\n    //#region Css vars.\n    const isCssVarsBound = signal(false);\n    this.isCssVarsBound = computed(isCssVarsBound);\n    this.bindCssVarsFp = withChecksFp(getCSSVarName => {\n      if (isCssVarsBound()) {\n        return E.left(new CSSVarsBoundError());\n      }\n      const [addCleanup, cleanup] = createCbCollector(() => {\n        isCssVarsBound.set(false);\n      });\n\n      const bind = (cssVar: string, signal: Computed<RGB | undefined>) => {\n        const update = () => {\n          setCssVar(cssVar, signal() || null);\n        };\n        update();\n        addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n      };\n\n      getCSSVarName ||= prop => `--tg-${camelToKebab(prop)}`;\n      bind(getCSSVarName('bgColor'), this.bgColorRgb);\n      bind(getCSSVarName('bottomBarColor'), this.bottomBarColorRgb);\n      bind(getCSSVarName('headerColor'), this.headerColorRgb);\n\n      isCssVarsBound.set(true);\n\n      return E.right(cleanup);\n    }, { isTma, returns: 'either', isMounted: this.isMounted });\n    this.bindCssVars = throwifyWithChecksFp(this.bindCssVarsFp);\n    //#endregion\n\n    //#region Colors.\n    type GenColorToolsetResult<K extends Exclude<keyof MiniAppState, 'isActive'>> = [\n      rawColor: Computed<AnyColor>,\n      rgbColor: Computed<RGB | undefined>,\n      throwing: WithChecks<\n        (color: AnyColor) => void,\n        true,\n        K extends 'headerColor' ? 'rgb' : never\n      >,\n      fp: WithChecksFp<\n        (color: AnyColor) => E.Either<UnknownThemeParamsKeyError | PostEventError, void>,\n        true,\n        K extends 'headerColor' ? 'rgb' : never\n      >,\n    ];\n    const genColorToolset = <K extends Exclude<keyof MiniAppState, 'isActive'>>(\n      stateKey: K,\n    ): GenColorToolsetResult<K> => {\n      const rawColor = stateful.getter(stateKey);\n      const rgbColor = computedRgbBasedOn(rawColor);\n      const method = ({\n        headerColor: 'web_app_set_header_color',\n        bgColor: 'web_app_set_background_color',\n        bottomBarColor: 'web_app_set_bottom_bar_color',\n      } as const)[stateKey];\n\n      const fp = withChecksFp(\n        (color: AnyColor): E.Either<UnknownThemeParamsKeyError | PostEventError, void> => {\n          if (color === rawColor()) {\n            return E.right(undefined);\n          }\n          if (\n            method === 'web_app_set_header_color'\n            && (color === 'bg_color' || color === 'secondary_bg_color')\n          ) {\n            return pipe(\n              postEvent('web_app_set_header_color', { color_key: color }),\n              E.map(() => {\n                stateful.setState({ [stateKey]: color });\n              }),\n            );\n          }\n          const rgb = rgbBasedOn(color);\n          return pipe(\n            rgb\n              ? postEvent(method, { color: rgb })\n              : E.left(new UnknownThemeParamsKeyError(color)),\n            E.map(() => {\n              stateful.setState({ [stateKey]: color });\n            }),\n          );\n        },\n        {\n          isTma,\n          version,\n          requires: method,\n          isMounted: this.isMounted,\n          returns: 'either',\n          supports: stateKey === 'headerColor'\n            ? {\n              rgb: {\n                method: 'web_app_set_header_color',\n                param: 'color',\n                shouldCheck: isRGB,\n              },\n            }\n            : undefined,\n        },\n      );\n\n      return [rawColor, rgbColor, throwifyWithChecksFp(fp), fp] as GenColorToolsetResult<K>;\n    };\n    [\n      this.bgColor,\n      this.bgColorRgb,\n      this.setBgColor,\n      this.setBgColorFp,\n    ] = genColorToolset('bgColor');\n    [\n      this.headerColor,\n      this.headerColorRgb,\n      this.setHeaderColor,\n      this.setHeaderColorFp,\n    ] = genColorToolset('headerColor');\n    [\n      this.bottomBarColor,\n      this.bottomBarColorRgb,\n      this.setBottomBarColor,\n      this.setBottomBarColorFp,\n    ] = genColorToolset('bottomBarColor');\n    //#endregion\n\n    //#region Other methods.\n    const withBasicEither = createWithChecksFp({ isTma, returns: 'either' });\n    this.closeFp = withBasicEither(returnBack => {\n      return postEvent('web_app_close', { return_back: returnBack });\n    });\n    this.close = throwifyWithChecksFp(this.closeFp);\n\n    this.readyFp = withBasicEither(() => postEvent('web_app_ready'));\n    this.ready = throwifyWithChecksFp(this.readyFp);\n    //#endregion\n  }\n\n  //#region Other properties.\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * True if the current Mini App background color is recognized as dark.\n   */\n  readonly isDark = computed(() => {\n    const color = this.bgColorRgb();\n    return color ? isColorDark(color) : false;\n  });\n\n  /**\n   * Signal indicating if the mini app is currently active.\n   */\n  readonly isActive: Computed<boolean>;\n\n  /**\n   * Complete component state.\n   */\n  readonly state: Computed<MiniAppState>;\n  //#endregion\n\n  //#region CSS variables.\n  /**\n   * True if the CSS variables are currently bound.\n   */\n  readonly isCssVarsBound: Computed<boolean>;\n\n  /**\n   * Creates CSS variables connected with the mini app.\n   *\n   * Default variables:\n   * - `--tg-bg-color`\n   * - `--tg-header-color`\n   * - `--tg-bottom-bar-color`\n   *\n   * Variables are being automatically updated if theme parameters were changed.\n   *\n   * @param getCSSVarName - function, returning complete CSS variable name for the specified\n   * mini app key.\n   * @returns Function to stop updating variables.\n   * @example Using no arguments\n   * miniApp.bindCssVars();\n   * @example Using custom CSS vars generator\n   * miniApp.bindCssVars(key => `--my-prefix-${key}`);\n   */\n  readonly bindCssVarsFp: WithChecksFp<\n    (getCssVarName?: MiniAppGetCssVarNameFn) => E.Either<CSSVarsBoundError, VoidFunction>,\n    false\n  >;\n\n  readonly bindCssVars: WithChecks<(getCssVarName?: MiniAppGetCssVarNameFn) => VoidFunction, false>;\n  //#endregion\n\n  //#region Mounting.\n  /**\n   * Signal indicating if the component is mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component.\n   *\n   * This function restores the component state and is automatically saving it in the local storage\n   * if it changed.\n   * @since Mini Apps v6.1\n   */\n  readonly mountFp: WithChecksFp<() => void, false>;\n\n  /**\n   * @see mount\n   */\n  readonly mount: WithChecks<() => void, false>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n  //#endregion\n\n  //#region Background color.\n  /**\n   * The Mini App background color.\n   *\n   * Represents an RGB color, or theme parameters key, like \"bg_color\", \"secondary_bg_color\", etc.\n   *\n   * Note that using a theme parameters key, background color becomes bound to the current\n   * theme parameters, making it automatically being updated whenever theme parameters change.\n   * In order to remove this bind, use an explicit RGB color.\n   */\n  readonly bgColor: Computed<AnyColor>;\n\n  /**\n   * RGB representation of the background color.\n   *\n   * This value requires the Theme Params component to be mounted to extract a valid RGB value\n   * of the color key.\n   */\n  readonly bgColorRgb: Computed<RGB | undefined>;\n\n  /**\n   * Updates the mini app background color.\n   * @since Mini Apps v6.1\n   */\n  readonly setBgColorFp: WithChecksFp<\n    (color: AnyColor) => E.Either<PostEventError | UnknownThemeParamsKeyError, void>,\n    true\n  >;\n\n  /**\n   * @see setBgColorFp\n   */\n  readonly setBgColor: WithChecks<(color: AnyColor) => void, true>;\n  //#endregion\n\n  //#region Header color.\n  /**\n   * The Mini App header color.\n   */\n  readonly headerColor: Computed<AnyColor>;\n\n  /**\n   * RGB representation of the header color.\n   *\n   * This value requires the Theme Params component to be mounted to extract a valid RGB value\n   * of the color key.\n   */\n  readonly headerColorRgb: Computed<RGB | undefined>;\n\n  /**\n   * Updates the mini app header color.\n   * @since Mini Apps v6.1\n   */\n  readonly setHeaderColorFp: WithChecksFp<\n    (color: AnyColor) => E.Either<PostEventError | UnknownThemeParamsKeyError, void>,\n    true,\n    'rgb'\n  >;\n\n  /**\n   * @see setHeaderColorFp\n   */\n  readonly setHeaderColor: WithChecks<(color: AnyColor) => void, true, 'rgb'>;\n  //#endregion\n\n  //#region Bottom bar background color.\n  /**\n   * The Mini App bottom bar background color.\n   */\n  readonly bottomBarColor: Computed<AnyColor>;\n\n  /**\n   * RGB representation of the bottom bar background color.\n   *\n   * This value requires the Theme Params component to be mounted to extract a valid RGB value\n   * of the color key.\n   */\n  readonly bottomBarColorRgb: Computed<RGB | undefined>;\n\n  /**\n   * Updates the mini app bottom bar bg color.\n   * @since Mini Apps v7.10\n   */\n  readonly setBottomBarColorFp: WithChecksFp<\n    (color: AnyColor) => E.Either<PostEventError | UnknownThemeParamsKeyError, void>,\n    true\n  >;\n\n  /**\n   * @see setBottomBarColorFp\n   */\n  readonly setBottomBarColor: WithChecks<(color: AnyColor) => void, true>;\n  //#endregion\n\n  //#region Other methods.\n  /**\n   * Closes the Mini App.\n   * @param returnBack - should the client return to the previous activity.\n   */\n  readonly closeFp: WithChecksFp<(returnBack?: boolean) => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see closeFp\n   */\n  readonly close: WithChecks<(returnBack?: boolean) => void, false>;\n\n  /**\n   * Informs the Telegram app that the Mini App is ready to be displayed.\n   *\n   * It is recommended to call this method as early as possible, as soon as all\n   * essential interface elements loaded.\n   *\n   * Once this method is called, the loading placeholder is hidden and the Mini\n   * App shown.\n   *\n   * If the method is not called, the placeholder will be hidden only when the\n   * page was fully loaded.\n   */\n  readonly readyFp: WithChecksFp<() => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see readyFp\n   */\n  readonly ready: WithChecks<() => void, false>;\n  //#endregion\n}\n","import { on, off } from '@tma.js/bridge';\nimport { pipe } from 'fp-ts/function';\n\nimport { MiniApp, type MiniAppState } from '@/features/MiniApp/MiniApp.js';\nimport { themeParams } from '@/features/ThemeParams/instance.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport const miniApp = new MiniApp({\n  ...pipe(\n    sharedFeatureOptions(),\n    withPostEvent,\n    withVersion,\n    withStateRestore<MiniAppState>('miniApp'),\n  ),\n  offVisibilityChanged(listener) {\n    off('visibility_changed', listener);\n  },\n  onVisibilityChanged(listener) {\n    on('visibility_changed', listener);\n  },\n  theme: themeParams.state,\n});\n","import type { PopupParams, PopupButton } from '@tma.js/bridge';\nimport * as E from 'fp-ts/Either';\n\nimport { InvalidArgumentsError } from '@/errors.js';\nimport type { ShowOptions } from '@/features/Popup/types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n */\nexport function prepareParams(params: ShowOptions): E.Either<InvalidArgumentsError, PopupParams> {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const paramsButtons = params.buttons || [];\n\n  if (title.length > 64) {\n    return E.left(new InvalidArgumentsError(`Invalid title: ${title}`));\n  }\n  if (!message || message.length > 256) {\n    return E.left(new InvalidArgumentsError(`Invalid message: ${message}`));\n  }\n  if (paramsButtons.length > 3) {\n    return E.left(new InvalidArgumentsError(`Invalid buttons count: ${paramsButtons.length}`));\n  }\n\n  const buttons: PopupButton[] = [];\n  if (!paramsButtons.length) {\n    buttons.push({ type: 'close', id: '' });\n  } else {\n    for (let i = 0; i < paramsButtons.length; i++) {\n      const button = paramsButtons[i];\n      const id = button.id || '';\n      if (id.length > 64) {\n        return E.left(new InvalidArgumentsError(`Button with index ${i} has invalid id: ${id}`));\n      }\n\n      if (!button.type || button.type === 'default' || button.type === 'destructive') {\n        const text = button.text.trim();\n        if (!text || text.length > 64) {\n          return E.left(new InvalidArgumentsError(`Button with index ${i} has invalid text: ${text}`));\n        }\n        buttons.push({ type: button.type, text, id });\n      } else {\n        buttons.push({ type: button.type, id });\n      }\n    }\n  }\n\n  return E.right({ title, message, buttons });\n}\n","import type { RequestError } from '@tma.js/bridge';\nimport { type Computed, signal, computed } from '@tma.js/signals';\nimport type { BetterPromise } from 'better-promises';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { ConcurrentCallError, type InvalidArgumentsError } from '@/errors.js';\nimport { prepareParams } from '@/features/Popup/prepareParams.js';\nimport type { ShowOptions } from '@/features/Popup/types.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithRequest } from '@/fn-options/withRequest.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecksFp, type WithChecks } from '@/with-checks/withChecksFp.js';\n\nexport interface PopupOptions extends SharedFeatureOptions, WithVersion, WithRequest {\n}\n\n/**\n * @since Mini Apps v6.2\n */\nexport class Popup {\n  constructor({ version, isTma, request }: PopupOptions) {\n    const isOpened = signal(false);\n    const toggleClosed = () => {\n      isOpened.set(false);\n    };\n\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      isTma,\n      requires: 'web_app_open_popup',\n      returns: 'task',\n    });\n\n    this.isSupported = createIsSupportedSignal('web_app_open_popup', version);\n    this.isOpened = computed(isOpened);\n    this.showFp = wrapSupportedTask(options => {\n      return pipe(\n        this.isOpened()\n          ? TE.left(new ConcurrentCallError('A popup is already opened'))\n          : TE.right(undefined as never),\n        TE.chainW(() => TE.fromEither(prepareParams(options))),\n        TE.chain(preparedOptions => {\n          isOpened.set(true);\n          return request('web_app_open_popup', 'popup_closed', {\n            ...options,\n            params: preparedOptions,\n          });\n        }),\n        TE.mapBoth(\n          err => {\n            toggleClosed();\n            return err;\n          },\n          response => {\n            toggleClosed();\n            return response.button_id;\n          },\n        ),\n      );\n    });\n    this.show = throwifyWithChecksFp(this.showFp);\n  }\n\n  /**\n   * Signal indicating if any popup is currently opened.\n   */\n  readonly isOpened: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * A method that shows a native popup described by the `params` argument.\n   * The promise will be resolved when the popup is closed. Resolved value will have\n   * an identifier of the pressed button.\n   *\n   * If a user clicked outside the popup or clicked the top right popup close\n   * button, null will be resolved.\n   *\n   * @param options - popup parameters.\n   * @since Mini Apps v6.2\n   * @example\n   * pipe(\n   *   popup.showFp({\n   *     title: 'Confirm action',\n   *     message: 'Do you really want to buy this burger?',\n   *     buttons: [\n   *       { id: 'yes', text: 'Yes' },\n   *       { id: 'no', type: 'destructive', text: 'No' },\n   *     ],\n   *   }),\n   *   TE.map(buttonId => {\n   *     console.log('User clicked a button with ID', buttonId);\n   *   }),\n   * );\n   */\n  readonly showFp: WithChecksFp<\n    (options: ShowOptions) => TE.TaskEither<\n      RequestError | InvalidArgumentsError | ConcurrentCallError,\n      string | undefined\n    >,\n    true\n  >;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<(options: ShowOptions) => BetterPromise<string | undefined>, true>;\n}\n","import { pipe } from 'fp-ts/function';\n\nimport { Popup } from '@/features/Popup/Popup.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport const popup = new Popup(pipe(sharedFeatureOptions(), withRequest, withVersion));\n","import type { PhoneRequestedStatus, RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nexport type RequestPhoneAccessError = RequestError;\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    options?: AsyncOptions,\n  ): TE.TaskEither<RequestPhoneAccessError, PhoneRequestedStatus> => {\n    return pipe(\n      request('web_app_request_phone', 'phone_requested', options),\n      TE.map(response => response.status),\n    );\n  }, { ...rest, requires: 'web_app_request_phone', returns: 'task' });\n}\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n */\nexport const requestPhoneAccessFp = create(pipe(\n  sharedFeatureOptions(),\n  withVersion,\n  withRequest,\n));\n\n/**\n * @see requestPhoneAccessFp\n */\nexport const requestPhoneAccess = throwifyWithChecksFp(requestPhoneAccessFp);\n","import { PhoneRequestedStatus } from '@tma.js/bridge';\nimport { BetterTaskEither, type BetterTaskEitherError } from '@tma.js/toolkit';\nimport { pipeJsonToSchema, pipeQueryToSchema } from '@tma.js/transformers';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\nimport {\n  safeParse,\n  pipe as valiPipe,\n  date,\n  looseObject,\n  number,\n  optional,\n  string,\n  transform,\n} from 'valibot';\n\nimport { AccessDeniedError, ValidationError } from '@/errors.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\n\nimport {\n  withInvokeCustomMethod,\n  type WithInvokeCustomMethod,\n  InvokeCustomMethodError,\n} from '@/fn-options/withInvokeCustomMethod.js';\n\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\n\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\nimport { type RequestPhoneAccessError, requestPhoneAccessFp } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n    [key: string]: unknown;\n  };\n  auth_date: Date;\n  hash: string;\n  [key: string]: unknown;\n}\n\n/**\n * Requested contact complete data.\n */\nexport interface RequestedContactCompleteData {\n  /**\n   * Raw original representation of the contact data returned from the Telegram server.\n   */\n  raw: string;\n  /**\n   * Parsed representation of the contact data.\n   */\n  parsed: RequestedContact;\n}\n\ninterface CreateCompleteOptions extends SharedFeatureOptions, WithInvokeCustomMethod, WithVersion {\n  requestPhoneAccess: (options?: AsyncOptions) => (\n    TE.TaskEither<RequestPhoneAccessError, PhoneRequestedStatus>\n  );\n}\n\ninterface CreateParsedOptions extends SharedFeatureOptions, WithVersion {\n  requestContact: (options?: AsyncOptions) => TE.TaskEither<RequestContactError, RequestedContact>;\n}\n\nexport type RequestContactError =\n  | InvokeCustomMethodError\n  | AccessDeniedError\n  | ValidationError\n  | BetterTaskEitherError;\n\nfunction createComplete({\n  invokeCustomMethod,\n  requestPhoneAccess,\n  ...rest\n}: CreateCompleteOptions) {\n  type GetRequestedContactError = InvokeCustomMethodError | ValidationError;\n\n  // Attempts to get previously requested contact.\n  const getContact = (\n    options?: AsyncOptions,\n  ): TE.TaskEither<GetRequestedContactError, RequestedContactCompleteData | undefined> => {\n    return pipe(\n      invokeCustomMethod('getRequestedContact', {}, {\n        ...options,\n        timeout: (options || {}).timeout || 5000,\n      }),\n      TE.chainW(response => {\n        const toStringResult = safeParse(string(), response);\n        if (!toStringResult.success) {\n          return TE.left(new ValidationError(response, toStringResult.issues));\n        }\n\n        if (!toStringResult.output) {\n          return TE.right(undefined);\n        }\n\n        const toParsedResult = safeParse(\n          pipeQueryToSchema(\n            looseObject({\n              contact: pipeJsonToSchema(looseObject({\n                user_id: number(),\n                phone_number: string(),\n                first_name: string(),\n                last_name: optional(string()),\n              })),\n              auth_date: valiPipe(\n                string(),\n                transform(input => new Date(Number(input) * 1000)),\n                date(),\n              ),\n              hash: string(),\n            }),\n          ),\n          toStringResult.output,\n        );\n        return toParsedResult.success\n          ? TE.right({ raw: toStringResult.output, parsed: toParsedResult.output })\n          : TE.left(new ValidationError(toStringResult.output, toParsedResult.issues));\n      }),\n    );\n  };\n\n  // Attempts to get previously requested contact, but ignores all errors except validation error.\n  const getContactWithErrorsIgnore = (\n    options?: AsyncOptions,\n  ): TE.TaskEither<ValidationError, RequestedContactCompleteData | undefined> => {\n    return pipe(\n      getContact(options),\n      TE.match(\n        // All other errors except validation ones should be ignored. Receiving validation error\n        // means that we have some data, but we are unable to parse it properly. So, there is no\n        // need to make some more requests further, the problem is local.\n        error => (ValidationError.is(error) ? E.left(error) : E.right(undefined)),\n        contact => E.right(contact),\n      ),\n    );\n  };\n\n  // Polls previously requested contact with increasing timeout between requests.\n  const pollContact = (ctx: {\n    isRejected: boolean;\n    rejectReason: unknown;\n    abortSignal: AbortSignal;\n  }): TE.TaskEither<BetterTaskEitherError | ValidationError, RequestedContactCompleteData> => {\n    return BetterTaskEither<ValidationError, RequestedContactCompleteData>(\n      async (res, rej, context) => {\n        // Time to wait before executing the next request.\n        let sleepTime = 50;\n\n        // We are trying to retrieve the requested contact until the deadline was reached.\n        while (!context.isRejected) {\n          const result = await getContactWithErrorsIgnore(context)();\n          if (result._tag === 'Left') {\n            return rej(result.left);\n          }\n          if (result.right) {\n            return res(result.right);\n          }\n          await new Promise(resolve => setTimeout(resolve, sleepTime));\n          sleepTime += 50;\n        }\n      },\n      ctx,\n    );\n  };\n\n  return withChecksFp((\n    options?: AsyncOptions,\n  ): TE.TaskEither<RequestContactError, RequestedContactCompleteData> => {\n    return BetterTaskEither.fn(context => {\n      return pipe(\n        // Try to get the requested contact. Probably, we already requested it before.\n        getContactWithErrorsIgnore(context),\n        TE.chain(contact => {\n          if (contact) {\n            return TE.right(contact);\n          }\n          return pipe(\n            requestPhoneAccess(context),\n            TE.chainW(status => {\n              return status === 'sent'\n                ? pollContact(context)\n                : TE.left(new AccessDeniedError('User denied access'));\n            }),\n          );\n        }),\n      );\n    }, options);\n  }, { ...rest, returns: 'task', requires: 'web_app_request_phone' });\n}\n\nfunction createParsed({ requestContact, ...rest }: CreateParsedOptions) {\n  return withChecksFp(\n    requestContact,\n    { ...rest, returns: 'task', requires: 'web_app_request_phone' },\n  );\n}\n\n/**\n * Requests current user contact information.\n *\n * This function returns an object, containing both raw and parsed representations of a response,\n * received from the Telegram client.\n * @param options - additional options.\n * @since Mini Apps v6.9\n */\nexport const requestContactCompleteFp = createComplete({\n  ...pipe(sharedFeatureOptions(), withInvokeCustomMethod, withVersion),\n  requestPhoneAccess: requestPhoneAccessFp,\n});\n\n/**\n * @see requestContactCompleteFp\n */\nexport const requestContactComplete = throwifyWithChecksFp(requestContactCompleteFp);\n\n/**\n * Works the same way as the `requestContactCompleteFp` function, but returns only parsed\n * representation of the contact data.\n * @see requestContactCompleteFp\n * @param options - additional options.\n * @since Mini Apps v6.9\n */\nexport const requestContactFp = createParsed({\n  ...pipe(sharedFeatureOptions(), withVersion),\n  requestContact(options) {\n    return pipe(\n      requestContactCompleteFp(options),\n      TE.map(contact => contact.parsed),\n    );\n  },\n});\n\n/**\n * @see requestContactFp\n */\nexport const requestContact = throwifyWithChecksFp(requestContactFp);\n","import type { WriteAccessRequestedStatus, RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nexport type RequestWriteAccessError = RequestError;\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    options?: AsyncOptions,\n  ): TE.TaskEither<RequestWriteAccessError, WriteAccessRequestedStatus> => {\n    return pipe(\n      request('web_app_request_write_access', 'write_access_requested', options),\n      TE.map(response => response.status),\n    );\n  }, { ...rest, requires: 'web_app_request_write_access', returns: 'task' });\n}\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n */\nexport const requestWriteAccessFp = create(pipe(\n  sharedFeatureOptions(),\n  withVersion,\n  withRequest,\n));\n\n/**\n * @see requestWriteAccessFp\n */\nexport const requestWriteAccess = throwifyWithChecksFp(requestWriteAccessFp);\n","import type { PostEventError } from '@tma.js/bridge';\nimport { computed, type Computed, signal } from '@tma.js/signals';\nimport { createCbCollector, BetterTaskEither, type BetterTaskEitherError } from '@tma.js/toolkit';\nimport { BetterPromise } from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { ConcurrentCallError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport interface QrScannerOptions extends WithVersion, WithPostEvent, SharedFeatureOptions {\n  /**\n   * A function to add a listener to the event determining if the QR scanner\n   * was closed.\n   * @param listener - a listener to add.\n   * @returns A function to remove the listener.\n   */\n  onClosed: (listener: VoidFunction) => VoidFunction;\n  /**\n   * A function to add a listener to the event containing a scanned QR content.\n   * @param listener - a listener to add.\n   * @returns A function to remove the listener.\n   */\n  onTextReceived: (listener: (data: string) => void) => VoidFunction;\n}\n\ninterface SharedOptions extends AsyncOptions {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\ninterface CaptureOptions extends SharedOptions {\n  /**\n   * @returns True if the passed QR code should be captured.\n   * @param qr - scanned QR content.\n   */\n  capture: (qr: string) => boolean;\n}\n\ninterface OpenOptions extends SharedOptions {\n  /**\n   * Function which will be called if a QR code was scanned.\n   * @param qr - scanned QR content.\n   */\n  onCaptured: (qr: string) => void;\n}\n\n/**\n * @since Mini Apps v6.4\n */\nexport class QrScanner {\n  constructor({\n    version,\n    onClosed,\n    onTextReceived,\n    isTma,\n    postEvent,\n  }: QrScannerOptions) {\n    const wrapOptions = { version, requires: 'web_app_open_scan_qr_popup', isTma } as const;\n    const wrapSupportedEither = createWithChecksFp({ ...wrapOptions, returns: 'either' });\n    const wrapSupportedTask = createWithChecksFp({ ...wrapOptions, returns: 'task' });\n\n    const isOpened = signal(false);\n    const setClosed = () => {\n      isOpened.set(false);\n    };\n\n    this.isSupported = createIsSupportedSignal('web_app_open_scan_qr_popup', version);\n    this.isOpened = computed(isOpened);\n\n    this.captureFp = wrapSupportedTask(options => {\n      let captured: string | undefined;\n      return pipe(\n        this.openFp({\n          ...options,\n          onCaptured: qr => {\n            if (options.capture(qr)) {\n              captured = qr;\n              this.close();\n            }\n          },\n        }),\n        TE.map(() => captured),\n      );\n    });\n    this.closeFp = wrapSupportedEither(() => {\n      return pipe(postEvent('web_app_close_scan_qr_popup'), E.map(setClosed));\n    });\n    this.openFp = wrapSupportedTask(options => {\n      return pipe(\n        isOpened()\n          ? TE.left(new ConcurrentCallError('The QR Scanner is already opened'))\n          : async () => postEvent('web_app_open_scan_qr_popup', { text: options.text }),\n        TE.chainW(() => {\n          isOpened.set(true);\n          const [addToCleanup, cleanup] = createCbCollector();\n          const onSettled = <T>(value: T): T => {\n            cleanup();\n            isOpened.set(false);\n            return value;\n          };\n\n          return pipe(\n            BetterTaskEither<never, void>(resolve => {\n              addToCleanup(\n                // The scanner was closed externally.\n                onClosed(resolve),\n                // The scanner was closed internally.\n                isOpened.sub(isOpenedValue => {\n                  if (!isOpenedValue) {\n                    resolve();\n                  }\n                }),\n                onTextReceived(options.onCaptured),\n              );\n            }, options),\n            TE.mapBoth(onSettled, onSettled),\n          );\n        }),\n      );\n    });\n\n    this.open = throwifyWithChecksFp(this.openFp);\n    this.capture = throwifyWithChecksFp(this.captureFp);\n    this.close = throwifyWithChecksFp(this.closeFp);\n  }\n\n  /**\n   * Signal indicating if the scanner is currently opened.\n   */\n  readonly isOpened: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Opens the scanner and returns a task which will be completed with the QR content if the\n   * passed `capture` function returned true.\n   *\n   * Task may also be completed with undefined if the scanner was closed.\n   * @param options - method options.\n   * @returns A promise with QR content presented as string or undefined if the scanner was closed.\n   * @since Mini Apps v6.4\n   * @example\n   * pipe(\n   *   qrScanner.captureFp({\n   *     capture(scannedQr) {\n   *       return scannedQr === 'any expected by me qr';\n   *     }\n   *   }),\n   *   TE.match(\n   *     error => {\n   *       console.error(error);\n   *     },\n   *     qr => {\n   *       console.log('My QR:'), qr;\n   *     }\n   *   ),\n   * );\n   */\n  readonly captureFp: WithChecksFp<\n    (options: CaptureOptions) => (\n      TE.TaskEither<PostEventError | BetterTaskEitherError, string | undefined>\n    ),\n    true\n  >;\n\n  /**\n   * @see captureFp\n   */\n  readonly capture: WithChecks<\n    (options: CaptureOptions) => BetterPromise<string | undefined>,\n    true\n  >;\n\n  /**\n   * Closes the scanner.\n   * @since Mini Apps v6.4\n   */\n  readonly closeFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see close\n   */\n  readonly close: WithChecks<() => void, true>;\n\n  /**\n   * Opens the scanner and returns a task which will be completed when the scanner was closed.\n   * @param options - method options.\n   * @since Mini Apps v6.4\n   * @example Without `capture` option\n   * if (qrScanner.open.isAvailable()) {\n   *   const qr = await qrScanner.open({ text: 'Scan any QR' });\n   * }\n   * @example\n   * pipe(\n   *   qrScanner.openFp({\n   *     onCaptured(scannedQr) {\n   *       if (scannedQr === 'any expected by me qr') {\n   *         qrScanner.close();\n   *       }\n   *     }\n   *   }),\n   *   TE.match(\n   *     error => {\n   *       console.error(error);\n   *     },\n   *     () => {\n   *       console.log('The scanner was closed');\n   *     }\n   *   ),\n   * );\n   */\n  readonly openFp: WithChecksFp<\n    (options: OpenOptions) => TE.TaskEither<PostEventError, void>,\n    true\n  >;\n\n  /**\n   * @see openFp\n   */\n  readonly open: WithChecks<(options: OpenOptions) => BetterPromise<void>, true>;\n}\n","import { on } from '@tma.js/bridge';\n\nimport { pipe } from 'fp-ts/function';\n\nimport { QrScanner } from '@/features/QrScanner/QrScanner.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport const qrScanner = new QrScanner({\n  ...pipe(sharedFeatureOptions(), withPostEvent, withVersion),\n  onClosed(listener) {\n    return on('scan_qr_popup_closed', listener);\n  },\n  onTextReceived(listener) {\n    return on('qr_text_received', event => {\n      listener(event.data);\n    });\n  },\n});\n","import type { PostEventError, SecondaryButtonPosition } from '@tma.js/bridge';\nimport { computed, type Computed } from '@tma.js/signals';\nimport type { RGB } from '@tma.js/types';\nimport * as E from 'fp-ts/Either';\n\nimport { Button, type ButtonOptions } from '@/composables/Button.js';\nimport { access } from '@/helpers/access.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { MaybeAccessor } from '@/types.js';\nimport type { WithChecks, WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype SecondaryButtonEither = E.Either<PostEventError, void>;\n\nexport interface SecondaryButtonState {\n  isVisible: boolean;\n  bgColor?: RGB;\n  hasShineEffect: boolean;\n  isEnabled: boolean;\n  isLoaderVisible: boolean;\n  text: string;\n  textColor?: RGB;\n  position: SecondaryButtonPosition;\n}\n\nexport interface SecondaryButtonOptions extends Omit<\n  ButtonOptions<SecondaryButtonState, 'web_app_setup_secondary_button'>,\n  'initialState' | 'method' | 'payload'\n> {\n  /**\n   * Default values for different kinds of the button properties.\n   */\n  defaults: {\n    bgColor: MaybeAccessor<RGB>;\n    textColor: MaybeAccessor<RGB>;\n  };\n}\n\n/**\n * @since Mini Apps v7.10\n */\nexport class SecondaryButton {\n  constructor({ defaults, ...options }: SecondaryButtonOptions) {\n    const button = new Button({\n      ...options,\n      initialState: {\n        hasShineEffect: false,\n        isEnabled: true,\n        isLoaderVisible: false,\n        isVisible: false,\n        text: 'Cancel',\n        position: 'left',\n      },\n      method: 'web_app_setup_secondary_button',\n      payload: state => ({\n        has_shine_effect: state.hasShineEffect,\n        is_visible: state.isVisible,\n        is_active: state.isEnabled,\n        is_progress_visible: state.isLoaderVisible,\n        text: state.text,\n        color: state.bgColor,\n        text_color: state.textColor,\n        position: state.position,\n      }),\n    });\n\n    const withDefault = (\n      field: 'bgColor' | 'textColor',\n      getDefault: MaybeAccessor<RGB>,\n    ) => {\n      const fromState = button.stateGetter(field);\n      return computed(() => fromState() || access(getDefault));\n    };\n\n    this.isSupported = createIsSupportedSignal('web_app_setup_secondary_button', options.version);\n    this.bgColor = withDefault('bgColor', defaults.bgColor);\n    this.textColor = withDefault('textColor', defaults.textColor);\n    this.position = button.stateGetter('position');\n    this.hasShineEffect = button.stateGetter('hasShineEffect');\n    this.isEnabled = button.stateGetter('isEnabled');\n    this.isLoaderVisible = button.stateGetter('isLoaderVisible');\n    this.text = button.stateGetter('text');\n    this.isVisible = button.stateGetter('isVisible');\n    this.isMounted = button.isMounted;\n    this.state = button.state;\n\n    [this.setPosition, this.setPositionFp] = button.stateSetters('position');\n    [this.setBgColor, this.setBgColorFp] = button.stateSetters('bgColor');\n    [this.setTextColor, this.setTextColorFp] = button.stateSetters('textColor');\n    [\n      [this.disableShineEffect, this.disableShineEffectFp],\n      [this.enableShineEffect, this.enableShineEffectFp],\n    ] = button.stateBoolSetters('hasShineEffect');\n    [\n      [this.disable, this.disableFp],\n      [this.enable, this.enableFp],\n    ] = button.stateBoolSetters('isEnabled');\n    [\n      [this.hideLoader, this.hideLoaderFp],\n      [this.showLoader, this.showLoaderFp],\n    ] = button.stateBoolSetters('isLoaderVisible');\n\n    [this.setText, this.setTextFp] = button.stateSetters('text');\n    [[this.hide, this.hideFp], [this.show, this.showFp]] = button.stateBoolSetters('isVisible');\n    this.setParams = button.setState;\n    this.setParamsFp = button.setStateFp;\n    this.onClick = button.onClick;\n    this.onClickFp = button.onClickFp;\n    this.offClick = button.offClick;\n    this.offClickFp = button.offClickFp;\n    this.mount = button.mount;\n    this.mountFp = button.mountFp;\n    this.unmount = button.unmount;\n  }\n\n  //#region Properties.\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * The button position relative to the main one.\n   */\n  readonly position: Computed<SecondaryButtonPosition>;\n\n  /**\n   * The button background color.\n   */\n  readonly bgColor: Computed<RGB>;\n\n  /**\n   * True if the button has a shining effect.\n   */\n  readonly hasShineEffect: Computed<boolean>;\n\n  /**\n   * True if the button is clickable.\n   */\n  readonly isEnabled: Computed<boolean>;\n\n  /**\n   * True if the button loader is visible.\n   */\n  readonly isLoaderVisible: Computed<boolean>;\n\n  /**\n   * True if the button is visible.\n   */\n  readonly isVisible: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * The complete button state.\n   */\n  readonly state: Computed<SecondaryButtonState>;\n\n  /**\n   * The button displayed text.\n   */\n  readonly text: Computed<string>;\n\n  /**\n   * The button text color.\n   *\n   * Note that this value is computed based on the external defaults. For\n   * example, if not explicitly set, this value may be equal to one of theme\n   * params colors.\n   */\n  readonly textColor: Computed<RGB>;\n  //#endregion\n\n  //#region Methods.\n  /**\n   * Shows the button.\n   * @since Mini Apps v7.10\n   */\n  readonly showFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<() => void, true>;\n\n  /**\n   * Hides the button.\n   * @since Mini Apps v7.10\n   */\n  readonly hideFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see hideFp\n   */\n  readonly hide: WithChecks<() => void, true>;\n\n  /**\n   * Enables the button.\n   * @since Mini Apps v7.10\n   */\n  readonly enableFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see enableFp\n   */\n  readonly enable: WithChecks<() => void, true>;\n\n  /**\n   * Enables the button.\n   * @since Mini Apps v7.10\n   */\n  readonly enableShineEffectFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see enableShineEffectFp\n   */\n  readonly enableShineEffect: WithChecks<() => void, true>;\n\n  /**\n   * Disables the button.\n   * @since Mini Apps v7.10\n   */\n  readonly disableFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see disableFp\n   */\n  readonly disable: WithChecks<() => void, true>;\n\n  /**\n   * Enables the button.\n   * @since Mini Apps v7.10\n   */\n  readonly disableShineEffectFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see disableShineEffectFp\n   */\n  readonly disableShineEffect: WithChecks<() => void, true>;\n\n  /**\n   * Updates the button background color.\n   * @since Mini Apps v7.10\n   */\n  readonly setBgColorFp: WithChecksFp<(value: RGB) => SecondaryButtonEither, true>;\n\n  /**\n   * @see setBgColorFp\n   */\n  readonly setBgColor: WithChecks<(value: RGB) => void, true>;\n\n  /**\n   * Updates the button text color.\n   * @since Mini Apps v7.10\n   */\n  readonly setTextColorFp: WithChecksFp<(value: RGB) => SecondaryButtonEither, true>;\n\n  /**\n   * @see setTextColorFp\n   */\n  readonly setTextColor: WithChecks<(value: RGB) => void, true>;\n\n  /**\n   * Updates the button text.\n   * @since Mini Apps v7.10\n   */\n  readonly setTextFp: WithChecksFp<(value: string) => SecondaryButtonEither, true>;\n\n  /**\n   * @see setTextFp\n   */\n  readonly setText: WithChecks<(value: string) => void, true>;\n\n  /**\n   * Updates the button position.\n   * @since Mini Apps v7.10\n   */\n  readonly setPositionFp: WithChecksFp<\n    (position: SecondaryButtonPosition) => SecondaryButtonEither,\n    true\n  >;\n\n  /**\n   * @see setPositionFp\n   */\n  readonly setPosition: WithChecks<(position: SecondaryButtonPosition) => void, true>;\n\n  /**\n   * Shows the button loader.\n   * @since Mini Apps v7.10\n   */\n  readonly showLoaderFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see showLoaderFp\n   */\n  readonly showLoader: WithChecks<() => void, true>;\n\n  /**\n   * Hides the button loader.\n   * @since Mini Apps v7.10\n   */\n  readonly hideLoaderFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see hideLoaderFp\n   */\n  readonly hideLoader: WithChecks<() => void, true>;\n\n  /**\n   * Updates the button state.\n   * @param state - updates to apply.\n   * @since Mini Apps v7.10\n   * @example\n   * button.setParams({\n   *   text: 'Submit',\n   *   isEnabled: true,\n   *   hasShineEffect: true,\n   * });\n   */\n  readonly setParamsFp: WithChecksFp<\n    (state: Partial<SecondaryButtonState>) => SecondaryButtonEither,\n    true\n  >;\n\n  /**\n   * @see setParamsFp\n   */\n  readonly setParams: WithChecks<(state: Partial<SecondaryButtonState>) => void, true>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v7.10\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @since Mini Apps v7.10\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * @see onClick\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @since Mini Apps v7.10\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => void, true>;\n\n  /**\n   * @see offClick\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, true>;\n  //#endregion\n}\n","import { computed } from '@tma.js/signals';\n\nimport { miniApp } from '@/features/MiniApp/instance.js';\nimport { SecondaryButton } from '@/features/SecondaryButton/SecondaryButton.js';\nimport { themeParams } from '@/features/ThemeParams/instance.js';\nimport { bottomButtonOptions } from '@/fn-options/bottomButtonOptions.js';\n\nexport const secondaryButton = new SecondaryButton(\n  bottomButtonOptions('secondaryButton', 'secondary_button_pressed', {\n    bgColor: computed(() => miniApp.bottomBarColorRgb() || '#000000'),\n    textColor: computed(() => themeParams.buttonColor() || '#2481cc'),\n  }),\n);\n","import { EventPayload, type MethodParams, type Request2CaptureFn, RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { SecureStorageMethodError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithCreateRequestId } from '@/fn-options/withCreateRequestId.js';\nimport type { WithRequest } from '@/fn-options/withRequest.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport type SecureStorageError = RequestError | SecureStorageMethodError;\n\nexport interface SecureStorageOptions extends SharedFeatureOptions,\n  WithVersion,\n  WithRequest,\n  WithCreateRequestId {\n}\n\n/**\n * @since Mini Apps v9.0\n */\nexport class SecureStorage {\n  constructor({ isTma, request, version, createRequestId }: SecureStorageOptions) {\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      requires: 'web_app_secure_storage_get_key',\n      isTma,\n      returns: 'task',\n    });\n\n    const invokeMethod = <\n      M extends (\n        | 'web_app_secure_storage_save_key'\n        | 'web_app_secure_storage_get_key'\n        | 'web_app_secure_storage_restore_key'\n        | 'web_app_secure_storage_save_key'\n        | 'web_app_secure_storage_clear'\n      ),\n      E extends (\n        | 'secure_storage_key_saved'\n        | 'secure_storage_key_received'\n        | 'secure_storage_key_restored'\n        | 'secure_storage_cleared'\n      ),\n    >(\n      method: M,\n      event: E,\n      params: Omit<MethodParams<M>, 'req_id'>,\n    ): TE.TaskEither<SecureStorageError, EventPayload<E>> => {\n      const requestId = createRequestId();\n      return pipe(\n        request<M, ('secure_storage_failed' | E)[]>(method, ['secure_storage_failed', event], {\n          params: { ...params, req_id: requestId },\n          capture: (event => {\n            return 'payload' in event ? event.payload.req_id === requestId : true;\n          }) as Request2CaptureFn<('secure_storage_failed' | E)[]>,\n        }),\n        TE.chain(response => (\n          response.event === 'secure_storage_failed'\n            ? TE.left(new SecureStorageMethodError(response.payload.error || 'UNKNOWN_ERROR'))\n            : TE.right(response.payload as EventPayload<E>)\n        )),\n      );\n    };\n\n    this.getItemFp = wrapSupportedTask(key => {\n      return pipe(\n        invokeMethod('web_app_secure_storage_get_key', 'secure_storage_key_received', { key }),\n        TE.map(payload => ({\n          value: payload.value,\n          canRestore: !!payload.can_restore,\n        })),\n      );\n    });\n    this.setItemFp = wrapSupportedTask((key, value) => {\n      return pipe(\n        invokeMethod('web_app_secure_storage_save_key', 'secure_storage_key_saved', { key, value }),\n        TE.map(() => undefined),\n      );\n    });\n    this.deleteItemFp = wrapSupportedTask(key => {\n      return this.setItemFp(key, null);\n    });\n    this.clearFp = wrapSupportedTask(() => {\n      return pipe(\n        invokeMethod('web_app_secure_storage_clear', 'secure_storage_cleared', {}),\n        TE.map(() => undefined),\n      );\n    });\n    this.restoreItemFp = wrapSupportedTask(key => {\n      return pipe(\n        invokeMethod('web_app_secure_storage_restore_key', 'secure_storage_key_restored', { key }),\n        TE.map(payload => payload.value),\n      );\n    });\n\n    this.getItem = throwifyWithChecksFp(this.getItemFp);\n    this.setItem = throwifyWithChecksFp(this.setItemFp);\n    this.deleteItem = throwifyWithChecksFp(this.deleteItemFp);\n    this.clear = throwifyWithChecksFp(this.clearFp);\n    this.restoreItem = throwifyWithChecksFp(this.restoreItemFp);\n  }\n\n  /**\n    * Retrieves an item using its key.\n    * @since Mini Apps v9.0\n    */\n  readonly getItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<SecureStorageError, {\n      value: string | null;\n      canRestore: boolean;\n    }>,\n    true\n  >;\n\n  /**\n   * @see getItemFp\n   */\n  readonly getItem: WithChecks<\n    (key: string) => Promise<{ value: string | null; canRestore: boolean }>,\n    true\n  >;\n\n  /**\n   * Restores an item from the storage.\n   * @since Mini Apps v9.0\n   */\n  readonly restoreItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<SecureStorageError, string | null>,\n    true\n  >;\n\n  /**\n   * @see restoreItemFp\n   */\n  readonly restoreItem: WithChecks<(key: string) => Promise<string | null>, true>;\n\n  /**\n    * Sets a new item in the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly setItemFp: WithChecksFp<\n    (key: string, value: string | null) => TE.TaskEither<SecureStorageError, void>,\n    true\n  >;\n\n  /**\n   * @see setItemFp\n   */\n  readonly setItem: WithChecks<(key: string, value: string | null) => Promise<void>, true>;\n\n  /**\n    * Removes a key from the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly deleteItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<SecureStorageError, void>,\n    true\n  >;\n\n  /**\n   * @see deleteItemFp\n   */\n  readonly deleteItem: WithChecks<(key: string) => Promise<void>, true>;\n\n  /**\n    * Removes all keys from the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly clearFp: WithChecksFp<() => TE.TaskEither<SecureStorageError, void>, true>;\n\n  /**\n   * @see clearFp\n   */\n  readonly clear: WithChecks<() => Promise<void>, true>;\n}\n","import { pipe } from 'fp-ts/function';\n\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withCreateRequestId } from '@/fn-options/withCreateRequestId.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nimport { SecureStorage } from './SecureStorage.js';\n\nexport const secureStorage = new SecureStorage(pipe(\n  sharedFeatureOptions(),\n  withVersion,\n  withRequest,\n  withCreateRequestId,\n));\n","import type { PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport * as E from 'fp-ts/Either';\n\nimport { Button, type ButtonOptions } from '@/composables/Button.js';\nimport type { WithChecksFp, WithChecks } from '@/with-checks/withChecksFp.js';\n\nexport interface SettingsButtonState {\n  isVisible: boolean;\n}\n\nexport type SettingsButtonOptions = Omit<\n  ButtonOptions<SettingsButtonState, 'web_app_setup_settings_button'>,\n  'method' | 'payload' | 'initialState'\n>;\n\n/**\n * @since Mini Apps v6.10\n */\nexport class SettingsButton {\n  constructor(options: SettingsButtonOptions) {\n    const button = new Button({\n      ...options,\n      method: 'web_app_setup_settings_button',\n      payload: state => ({ is_visible: state.isVisible }),\n      initialState: { isVisible: false },\n    });\n\n    this.isVisible = button.stateGetter('isVisible');\n    this.isMounted = button.isMounted;\n    this.isSupported = button.isSupported;\n    [[this.hide, this.hideFp], [this.show, this.showFp]] = button.stateBoolSetters('isVisible');\n    this.onClick = button.onClick;\n    this.onClickFp = button.onClickFp;\n    this.offClick = button.offClick;\n    this.offClickFp = button.offClickFp;\n    this.mount = button.mount;\n    this.mountFp = button.mountFp;\n    this.unmount = button.unmount;\n  }\n\n  /**\n   * Signal indicating if the component is currently visible.\n   */\n  readonly isVisible: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Hides the button.\n   * @since Mini Apps v6.10\n   */\n  readonly hideFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see hideFp\n   */\n  readonly hide: WithChecks<() => void, true>;\n\n  /**\n   * Shows the button.\n   * @since Mini Apps v6.10\n   */\n  readonly showFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<() => void, true>;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @since Mini Apps v6.10\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => VoidFunction,\n    true\n  >;\n\n  /**\n   * @see onClickFp\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @since Mini Apps v6.10\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => void,\n    true\n  >;\n\n  /**\n   * @see offClickFp\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, true>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v6.10\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   *\n   * Note that this function does not remove listeners added via the `onClick`\n   * function, so you have to remove them on your own.\n   * @see onClick\n   */\n  readonly unmount: () => void;\n}\n","import { SettingsButton } from '@/features/SettingsButton/SettingsButton.js';\nimport { buttonOptions } from '@/fn-options/buttonOptions.js';\n\nexport const settingsButton = new SettingsButton(\n  buttonOptions('settingsButton', 'settings_button_pressed'),\n);\n","import type { PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecks, type WithChecksFp } from '@/with-checks/withChecksFp.js';\n\nexport interface SwipeBehaviorState {\n  isVerticalEnabled: boolean;\n}\n\nexport interface SwipeBehaviorOptions\n  extends WithStateRestore<SwipeBehaviorState>,\n  WithVersion,\n  WithPostEvent,\n  SharedFeatureOptions {\n}\n\n/**\n * @since Mini Apps v7.7\n */\nexport class SwipeBehavior {\n  constructor({ postEvent, storage, isTma, isPageReload, version }: SwipeBehaviorOptions) {\n    const initialState = { isVerticalEnabled: true };\n    const stateful = new Stateful({\n      initialState,\n      onChange(state) {\n        storage.set(state);\n      },\n    });\n    const mountable = new Mountable({\n      initialState,\n      isPageReload,\n      onMounted: stateful.setState,\n      restoreState: storage.get,\n    });\n\n    const wrapOptions = { requires: 'web_app_setup_swipe_behavior', isTma, version } as const;\n    const wrapSupportedPlain = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'plain',\n    });\n    const wrapMountedEither = createWithChecksFp({\n      ...wrapOptions,\n      isMounted: mountable.isMounted,\n      returns: 'either',\n    });\n\n    const setVerticalEnabled = (isVerticalEnabled: boolean) => {\n      const update = { isVerticalEnabled };\n      if (!stateful.hasDiff(update)) {\n        return E.right(undefined);\n      }\n      return pipe(\n        postEvent('web_app_setup_swipe_behavior', { allow_vertical_swipe: isVerticalEnabled }),\n        E.map(() => {\n          stateful.setState(update);\n        }),\n      );\n    };\n\n    this.isSupported = createIsSupportedSignal('web_app_setup_swipe_behavior', version);\n    this.isVerticalEnabled = stateful.getter('isVerticalEnabled');\n    this.isMounted = mountable.isMounted;\n    this.disableVerticalFp = wrapMountedEither(() => {\n      return setVerticalEnabled(false);\n    });\n    this.enableVerticalFp = wrapMountedEither(() => {\n      return setVerticalEnabled(true);\n    });\n    this.mountFp = wrapSupportedPlain(() => {\n      const nothing = () => undefined;\n      return pipe(mountable.mount(), E.match(nothing, nothing));\n    });\n    this.unmount = mountable.unmount;\n\n    this.disableVertical = throwifyWithChecksFp(this.disableVerticalFp);\n    this.enableVertical = throwifyWithChecksFp(this.enableVerticalFp);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n  }\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Signal indicating if vertical swipes are enabled.\n   */\n  readonly isVerticalEnabled: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v7.7\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n\n  /**\n   * Disables the closing confirmation dialog.\n   * @since Mini Apps v7.7\n   */\n  readonly disableVerticalFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see disableVerticalFp\n   */\n  readonly disableVertical: WithChecks<() => void, true>;\n\n  /**\n   * Enables the closing confirmation dialog.\n   * @since Mini Apps v7.7\n   */\n  readonly enableVerticalFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see enableVerticalFp\n   */\n  readonly enableVertical: WithChecks<() => void, true>;\n}\n","import { pipe } from 'fp-ts/function';\n\nimport { SwipeBehavior, type SwipeBehaviorState } from '@/features/SwipeBehavior/SwipeBehavior.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nexport const swipeBehavior = new SwipeBehavior(pipe(\n  sharedFeatureOptions(),\n  withPostEvent,\n  withVersion,\n  withStateRestore<SwipeBehaviorState>('swipeBehavior'),\n));\n","/**\n * Copies specified text to the clipboard.\n * @param text - text to copy.\n */\nexport async function copyTextToClipboard(text: string): Promise<void> {\n  try {\n    const { clipboard } = navigator;\n    if (clipboard) {\n      return await clipboard.writeText(text);\n    }\n  } catch {\n  }\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n","import { RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { AccessDeniedError } from '@/errors.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nexport type DownloadFileError = RequestError | AccessDeniedError;\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    url: string,\n    fileName: string,\n    options?: AsyncOptions,\n  ): TE.TaskEither<DownloadFileError, void> => {\n    return pipe(\n      request(\n        'web_app_request_file_download',\n        'file_download_requested',\n        { ...options, params: { url, file_name: fileName } },\n      ),\n      TE.chain(response => {\n        return response.status === 'downloading'\n          ? TE.right(undefined)\n          : TE.left(new AccessDeniedError('User denied the action'));\n      }),\n    );\n  }, { ...rest, requires: 'web_app_request_file_download', returns: 'task' });\n}\n\n/**\n * Displays a native popup prompting the user to download a file.\n * @param url - the HTTPS URL of the file to be downloaded.\n * @param file - the suggested name for the downloaded file.\n * @param options - additional request execution options.\n * @since Mini Apps v8.0\n * @example\n * pipe(\n *   downloadFileFp('https://telegram.org/js/telegram-web-app.js', 'telegram-sdk.js'),\n *   TE.map(() => {\n *     console.log('Downloading');\n *   })\n * )\n */\nexport const downloadFileFp = create(pipe(\n  sharedFeatureOptions(),\n  withRequest,\n  withVersion,\n));\n\nexport const downloadFile = throwifyWithChecksFp(downloadFileFp);\n","import * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\nimport { date, integer, number, transform, pipe as valiPipe, safeParse } from 'valibot';\n\nimport { ValidationError } from '@/errors.js';\nimport {\n  type SharedFeatureOptions,\n  sharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport {\n  type WithInvokeCustomMethod,\n  withInvokeCustomMethod,\n  type InvokeCustomMethodError,\n} from '@/fn-options/withInvokeCustomMethod.js';\nimport { type WithVersion, withVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithInvokeCustomMethod, WithVersion {\n}\n\nexport type GetCurrentTimeError = InvokeCustomMethodError | ValidationError;\n\nfunction create({ invokeCustomMethod, ...rest }: CreateOptions) {\n  return withChecksFp((options?: AsyncOptions): TE.TaskEither<GetCurrentTimeError, Date> => {\n    return pipe(\n      invokeCustomMethod('getCurrentTime', {}, options),\n      TE.chain(response => {\n        const parsed = safeParse(\n          valiPipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n          response,\n        );\n        return parsed.success\n          ? TE.right(parsed.output)\n          : TE.left(new ValidationError(response, parsed.issues));\n      }),\n    );\n  }, { ...rest, requires: 'web_app_invoke_custom_method', returns: 'task' });\n}\n\n/**\n * @returns The current time according to the Telegram server time.\n * @param options - additional options.\n * @since Mini Apps v6.9\n */\nexport const getCurrentTimeFp = create(pipe(\n  sharedFeatureOptions(),\n  withInvokeCustomMethod,\n  withVersion,\n));\n\n/**\n * @see getCurrentTimeFp\n */\nexport const getCurrentTime = throwifyWithChecksFp(getCurrentTimeFp);\n","import type { PostEventError } from '@tma.js/bridge';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n}\n\nexport type HideKeyboardError = PostEventError;\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((): E.Either<HideKeyboardError, void> => {\n    return postEvent('web_app_hide_keyboard');\n  }, { ...rest, returns: 'either', requires: 'web_app_hide_keyboard' });\n}\n\n/**\n * Hides the on-screen keyboard, if it is currently visible. Does nothing if the keyboard is\n * not active.\n * @since Mini Apps v9.1\n */\nexport const hideKeyboardFp = create(pipe(\n  sharedFeatureOptions(),\n  withPostEvent,\n  withVersion,\n));\n\n/**\n * @see hideKeyboardFp\n */\nexport const hideKeyboard = throwifyWithChecksFp(hideKeyboardFp);\n","import { captureSameReq, type RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { createRequestId } from '@/globals/createRequestId.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithVersion, WithRequest {\n  createRequestId: () => string;\n}\n\nexport type ReadTextFromClipboardError = RequestError;\n\nfunction create({ request, createRequestId, ...rest }: CreateOptions) {\n  return withChecksFp((\n    options?: AsyncOptions,\n  ): TE.TaskEither<ReadTextFromClipboardError, string | null> => {\n    const reqId = createRequestId();\n    return pipe(\n      request('web_app_read_text_from_clipboard', 'clipboard_text_received', {\n        ...options,\n        params: { req_id: reqId },\n        capture: captureSameReq(reqId),\n      }),\n      TE.map(({ data = null }) => data),\n    );\n  }, { ...rest, requires: 'web_app_read_text_from_clipboard', returns: 'task' });\n}\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in one of the following cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n */\nexport const readTextFromClipboardFp = create({\n  ...pipe(\n    sharedFeatureOptions(),\n    withVersion,\n    withRequest,\n  ),\n  createRequestId,\n});\n\nexport const readTextFromClipboard = throwifyWithChecksFp(readTextFromClipboardFp);\n","export interface AndroidDeviceData {\n  appVersion?: string;\n  manufacturer?: string;\n  model?: string;\n  androidVersion?: string;\n  sdkVersion?: number;\n  performanceClass?: 'LOW' | 'AVERAGE' | 'HIGH' | string;\n}\n\n/**\n * Retrieves Android device data from the specified User Agent.\n * @see https://core.telegram.org/bots/webapps#additional-data-in-user-agent\n * @param userAgent - user agent.\n */\nexport function retrieveAndroidDeviceDataFrom(userAgent: string): AndroidDeviceData {\n  const result: AndroidDeviceData = {};\n  const match = userAgent.match(/Telegram-Android(?:\\/([^ ]+))?(?: (\\([^)]+\\))?|$)/);\n  if (match) {\n    const [, appVersion, systemInfo] = match;\n    appVersion && (result.appVersion = appVersion);\n    systemInfo && systemInfo\n      .slice(1, systemInfo.length - 1)\n      .split(';')\n      .forEach(item => {\n        const [key, value] = item.trim().split(' ');\n        if (key === 'Android') {\n          result.androidVersion = value;\n        } else if (key === 'SDK') {\n          const parsed = parseInt(value, 10);\n          parsed && (result.sdkVersion = parsed);\n        } else if (value) {\n          result.manufacturer = key;\n          result.model = value;\n        } else {\n          result.performanceClass = key;\n        }\n      });\n  }\n  return result;\n}\n","import {\n  type AndroidDeviceData,\n  retrieveAndroidDeviceDataFrom,\n} from './retrieveAndroidDeviceDataFrom.js';\n\n/**\n * Retrieves Android device data from the navigator.userAgent.\n * @see https://core.telegram.org/bots/webapps#additional-data-in-user-agent\n */\nexport function retrieveAndroidDeviceData(): AndroidDeviceData {\n  return retrieveAndroidDeviceDataFrom(navigator.userAgent);\n}\n","import type { PostEventError } from '@tma.js/bridge';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { InvalidArgumentsError } from '@/errors.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent {\n}\n\nexport type SendDataError = PostEventError | InvalidArgumentsError;\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((data: string): E.Either<SendDataError, void> => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      return E.left(\n        new InvalidArgumentsError(size\n          ? 'Maximum size of data to send is 4096 bytes'\n          : 'Attempted to send empty data'),\n      );\n    }\n    return postEvent('web_app_data_send', { data });\n  }, { ...rest, returns: 'either' });\n}\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n */\nexport const sendDataFp = create(pipe(sharedFeatureOptions(), withPostEvent));\n\n/**\n * @see sendDataFp\n */\nexport const sendData = throwifyWithChecksFp(sendDataFp);\n","import { RequestError } from '@tma.js/bridge';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { ShareMessageError } from '@/errors.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nexport type ShareMessageFnError = RequestError | ShareMessageError;\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    messageId: string,\n    options?: AsyncOptions,\n  ): TE.TaskEither<ShareMessageFnError, void> => {\n    return pipe(\n      request(\n        'web_app_send_prepared_message',\n        ['prepared_message_failed', 'prepared_message_sent'],\n        {\n          ...options,\n          params: { id: messageId },\n        },\n      ),\n      TE.chain(response => (\n        response.event === 'prepared_message_failed'\n          ? TE.left(new ShareMessageError(response.payload.error))\n          : TE.right(undefined)\n      )),\n    );\n  }, { ...rest, requires: 'web_app_send_prepared_message', returns: 'task' });\n}\n\n/**\n * Opens a dialog allowing the user to share a message provided by the bot.\n * @since Mini Apps v8.0\n */\nexport const shareMessageFp = create(pipe(\n  sharedFeatureOptions(),\n  withRequest,\n  withVersion,\n));\n\n/**\n * @see shareMessageFp\n */\nexport const shareMessage = throwifyWithChecksFp(shareMessageFp);\n","import type { PostEventError } from '@tma.js/bridge';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n}\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\nexport type ShareStoryError = PostEventError;\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((\n    mediaUrl: string,\n    options: ShareStoryOptions = {},\n  ): E.Either<ShareStoryError, void> => {\n    return postEvent('web_app_share_to_story', {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  }, { ...rest, requires: 'web_app_share_to_story', returns: 'either' });\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @example\n * pipe(\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   }),\n *   TE.match(error => {\n *     console.error('Something went wrong', error);\n *   }, () => {\n *     console.log('Call was successful');\n *   }),\n * );\n */\nexport const shareStoryFp = create(pipe(\n  sharedFeatureOptions(),\n  withPostEvent,\n  withVersion,\n));\n\n/**\n * @see shareStoryFp\n */\nexport const shareStory = throwifyWithChecksFp(shareStoryFp);\n","import { createSignal } from '@/globals/signals-registry.js';\n\n/**\n * True if the application is launched in inline mode.\n */\nexport const isInlineMode = createSignal(false);\n","import type { PostEventError, SwitchInlineQueryChatType } from '@tma.js/bridge';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { isInlineMode } from '@/globals/isInlineMode.js';\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n  isInlineMode: MaybeAccessor<boolean>;\n}\n\nexport type SwitchInlineQueryError = PostEventError;\n\nfunction create({ isInlineMode, postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((\n    query: string,\n    chatTypes?: SwitchInlineQueryChatType[],\n  ): E.Either<SwitchInlineQueryError, void> => {\n    return postEvent('web_app_switch_inline_query', {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  }, {\n    ...rest,\n    requires: {\n      every: ['web_app_switch_inline_query', () => {\n        return access(isInlineMode)\n          ? undefined\n          : 'The application must be launched in the inline mode';\n      }],\n    },\n    returns: 'either',\n  });\n}\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @example\n * pipe(\n *   switchInlineQuery('my query goes here', ['users']),\n *   E.match(error => {\n *     console.error('Something went wrong', error);\n *   }, () => {\n *     console.log('Call was successful');\n *   }),\n * );\n */\nexport const switchInlineQueryFp = create({\n  ...pipe(\n    sharedFeatureOptions(),\n    withPostEvent,\n    withVersion,\n  ),\n  isInlineMode,\n});\n\n/**\n * @see switchInlineQueryFp\n */\nexport const switchInlineQuery = throwifyWithChecksFp(switchInlineQueryFp);\n","import {\n  type SafeAreaInsets,\n  type EventListener,\n  supports,\n  type RequestError,\n  type PostEventError,\n} from '@tma.js/bridge';\nimport { Computed, computed, signal } from '@tma.js/signals';\nimport { camelToKebab } from '@tma.js/toolkit';\nimport { BetterPromise } from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { AsyncMountable } from '@/composables/AsyncMountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport { CSSVarsBoundError, FullscreenFailedError } from '@/errors.js';\nimport { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { WithRequest } from '@/fn-options/withRequest.js';\nimport { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport { WithVersion } from '@/fn-options/withVersion.js';\nimport { access } from '@/helpers/access.js';\nimport { deleteCssVar, setCssVar } from '@/helpers/css-vars.js';\nimport { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, WithChecks, WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype FullscreenError = FullscreenFailedError | RequestError;\ntype ViewportChangedEventListener = EventListener<'viewport_changed'>;\ntype FullscreenChangedEventListener = EventListener<'fullscreen_changed'>;\ntype SafeAreaInsetsChangedEventListener = EventListener<'safe_area_changed'>;\ntype SafeAreaInsetCSSVarKey = `safeAreaInset${Capitalize<keyof SafeAreaInsets>}`;\n\nexport type GetCSSVarNameKey =\n  | 'width'\n  | 'height'\n  | 'stableHeight'\n  | SafeAreaInsetCSSVarKey\n  | `content${Capitalize<SafeAreaInsetCSSVarKey>}`;\n\nexport type GetCSSVarNameFn = (key: GetCSSVarNameKey) => string | null | undefined | false;\n\nexport interface ViewportState {\n  contentSafeAreaInsets: SafeAreaInsets;\n  height: number;\n  isExpanded: boolean;\n  isFullscreen: boolean;\n  safeAreaInsets: SafeAreaInsets;\n  stableHeight: number;\n  width: number;\n}\n\ntype WithListeners<On extends string, Off extends string, L> = {\n  [K in On | Off]: (listener: L) => void;\n};\n\nexport interface ViewportOptions<EViewportStable, EFullscreen>\n  extends WithStateRestore<ViewportState>,\n  WithVersion,\n  WithRequest,\n  WithPostEvent,\n  WithListeners<'onViewportChanged', 'offViewportChanged', ViewportChangedEventListener>,\n  WithListeners<'onFullscreenChanged', 'offFullscreenChanged', FullscreenChangedEventListener>,\n  WithListeners<'onSafeAreaInsetsChanged', 'offSafeAreaInsetsChanged', SafeAreaInsetsChangedEventListener>,\n  WithListeners<'onContentSafeAreaInsetsChanged', 'offContentSafeAreaInsetsChanged', SafeAreaInsetsChangedEventListener>,\n  SharedFeatureOptions {\n  /**\n   * True if the viewport is stable.\n   */\n  isViewportStable: boolean | (() => E.Either<EViewportStable, boolean>);\n  /**\n   * True if the application was opened in fullscreen initially.\n   */\n  isFullscreen: boolean | (() => E.Either<EFullscreen, boolean>);\n}\n\nexport class Viewport<EViewportStable, EFullscreen> {\n  constructor({\n    storage,\n    isPageReload,\n    onContentSafeAreaInsetsChanged,\n    onSafeAreaInsetsChanged,\n    onViewportChanged,\n    onFullscreenChanged,\n    offContentSafeAreaInsetsChanged,\n    offFullscreenChanged,\n    offSafeAreaInsetsChanged,\n    offViewportChanged,\n    request,\n    isViewportStable,\n    isFullscreen,\n    isTma,\n    version,\n    postEvent,\n  }: ViewportOptions<EViewportStable, EFullscreen>) {\n    const initialInsets: SafeAreaInsets = { top: 0, right: 0, left: 0, bottom: 0 };\n    const stateful = new Stateful<ViewportState>({\n      initialState: {\n        contentSafeAreaInsets: initialInsets,\n        height: 0,\n        isExpanded: false,\n        isFullscreen: false,\n        safeAreaInsets: initialInsets,\n        stableHeight: 0,\n        width: 0,\n      },\n      onChange: storage.set,\n    });\n\n    const viewportChangedListener: ViewportChangedEventListener = event => {\n      stateful.setState({\n        isExpanded: event.is_expanded,\n        height: event.height,\n        width: event.width,\n        stableHeight: event.is_state_stable ? event.height : undefined,\n      });\n    };\n    const fullscreenChangedListener: FullscreenChangedEventListener = event => {\n      stateful.setState({ isFullscreen: event.is_fullscreen });\n    };\n    const safeAreaInsetsChangedListener: SafeAreaInsetsChangedEventListener = event => {\n      stateful.setState({ safeAreaInsets: event });\n    };\n    const contentSafeAreaInsetsChangedListener: SafeAreaInsetsChangedEventListener = event => {\n      stateful.setState({ contentSafeAreaInsets: event });\n    };\n\n    const mountable = new AsyncMountable({\n      initialState(options) {\n        const genRequestInsets = (kind: 'safe-area' | 'content-safe-area') => {\n          return () => {\n            const [method, event] = kind === 'safe-area'\n              ? ['web_app_request_safe_area', 'safe_area_changed'] as const\n              : ['web_app_request_content_safe_area', 'content_safe_area_changed'] as const;\n\n            if (!supports(method, access(version))) {\n              return TE.right({ top: 0, left: 0, right: 0, bottom: 0 });\n            }\n            return request(method, event, options);\n          };\n        };\n        const genFlag = <E>(flag: boolean | (() => E.Either<E, boolean>)) => {\n          return () => (\n            typeof flag === 'boolean'\n              ? TE.right(flag)\n              : TE.fromEither(flag())\n          );\n        };\n\n        return pipe(\n          TE.Do,\n          TE.bindW('safeAreaInsets', genRequestInsets('safe-area')),\n          TE.bindW('contentSafeAreaInsets', genRequestInsets('content-safe-area')),\n          TE.bindW('isFullscreen', genFlag(isFullscreen)),\n          TE.bindW('isViewportStable', genFlag(isViewportStable)),\n          TE.chainW(({ isViewportStable, ...shared }) => {\n            if (isViewportStable) {\n              return TE.right({\n                ...shared,\n                height: window.innerHeight,\n                isExpanded: true,\n                stableHeight: window.innerHeight,\n                width: window.innerWidth,\n              });\n            }\n            return pipe(\n              request('web_app_request_viewport', 'viewport_changed', options),\n              TE.map(viewport => ({\n                ...shared,\n                height: viewport.height,\n                isExpanded: viewport.is_expanded,\n                stableHeight: viewport.is_state_stable ? viewport.height : 0,\n                width: viewport.width,\n              })),\n            );\n          }),\n        );\n      },\n      isPageReload,\n      onMounted(state) {\n        onViewportChanged(viewportChangedListener);\n        onFullscreenChanged(fullscreenChangedListener);\n        onSafeAreaInsetsChanged(safeAreaInsetsChangedListener);\n        onContentSafeAreaInsetsChanged(contentSafeAreaInsetsChangedListener);\n        stateful.setState(state);\n      },\n      onUnmounted() {\n        offViewportChanged(viewportChangedListener);\n        offFullscreenChanged(fullscreenChangedListener);\n        offSafeAreaInsetsChanged(safeAreaInsetsChangedListener);\n        offContentSafeAreaInsetsChanged(contentSafeAreaInsetsChangedListener);\n      },\n      restoreState: storage.get,\n    });\n\n    const saBased = <K extends keyof SafeAreaInsets>(key: K) => {\n      return computed(() => this.safeAreaInsets()[key]);\n    };\n    const csaBased = <K extends keyof SafeAreaInsets>(key: K) => {\n      return computed(() => this.contentSafeAreaInsets()[key]);\n    };\n\n    this.state = stateful.state;\n    this.height = stateful.getter('height');\n    this.stableHeight = stateful.getter('stableHeight');\n    this.width = stateful.getter('width');\n    this.isExpanded = stateful.getter('isExpanded');\n    this.safeAreaInsets = stateful.getter('safeAreaInsets');\n    this.safeAreaInsetTop = saBased('top');\n    this.safeAreaInsetBottom = saBased('bottom');\n    this.safeAreaInsetLeft = saBased('left');\n    this.safeAreaInsetRight = saBased('right');\n    this.contentSafeAreaInsets = stateful.getter('contentSafeAreaInsets');\n    this.contentSafeAreaInsetTop = csaBased('top');\n    this.contentSafeAreaInsetBottom = csaBased('bottom');\n    this.contentSafeAreaInsetLeft = csaBased('left');\n    this.contentSafeAreaInsetRight = csaBased('right');\n\n    const wrapTask = createWithChecksFp({ isTma, returns: 'task' });\n    const wrapMountedEither = createWithChecksFp({\n      isTma,\n      returns: 'either',\n    });\n    const wrapFullscreenTask = createWithChecksFp({\n      isTma,\n      requires: 'web_app_request_fullscreen',\n      version,\n      returns: 'task',\n    });\n    const genFullscreenFn = (enable: boolean) => {\n      return wrapFullscreenTask((options?: AsyncOptions) => {\n        return pipe(\n          request(\n            enable ? 'web_app_request_fullscreen' : 'web_app_exit_fullscreen',\n            ['fullscreen_changed', 'fullscreen_failed'],\n            options,\n          ),\n          TE.chain(response => {\n            if (\n              response.event === 'fullscreen_failed'\n              && response.payload.error !== 'ALREADY_FULLSCREEN'\n            ) {\n              return TE.left(new FullscreenFailedError(response.payload.error));\n            }\n            stateful.setState({\n              isFullscreen: 'is_fullscreen' in response.payload\n                ? response.payload.is_fullscreen\n                : true,\n            });\n            return TE.right(undefined);\n          }),\n        );\n      });\n    };\n\n    // Mount.\n    this.isMounted = mountable.isMounted;\n    this.mountFp = wrapTask(mountable.mount);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n\n    // Fullscreen.\n    this.isFullscreen = stateful.getter('isFullscreen');\n    this.requestFullscreenFp = genFullscreenFn(true);\n    this.requestFullscreen = throwifyWithChecksFp(this.requestFullscreenFp);\n    this.exitFullscreenFp = genFullscreenFn(false);\n    this.exitFullscreen = throwifyWithChecksFp(this.exitFullscreenFp);\n\n    // CSS vars.\n    const isCssVarsBound = signal(false);\n    this.isCssVarsBound = computed(isCssVarsBound);\n    this.bindCssVarsFp = wrapMountedEither(\n      (getCSSVarName?: GetCSSVarNameFn) => {\n        if (isCssVarsBound()) {\n          return E.left(new CSSVarsBoundError());\n        }\n        getCSSVarName ||= prop => `--tg-viewport-${camelToKebab(prop)}`;\n\n        const settings = ([\n          ['height', this.height],\n          ['stableHeight', this.stableHeight],\n          ['width', this.width],\n          ['safeAreaInsetTop', this.safeAreaInsetTop],\n          ['safeAreaInsetBottom', this.safeAreaInsetBottom],\n          ['safeAreaInsetLeft', this.safeAreaInsetLeft],\n          ['safeAreaInsetRight', this.safeAreaInsetRight],\n          ['contentSafeAreaInsetTop', this.contentSafeAreaInsetTop],\n          ['contentSafeAreaInsetBottom', this.contentSafeAreaInsetBottom],\n          ['contentSafeAreaInsetLeft', this.contentSafeAreaInsetLeft],\n          ['contentSafeAreaInsetRight', this.contentSafeAreaInsetRight],\n        ] as const).reduce<{\n          update: VoidFunction;\n          removeListener: VoidFunction;\n          cssVar: string;\n        }[]>((acc, [key, signal]) => {\n          const cssVar = getCSSVarName(key);\n          if (cssVar) {\n            const update = () => {\n              setCssVar(cssVar, `${signal()}px`);\n            };\n            acc.push({ update, removeListener: signal.sub(update), cssVar });\n          }\n          return acc;\n        }, []);\n\n        settings.forEach(setting => {\n          setting.update();\n        });\n        isCssVarsBound.set(true);\n\n        return E.right(() => {\n          settings.forEach(s => {\n            s.removeListener();\n            deleteCssVar(s.cssVar);\n          });\n          isCssVarsBound.set(false);\n        });\n      },\n    );\n    this.bindCssVars = throwifyWithChecksFp(this.bindCssVarsFp);\n\n    // Other methods.\n    this.expandFp = wrapMountedEither(() => postEvent('web_app_expand'));\n    this.expand = throwifyWithChecksFp(this.expandFp);\n  }\n\n  //#region Other properties.\n  /**\n   * Complete component state.\n   */\n  readonly state: Computed<ViewportState>;\n\n  /**\n   * Signal containing the current height of the **visible area** of the Mini App.\n   *\n   * The application can display just the top part of the Mini App, with its\n   * lower part remaining outside the screen area. From this position, the user\n   * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n   * by calling `expand` method. As the position of the Mini App changes, the\n   * current height value of the visible area will be updated  in real time.\n   *\n   * Please note that the refresh rate of this value is not sufficient to\n   * smoothly follow the lower border of the window. It should not be used to pin\n   * interface elements to the bottom of the visible area. It's more appropriate\n   * to use the value of the `stableHeight` field for this purpose.\n   *\n   * @see stableHeight\n   */\n  readonly height: Computed<number>;\n\n  /**\n   * Signal containing the height of the visible area of the Mini App in its last stable state.\n   *\n   * The application can display just the top part of the Mini App, with its\n   * lower part remaining outside the screen area. From this position, the user\n   * can \"pull\" the Mini App to its maximum height, while the application can do\n   * the same by calling `expand` method.\n   *\n   * Unlike the value of `height`, the value of `stableHeight` does not change as\n   * the position of the Mini App changes with user gestures or during\n   * animations. The value of `stableHeight` will be updated after all gestures\n   * and animations are completed and the Mini App reaches its final size.\n   *\n   * @see height\n   */\n  readonly stableHeight: Computed<number>;\n\n  /**\n   * Signal containing the currently visible area width.\n   */\n  readonly width: Computed<number>;\n\n  /**\n   * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n   * if the Mini App occupies part of the screen and can be expanded to the full\n   * height using the `expand` method.\n   */\n  readonly isExpanded: Computed<boolean>;\n\n  /**\n   * Signal indicating if the current viewport height is stable and is not going to change in\n   * the next moment.\n   */\n  readonly isStable = computed(() => this.height() === this.stableHeight());\n  //#endregion\n\n  //#region Content safe area insets.\n  /**\n   * Signal containing content safe area insets.\n   */\n  readonly contentSafeAreaInsets: Computed<SafeAreaInsets>;\n\n  /**\n   * Signal containing top content safe area inset.\n   */\n  readonly contentSafeAreaInsetTop: Computed<number>;\n\n  /**\n   * Signal containing left content safe area inset.\n   */\n  readonly contentSafeAreaInsetLeft: Computed<number>;\n\n  /**\n   * Signal containing right content safe area inset.\n   */\n  readonly contentSafeAreaInsetRight: Computed<number>;\n\n  /**\n   * Signal containing bottom content safe area inset.\n   */\n  readonly contentSafeAreaInsetBottom: Computed<number>;\n  //#endregion\n\n  //#region Safe area insets.\n  /**\n   * Signal containing safe area insets.\n   */\n  readonly safeAreaInsets: Computed<SafeAreaInsets>;\n\n  /**\n   * Signal containing top safe area inset.\n   */\n  readonly safeAreaInsetTop: Computed<number>;\n\n  /**\n   * Signal containing left safe area inset.\n   */\n  readonly safeAreaInsetLeft: Computed<number>;\n\n  /**\n   * Signal containing right safe area inset.\n   */\n  readonly safeAreaInsetRight: Computed<number>;\n\n  /**\n   * Signal containing bottom safe area inset.\n   */\n  readonly safeAreaInsetBottom: Computed<number>;\n  //#endregion\n\n  //#region Fullscreen.\n  /**\n   * Signal indicating if the viewport is currently in fullscreen mode.\n   */\n  readonly isFullscreen: Computed<boolean>;\n\n  /**\n   * Requests fullscreen mode for the mini application.\n   * @since Mini Apps v8.0\n   */\n  readonly requestFullscreenFp: WithChecksFp<\n    (options?: AsyncOptions) => TE.TaskEither<FullscreenError, void>,\n    true\n  >;\n\n  /**\n   * @see requestFullscreenFp\n   */\n  readonly requestFullscreen: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, true>;\n\n  /**\n   * Exits mini application from the fullscreen mode.\n   * @since Mini Apps v8.0\n   */\n  readonly exitFullscreenFp: WithChecksFp<\n    (options?: AsyncOptions) => TE.TaskEither<FullscreenError, void>,\n    true\n  >;\n\n  /**\n   * @see exitFullscreenFp\n   */\n  readonly exitFullscreen: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, true>;\n  //#endregion\n\n  //#region CSS Vars.\n  /**\n   * Signal indicating if CSS variables are bound.\n   */\n  readonly isCssVarsBound: Computed<boolean>;\n\n  /**\n   * Creates CSS variables connected with the current viewport.\n   *\n   * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n   * {name} is a viewport property name converted from camel case to kebab case.\n   *\n   * Default variables:\n   * - `--tg-viewport-height`\n   * - `--tg-viewport-width`\n   * - `--tg-viewport-stable-height`\n   * - `--tg-viewport-content-safe-area-inset-top`\n   * - `--tg-viewport-content-safe-area-inset-bottom`\n   * - `--tg-viewport-content-safe-area-inset-left`\n   * - `--tg-viewport-content-safe-area-inset-right`\n   * - `--tg-viewport-safe-area-inset-top`\n   * - `--tg-viewport-safe-area-inset-bottom`\n   * - `--tg-viewport-safe-area-inset-left`\n   * - `--tg-viewport-safe-area-inset-right`\n   *\n   * Variables are being automatically updated if the viewport was changed.\n   *\n   * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n   * variable will only be defined if the function returned non-empty string value.\n   * @returns Function to stop updating variables.\n   * @example Using no arguments\n   * bindCssVarsFp();\n   * @example Using custom CSS vars generator\n   * bindCssVarsFp(key => `--my-prefix-${key}`);\n   */\n  readonly bindCssVarsFp: WithChecksFp<(getCSSVarName?: GetCSSVarNameFn) => (\n    E.Either<CSSVarsBoundError, VoidFunction>\n  ), false>;\n\n  /**\n   * @see bindCssVarsFp\n   */\n  readonly bindCssVars: WithChecks<(getCSSVarName?: GetCSSVarNameFn) => VoidFunction, false>;\n  //#endregion\n\n  //#region Mount.\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component.\n   */\n  readonly mountFp: WithChecksFp<(options?: AsyncOptions) => (\n    TE.TaskEither<EFullscreen | EViewportStable | RequestError, void>\n  ), false>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, false>;\n  //#endregion\n\n  //#region Other methods.\n  /**\n   * A method that expands the Mini App to the maximum available height. To find\n   * out if the Mini App is expanded to the maximum height, refer to the value of\n   * the `isExpanded`.\n   */\n  readonly expandFp: WithChecksFp<() => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see expandFp\n   */\n  readonly expand: WithChecks<() => void, false>;\n  //#endregion\n}\n","import { retrieveLaunchParamsFp, on, off, type EventName, EventListener } from '@tma.js/bridge';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { Viewport, type ViewportState } from '@/features/Viewport/Viewport.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction create() {\n  const createListeners = <E extends EventName>(event: E) => {\n    return {\n      on: (listener: EventListener<E>) => {\n        on(event, listener);\n      },\n      off: (listener: EventListener<E>) => {\n        off(event, listener);\n      },\n    };\n  };\n  const viewportListeners = createListeners('viewport_changed');\n  const fullscreenListeners = createListeners('fullscreen_changed');\n  const safeAreaListeners = createListeners('safe_area_changed');\n  const contentSafeAreaListeners = createListeners('content_safe_area_changed');\n\n  return new Viewport({\n    ...pipe(\n      sharedFeatureOptions(),\n      withStateRestore<ViewportState>('viewport'),\n      withVersion,\n      withPostEvent,\n      withRequest,\n    ),\n    isFullscreen() {\n      return pipe(retrieveLaunchParamsFp(), E.map(lp => !!lp.tgWebAppFullscreen));\n    },\n    isViewportStable() {\n      return pipe(retrieveLaunchParamsFp(), E.map(lp => {\n        return ['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform);\n      }));\n    },\n    offContentSafeAreaInsetsChanged: contentSafeAreaListeners.off,\n    offFullscreenChanged: fullscreenListeners.off,\n    offSafeAreaInsetsChanged: safeAreaListeners.off,\n    offViewportChanged: viewportListeners.off,\n    onContentSafeAreaInsetsChanged: contentSafeAreaListeners.on,\n    onFullscreenChanged: fullscreenListeners.on,\n    onSafeAreaInsetsChanged: safeAreaListeners.on,\n    onViewportChanged: viewportListeners.on,\n  });\n}\n\nexport const viewport = create();\n","import {\n  on,\n  logger,\n  retrieveLaunchParamsFp,\n  type RetrieveLaunchParamsError,\n  type PostEventError,\n  type PostEventFpFn,\n} from '@tma.js/bridge';\nimport { createCbCollector, throwifyFpFn } from '@tma.js/toolkit';\nimport type { Version, ThemeParams } from '@tma.js/types';\nimport * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nimport { isInlineMode } from '@/globals/isInlineMode.js';\nimport { postEventFpSignal, postEventFp, postEvent } from '@/globals/postEvent.js';\nimport { themeParams } from '@/globals/themeParams.js';\nimport { version } from '@/globals/version.js';\n\nexport interface InitOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n  /**\n   * True if the application is launched in inline mode.\n   * @default Will be calculated based on the launch parameters' tgWebAppBotInline field.\n   */\n  isInlineMode?: boolean;\n  /**\n   * A custom `postEvent` function to use across the package.\n   * @default tma.js/bridge's postEventFp function will be used.\n   */\n  postEvent?: PostEventFpFn;\n  /**\n   * Mini application theme parameters.\n   * @default Will be calculated based on the launch parameters' tgWebAppThemeParams field.\n   */\n  themeParams?: ThemeParams;\n  /**\n   * Telegram Mini Apps version supported by the Telegram client.\n   * @default Will be calculated based on the launch parameters' tgWebAppVersion field.\n   */\n  version?: Version;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application. This function also configure the package's global dependencies (functions,\n * variables used across the package).\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function initFp(\n  options: InitOptions = {},\n): E.Either<RetrieveLaunchParamsError | PostEventError, VoidFunction> {\n  const {\n    version: optionsVersion,\n    isInlineMode: optionsInlineMode,\n    themeParams: optionsThemeParams,\n  } = options;\n\n  if (optionsVersion && typeof optionsInlineMode === 'boolean' && optionsThemeParams) {\n    version.set(optionsVersion);\n    isInlineMode.set(optionsInlineMode);\n    themeParams.set(optionsThemeParams);\n  } else {\n    const error = pipe(retrieveLaunchParamsFp(), E.matchW(\n      err => err,\n      lp => {\n        version.set(optionsVersion || lp.tgWebAppVersion);\n        isInlineMode.set(typeof optionsInlineMode === 'boolean'\n          ? optionsInlineMode\n          : !!lp.tgWebAppBotInline);\n        themeParams.set(optionsThemeParams || lp.tgWebAppThemeParams);\n      },\n    ));\n    if (error) {\n      return E.left(error);\n    }\n  }\n  if (options.postEvent) {\n    postEventFpSignal.set(options.postEvent);\n  }\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logger().log('Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options;\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  return pipe(\n    postEventFp('iframe_ready', { reload_supported: true }),\n    E.map(() => {\n      logger().log('The package was initialized');\n      return cleanup;\n    }),\n  );\n}\n\n/**\n * @see initFp\n */\nexport const init = throwifyFpFn(initFp);\n","function _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n    } else obj[key] = value;\n\n    return obj;\n}\nexport { _define_property as _ };\n","import { _ as _define_property } from \"./_define_property.js\";\n\nfunction _object_spread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(\n                Object.getOwnPropertySymbols(source).filter(function(sym) {\n                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n                })\n            );\n        }\n\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n\n    return target;\n}\nexport { _object_spread as _ };\n","function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n\n    if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n\n    return target;\n}\nexport { _object_spread_props as _ };\n","function _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n\n    return target;\n}\nexport { _object_without_properties_loose as _ };\n","export function classNames(...args) {\n    const result = [];\n    args.forEach((item)=>{\n        if (!item) {\n            return;\n        }\n        switch(typeof item){\n            case 'string':\n                result.push(item);\n                break;\n            case 'object':\n                Object.keys(item).forEach((key)=>{\n                    if (item[key]) {\n                        result.push(key);\n                    }\n                });\n                break;\n            default:\n                result.push(`${item}`);\n        }\n    });\n    return result.join(' ');\n}\n\n//# sourceMappingURL=classNames.js.map","import { _ as _object_without_properties_loose } from \"./_object_without_properties_loose.js\";\n\nfunction _object_without_properties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _object_without_properties_loose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n\n    return target;\n}\nexport { _object_without_properties as _ };\n","'use client';\n\nimport { createContext, RefObject } from 'react';\n\nexport interface AppRootContextInterface {\n  platform?: 'base' | 'ios';\n  appearance?: 'light' | 'dark';\n  portalContainer?: RefObject<HTMLDivElement>;\n  isRendered: boolean;\n}\n\nexport const AppRootContext = createContext<AppRootContextInterface>({\n  isRendered: false,\n});\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { isHTMLElement } from \"@floating-ui/utils/dom\";\nexport const canUseDOM = (()=>!!(typeof window !== 'undefined' && window.document && window.document.createElement))();\nexport const getHTMLElementByChildren = (children, index)=>{\n    const foundEl = children[index];\n    return isHTMLElement(foundEl) ? foundEl : null;\n};\nexport const getHTMLElementSiblingByDirection = (el, direction)=>{\n    let siblingEl = null;\n    switch(direction){\n        case 'left':\n            siblingEl = el.previousElementSibling;\n            break;\n        case 'right':\n            siblingEl = el.nextElementSibling;\n            break;\n        default:\n            return null;\n    }\n    return isHTMLElement(siblingEl) ? siblingEl : null;\n};\n\n//# sourceMappingURL=dom.js.map","import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","\"use strict\";\n\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) return obj;\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") return { default: obj };\n\n    var cache = _getRequireWildcardCache(nodeInterop);\n\n    if (cache && cache.has(obj)) return cache.get(obj);\n\n    var newObj = { __proto__: null };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);\n            else newObj[key] = obj[key];\n        }\n    }\n\n    newObj.default = obj;\n\n    if (cache) cache.set(obj, newObj);\n\n    return newObj;\n}\nexports._ = _interop_require_wildcard;\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n","import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n"],"names":["callbacks","runInBatchMode","signal","fn","batch","cb","initialValue","options","equals","listeners","value","set","v","prev","s","once","unsub","formatSubOptions","onceOrOptions","idx","listener","lOptions","collectSignal","l","collectContexts","computed","deps","$signal","compute","update","collectedSignals","result","args","pipe","a","ab","bc","cd","de","ef","gh","hi","match","createIsInstanceOf","Class","o","e","t","n","c","name","toSuper","_CustomError","camelToSnakeObjKeys","acc","k","camelToSnake","params","m","__publicField","snakeToCamelObjKeys","CustomError","f","snakeToCamel","camelCased","errorClassWithData","fg","key","errorClass","u","r","deepSnakeToCamelObjKeys","toData","ret","i","snakeToKebab","_","letter","CancelledError","isLeft","ma","TimeoutError","left","formatKey","timeout","right","cause","getStorageValue","_.left","_.right","map","tag","fa","isResolved","_.isLeft","tryCatch","onThrow","cbs","withInheritedResolvers","parentPromise","childPromise","transformQueryToSchema","schema","transformer","arg1","maybeOptions","reject","resolve","executor","input","resolved","rejected","accValue","isRejected","createLogger","cleanupFns","cleanup","string","instance","textColor","isResolvedOrRejected","res","rej","optionsShouldLog","abortOnResolve","abortOnReject","shouldLogValue","shouldLog","print","level","force","_a","_b","commonCss","timeBgColor","timeTextColor","prefix","controller","withResolved","transform","reason","abortSignal","transformJsonToSchema","check","scope","bgColor","timeoutId","pipeQueryToSchema","forceMethod","union","voidFn","to","from","pack","ar","guardBasedOn","re","flow","ij","isRGBShort","isRGBAShort","isRGB","isRGBA","isAnyRGB","event","expandRgb","color","toRGBFullFp","clean","eventListeners","index","E.right","component","E.left","toRGBFp","E.map","rgb","toRGB","throwifyFpFn","toRGBFull","initDataChat","looseObject","number","optional","initDataUser","boolean","context","initData","date","BetterPromise","arity","body","isDataFirst","integer","pipeJsonToSchema","self","__spreadArray","onRejected","themeParams","matchW","onLeft","onRight","onFinally","F","onFulfilled","launchParams","optBool","flatMap","M","E.isLeft","initDataQuery","E.match","launchParamsQuery","_map","_apPar","isLaunchParamsQuery","fab","ap","is","miniAppsMessage","unknown","parseInitDataQueryFp","E.tryCatch","parse","of","parseLaunchParamsQueryFp","dual","parseInitDataQuery","parseLaunchParamsQuery","serializeToQuery","onObject","URI","Functor","Pointed","Monad","serializeInitDataQuery","serializeLaunchParamsQuery","__awaiter","thisArg","_arguments","P","generator","adopt","fulfilled","step","__generator","y","g","verb","op","ET.left","T.Pointed","ET.right","fromEither","T.of","ET.match","T.Functor","reason_1","ET.flatMap","T.Monad","chainW","throwifyAnyEither","either","onError","TE.match","data","BetterTaskEither","TE.tryCatch","_rej","error","TE.chainW","TE.left","TE.right","TE.fromEither","TE.matchW","all","Map","on","type","handler","handlers","get","push","off","splice","indexOf","emit","evt","slice","hasWebviewProxy","identity","none","some","emptyRecord","G","gab","ga","bimap","bind","mapLeft","b","foldW","fold","_ap","chain","_.none","_.some","isNone","onNone","onSome","apW","Apply","Chain","mapBoth","Do","_.emptyRecord","chainable.bind","bindW","access","Mountable","onMounted","initialState","onUnmounted","restored","isPageReload","restoreState","state","ET.mapBoth","method","version","MethodParameterUnsupportedError","removeUndefined","param","LaunchParamsRetrieveError","errors","shallowEqual","aKeys","bKeys","aKey","onChange","source","InvalidLaunchParamsError","nextState","InvokeCustomMethodFailedError","SESSION_STORAGE_KEY","urlString","retrieveLaunchParamsFp","retrieveRawLaunchParamsFp","E.chainW","retrieveLaunchParams","retrieveRawInitDataFp","raw","O.some","O.none","retrieveRawInitData","E.fold","err","O.match","createIsSupportedSignal","supports","retrieve","navigationEntry","retrieveLpFromUrl","maybeError","E.foldW","throwifyWithChecksFp","setStorageValue","retrieveRawLaunchParams","createEmitter","onFirst","onEmpty","eventToHandlersMap","emitter","mitt","handlersMap","item","prevSize","map_","E.Functor","internalHandler","ap_","E.Apply","E.bimap","emitEvent","eventData","eventType","_debug","onEventReceived","debug","setDebug","targetOrigin","_targetOrigin","origin","logger","postMessageImpl","resetGlobals","defineFnComposer","obj","propertyName","initialFn","assignedFunctions","property","callAssignedFunctions","unwrappableCallAssignedFunctions","ApplyPar","poolSize","defineStaticProperty","defineProxiedProperty","defineMergeableProperty","prop","objKey","objValue","transformers","nullish","windowMessageListener","message","offAll","wnd","ET.map","ET.ap","T.ApplyPar","path","cursor","msgToTuple","receiveEventOwner","receiveEvent","ValidationError","issues","postEvent","postEventFp","CSSVarsBoundError","E.mapLeft","DeviceStorageMethodError","SecureStorageMethodError","NotAvailableError","w","isIframe","postMessage","UnknownEnvError","InvalidEnvError","request2Fp","eventOrEvents","capture","FunctionUnavailableError","addCleanup","createCbCollector","payload","isEventsArray","InvalidArgumentsError","ConcurrentCallError","withCleanup","TE.mapBoth","FullscreenFailedError","request2","ShareMessageError","UnknownThemeParamsKeyError","withChecksFp","isTma","optionsIsSupported","returns","isSupportedSimplified","isOptionSupported","optionName","isTMA","optionSettings","monad","isTMAFp","calculateSupportError","mode","requirements","requirement","calculateOptionSupportError","hasProxy","isSupported","isInitialized","isMounted","isAvailable","wrapError","call","mockTelegramEnv","onEvent","resetPostMessage","errMessagePrefix","supportErr","supportsOptionErr","original","next","createWithChecksFp","Button","proxy","postEventDefaulted","storage","onClick","offClick","captureSameReq","reqId","req_id","releases","stateful","Stateful","mountable","wrapOptions","wrapSupportedPlain","getReleaseVersion","wrapMountedEither","compareVersions","parts","bParts","len","aParts","aVal","bVal","nothing","paramOrVersion","inVersion","wrapped","setFp","setFalse","setTrue","onUnsupported","onUnsupportedOrMode","MethodUnsupportedError","any","invokeCustomMethodFp","requestId","BackButton","TE.chain","invokeCustomMethod","requestFp","request","applyPolyfills","decodeBase64UrlFp","decodeBase64Url","encodeBase64Url","p1","button","createStartParamFp","b64","createStartParam","sharedFeatureOptions","arg2","decodeStartParamFp","createFnOption","mix","createSignal","postEventFpSignal","_postEventFp","withPostEvent","E.chain","decoded","createComponentSessionStorage","J.parse","isSafeToCreateStartParam","getFirstNavigationEntry","entry","withStateRestore","storageName","withVersion","buttonOptions","trackedClickEvent","backButton","AsyncMountable","TE.map","notAvailableError","eventToState","available","tokenSaved","deviceId","accessRequested","accessGranted","Biometry","onInfoReceived","offInfoReceived","wrapSupportedEither","wrapSupportedTask","wrapMountedTask","response","events","_requestFp","_request2Fp","withRequest","biometry","ClosingBehavior","setClosingConfirmation","isConfirmationEnabled","closingBehavior","CloudStorage","keyOrKeys","keys","values","record","array","lastRequestId","createRequestId","withInvokeCustomMethod","cloudStorage","DeviceStorage","invokeMethod","withCreateRequestId","deviceStorage","create","rest","requestEmojiStatusAccessFp","requestEmojiStatusAccess","customEmojiId","SetEmojiStatusError","setEmojiStatusFp","setEmojiStatus","HapticFeedback","HAPTIC_METHOD_NAME","wrapSupported","style","hapticFeedback","addToHomeScreenFp","addToHomeScreen","checkHomeScreenStatusFp","checkHomeScreenStatus","InitData","retrieveInitData","authDateValue","canSendAfterValue","E.Do","E.bindW","tgWebAppData","O.Do","O.bind","Invoice","isOpened","toggleClosed","slug","url","hostname","pathname","invoice","openLinkFp","openLink","openTelegramLinkFp","openTelegramLink","text","shareURLFp","shareURL","LocationManager","locationManager","MainButton","defaults","withDefault","field","getDefault","fromState","setCssVar","deleteCssVar","isColorDarkFp","modifier","dec","isColorDark","ThemeParams","offChange","getCSSVarName","forEachEntry","actualize","globalThemeParams","bottomButtonOptions","mainButton","MiniApp","theme","onVisibilityChanged","offVisibilityChanged","visibilityChangedListener","themeChangedListener","rgbBasedOn","computedRgbBasedOn","isCssVarsBound","cssVar","camelToKebab","genColorToolset","stateKey","rawColor","rgbColor","fp","withBasicEither","returnBack","miniApp","prepareParams","title","paramsButtons","buttons","id","Popup","preparedOptions","popup","requestPhoneAccessFp","requestPhoneAccess","createComplete","getContact","toStringResult","safeParse","toParsedResult","valiPipe","getContactWithErrorsIgnore","contact","pollContact","ctx","sleepTime","status","AccessDeniedError","createParsed","requestContact","requestContactCompleteFp","requestContactComplete","requestContactFp","requestWriteAccessFp","requestWriteAccess","QrScanner","onClosed","onTextReceived","setClosed","captured","qr","addToCleanup","onSettled","isOpenedValue","qrScanner","SecondaryButton","secondaryButton","SecureStorage","secureStorage","SettingsButton","settingsButton","SwipeBehavior","setVerticalEnabled","isVerticalEnabled","swipeBehavior","copyTextToClipboard","clipboard","textArea","fileName","downloadFileFp","downloadFile","parsed","getCurrentTimeFp","getCurrentTime","hideKeyboardFp","hideKeyboard","readTextFromClipboardFp","readTextFromClipboard","retrieveAndroidDeviceDataFrom","userAgent","appVersion","systemInfo","retrieveAndroidDeviceData","size","sendDataFp","sendData","messageId","shareMessageFp","shareMessage","mediaUrl","shareStoryFp","shareStory","isInlineMode","query","chatTypes","switchInlineQueryFp","switchInlineQuery","Viewport","onContentSafeAreaInsetsChanged","onSafeAreaInsetsChanged","onViewportChanged","onFullscreenChanged","offContentSafeAreaInsetsChanged","offFullscreenChanged","offSafeAreaInsetsChanged","offViewportChanged","isViewportStable","isFullscreen","initialInsets","viewportChangedListener","fullscreenChangedListener","safeAreaInsetsChangedListener","contentSafeAreaInsetsChangedListener","genRequestInsets","kind","genFlag","flag","TE.Do","TE.bindW","shared","viewport","saBased","csaBased","wrapTask","wrapFullscreenTask","genFullscreenFn","enable","settings","setting","createListeners","viewportListeners","fullscreenListeners","safeAreaListeners","contentSafeAreaListeners","lp","initFp","optionsVersion","optionsInlineMode","optionsThemeParams","E.matchW","acceptCustomStyles","html","init","createContext","AppRootContext","isRendered","ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind","isThenable","promise","then","dispatchAppRouterAction","useActionQueue","dispatch","action","Error","__DEV__","process","env","NODE_ENV","promisesWithDebugInfo","WeakMap","actionQueue","setState","React","useState","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","useMemo","promiseWithDebugInfo","undefined","debugInfo","Promise","asyncState","_debugInfo","use","callServer","actionId","actionArgs","startTransition","findSourceMapURL","basePath","__NEXT_ROUTER_BASEPATH","filename","startsWith","document","location","includes","URL","searchParams","href"],"mappings":"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","ignoreList":[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,181,182,183,184,185,186,187,188]}